---
phase: 09-communication-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/templateEngine.ts
  - src/main/index.ts
  - src/main/preload.ts
  - src/renderer/components/templates/TemplateEditor.tsx
  - src/renderer/components/templates/TemplateList.tsx
  - src/renderer/components/templates/VariableDropdown.tsx
  - src/renderer/stores/templateStore.ts
  - src/renderer/routes/ProjectLayout.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a new SMS template with name and body"
    - "User can create a new email template with name, subject, and body"
    - "User can insert variables from a dropdown menu into template body"
    - "User sees a live preview of the template with example data as they type"
    - "User can edit existing templates"
    - "User can delete templates"
  artifacts:
    - path: "src/main/templateEngine.ts"
      provides: "Template variable substitution and available variables list"
      exports: ["renderTemplate", "previewTemplate", "AVAILABLE_VARIABLES"]
    - path: "src/renderer/components/templates/TemplateEditor.tsx"
      provides: "Side-by-side template editing with live preview"
      min_lines: 120
    - path: "src/renderer/components/templates/TemplateList.tsx"
      provides: "List of templates with edit/delete actions"
      min_lines: 80
    - path: "src/renderer/stores/templateStore.ts"
      provides: "Zustand store for template CRUD operations"
      exports: ["useTemplateStore"]
  key_links:
    - from: "src/renderer/components/templates/TemplateEditor.tsx"
      to: "src/main/templateEngine.ts"
      via: "IPC invoke preview-template"
      pattern: "api\\.previewTemplate"
    - from: "src/renderer/stores/templateStore.ts"
      to: "window.api.createTemplate"
      via: "IPC invoke"
      pattern: "api\\.createTemplate"
---

<objective>
Build the template engine and template authoring UI for SMS and email message templates.

Purpose: Users need to create reusable message templates with dynamic variable substitution before they can send outreach messages. This enables personalized candidate communication at scale.

Output: Template engine with {{variable}} substitution, TemplateEditor with side-by-side live preview, TemplateList for managing templates, VariableDropdown for inserting variables, IPC handlers for template CRUD.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-communication-infrastructure/09-RESEARCH.md
@.planning/phases/09-communication-infrastructure/09-CONTEXT.md
@src/main/database.ts
@src/renderer/types/communication.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template engine with variable substitution</name>
  <files>
    src/main/templateEngine.ts
    src/renderer/types/communication.ts
  </files>
  <action>
Create `src/main/templateEngine.ts`:

```typescript
/**
 * Template variable substitution engine.
 * Uses {{variable}} syntax for placeholder replacement.
 */

export interface TemplateVariables {
  candidate_name: string;
  candidate_first_name: string;
  candidate_email?: string;
  candidate_phone?: string;
  role_title: string;
  company_name: string;
  recruiter_name?: string;
  recruiter_phone?: string;
  recruiter_email?: string;
}

/**
 * Available variables for template authoring.
 * Used by UI to populate the variable dropdown.
 */
export const AVAILABLE_VARIABLES: {
  key: keyof TemplateVariables;
  label: string;
  example: string;
  category: "candidate" | "role" | "recruiter";
}[] = [
  {
    key: "candidate_name",
    label: "Candidate Name",
    example: "John Smith",
    category: "candidate",
  },
  {
    key: "candidate_first_name",
    label: "Candidate First Name",
    example: "John",
    category: "candidate",
  },
  {
    key: "candidate_email",
    label: "Candidate Email",
    example: "john.smith@email.com",
    category: "candidate",
  },
  {
    key: "candidate_phone",
    label: "Candidate Phone",
    example: "+1 555 987 6543",
    category: "candidate",
  },
  {
    key: "role_title",
    label: "Role Title",
    example: "Senior Software Engineer",
    category: "role",
  },
  {
    key: "company_name",
    label: "Company Name",
    example: "TechCorp Ltd",
    category: "role",
  },
  {
    key: "recruiter_name",
    label: "Recruiter Name",
    example: "Jane Doe",
    category: "recruiter",
  },
  {
    key: "recruiter_phone",
    label: "Recruiter Phone",
    example: "+1 555 123 4567",
    category: "recruiter",
  },
  {
    key: "recruiter_email",
    label: "Recruiter Email",
    example: "jane@recruit.com",
    category: "recruiter",
  },
];

/**
 * Build example data object from AVAILABLE_VARIABLES.
 */
function getExampleData(): TemplateVariables {
  const data: Partial<TemplateVariables> = {};
  for (const v of AVAILABLE_VARIABLES) {
    (data as Record<string, string>)[v.key] = v.example;
  }
  return data as TemplateVariables;
}

/**
 * Render a template by replacing {{variable}} with values.
 * Unmatched variables are left as-is (for visibility).
 */
export function renderTemplate(
  template: string,
  variables: Partial<TemplateVariables>,
): string {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    const value = variables[key as keyof TemplateVariables];
    return value !== undefined ? String(value) : match;
  });
}

/**
 * Preview a template with example data.
 * Used for live preview in the template editor.
 */
export function previewTemplate(template: string): string {
  return renderTemplate(template, getExampleData());
}

/**
 * Extract all variable names used in a template.
 * Returns array of variable keys found in the template.
 */
export function extractTemplateVariables(template: string): string[] {
  const matches = template.matchAll(/\{\{(\w+)\}\}/g);
  const variables = new Set<string>();
  for (const match of matches) {
    variables.add(match[1]);
  }
  return Array.from(variables);
}

/**
 * Validate that all variables in template are known variables.
 * Returns array of unknown variable names.
 */
export function validateTemplateVariables(template: string): string[] {
  const used = extractTemplateVariables(template);
  const known = new Set(AVAILABLE_VARIABLES.map((v) => v.key));
  return used.filter((v) => !known.has(v as keyof TemplateVariables));
}
```

Add to `src/renderer/types/communication.ts`:

```typescript
// Template types
export interface MessageTemplate {
  id: string;
  projectId: string;
  name: string;
  type: "sms" | "email";
  subject?: string; // For email only
  body: string;
  variablesJson?: string;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateTemplateInput {
  projectId: string;
  name: string;
  type: "sms" | "email";
  subject?: string;
  body: string;
}

export interface UpdateTemplateInput {
  name?: string;
  subject?: string;
  body?: string;
  isDefault?: boolean;
}

export interface TemplateVariable {
  key: string;
  label: string;
  example: string;
  category: "candidate" | "role" | "recruiter";
}
```

  </action>
  <verify>
- `npx tsc --noEmit` passes
- templateEngine.ts exports renderTemplate, previewTemplate, extractTemplateVariables, validateTemplateVariables, AVAILABLE_VARIABLES
  </verify>
  <done>
- Template engine with {{variable}} substitution implemented
- AVAILABLE_VARIABLES constant defines all supported variables
- Preview function generates example-populated output
- Validation function detects unknown variables
  </done>
</task>

<task type="auto">
  <name>Task 2: Add template IPC handlers and database CRUD</name>
  <files>
    src/main/index.ts
    src/main/preload.ts
    src/main/database.ts
  </files>
  <action>
Add template CRUD functions to `database.ts`:

```typescript
// ============================================================================
// Template CRUD Functions (Phase 9)
// ============================================================================

export interface TemplateRecord {
  id: string;
  project_id: string;
  name: string;
  type: string;
  subject: string | null;
  body: string;
  variables_json: string | null;
  is_default: number;
  created_at: string;
  updated_at: string;
}

export function createTemplate(input: {
  projectId: string;
  name: string;
  type: "sms" | "email";
  subject?: string;
  body: string;
}): TemplateRecord {
  const database = getDatabase();
  const id = crypto.randomUUID();
  const now = new Date().toISOString();

  // Extract variables from body for storage
  const variableMatches = input.body.matchAll(/\{\{(\w+)\}\}/g);
  const variables = Array.from(new Set([...variableMatches].map((m) => m[1])));

  database
    .prepare(
      `
    INSERT INTO outreach_templates (id, project_id, name, type, subject, body, variables_json, is_default, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, 0, ?, ?)
  `,
    )
    .run(
      id,
      input.projectId,
      input.name,
      input.type,
      input.subject || null,
      input.body,
      JSON.stringify(variables),
      now,
      now,
    );

  return {
    id,
    project_id: input.projectId,
    name: input.name,
    type: input.type,
    subject: input.subject || null,
    body: input.body,
    variables_json: JSON.stringify(variables),
    is_default: 0,
    created_at: now,
    updated_at: now,
  };
}

export function getTemplate(id: string): TemplateRecord | null {
  const database = getDatabase();
  return (
    (database
      .prepare("SELECT * FROM outreach_templates WHERE id = ?")
      .get(id) as TemplateRecord | undefined) ?? null
  );
}

export function getTemplatesByProject(projectId: string): TemplateRecord[] {
  const database = getDatabase();
  return database
    .prepare(
      "SELECT * FROM outreach_templates WHERE project_id = ? ORDER BY created_at DESC",
    )
    .all(projectId) as TemplateRecord[];
}

export function updateTemplate(
  id: string,
  updates: {
    name?: string;
    subject?: string;
    body?: string;
    isDefault?: boolean;
  },
): boolean {
  const database = getDatabase();
  const now = new Date().toISOString();

  const fields: string[] = ["updated_at = ?"];
  const values: unknown[] = [now];

  if (updates.name !== undefined) {
    fields.push("name = ?");
    values.push(updates.name);
  }
  if (updates.subject !== undefined) {
    fields.push("subject = ?");
    values.push(updates.subject);
  }
  if (updates.body !== undefined) {
    fields.push("body = ?");
    values.push(updates.body);
    // Re-extract variables
    const variableMatches = updates.body.matchAll(/\{\{(\w+)\}\}/g);
    const variables = Array.from(
      new Set([...variableMatches].map((m) => m[1])),
    );
    fields.push("variables_json = ?");
    values.push(JSON.stringify(variables));
  }
  if (updates.isDefault !== undefined) {
    fields.push("is_default = ?");
    values.push(updates.isDefault ? 1 : 0);
  }

  values.push(id);
  const result = database
    .prepare(`UPDATE outreach_templates SET ${fields.join(", ")} WHERE id = ?`)
    .run(...values);
  return result.changes > 0;
}

export function deleteTemplate(id: string): boolean {
  const database = getDatabase();
  const result = database
    .prepare("DELETE FROM outreach_templates WHERE id = ?")
    .run(id);
  return result.changes > 0;
}
```

Add IPC handlers to `index.ts`:

```typescript
import { previewTemplate, AVAILABLE_VARIABLES } from "./templateEngine";
import {
  createTemplate,
  getTemplate,
  getTemplatesByProject,
  updateTemplate,
  deleteTemplate as deleteTemplateDB,
} from "./database";

// Template IPC handlers
ipcMain.handle(
  "create-template",
  async (
    _event,
    input: {
      projectId: string;
      name: string;
      type: "sms" | "email";
      subject?: string;
      body: string;
    },
  ) => {
    try {
      const template = createTemplate(input);
      return { success: true, data: template };
    } catch (error) {
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Failed to create template",
      };
    }
  },
);

ipcMain.handle("get-template", async (_event, id: string) => {
  try {
    const template = getTemplate(id);
    if (!template) return { success: false, error: "Template not found" };
    return { success: true, data: template };
  } catch (error) {
    return { success: false, error: String(error) };
  }
});

ipcMain.handle(
  "get-templates-by-project",
  async (_event, projectId: string) => {
    try {
      const templates = getTemplatesByProject(projectId);
      return { success: true, data: templates };
    } catch (error) {
      return { success: false, error: String(error) };
    }
  },
);

ipcMain.handle(
  "update-template",
  async (
    _event,
    id: string,
    updates: {
      name?: string;
      subject?: string;
      body?: string;
      isDefault?: boolean;
    },
  ) => {
    try {
      const success = updateTemplate(id, updates);
      return { success };
    } catch (error) {
      return { success: false, error: String(error) };
    }
  },
);

ipcMain.handle("delete-template", async (_event, id: string) => {
  try {
    const success = deleteTemplateDB(id);
    return { success };
  } catch (error) {
    return { success: false, error: String(error) };
  }
});

ipcMain.handle("preview-template", async (_event, template: string) => {
  try {
    const preview = previewTemplate(template);
    return { success: true, data: preview };
  } catch (error) {
    return { success: false, error: String(error) };
  }
});

ipcMain.handle("get-available-variables", async () => {
  return { success: true, data: AVAILABLE_VARIABLES };
});
```

Add preload API:

```typescript
// Template operations (Phase 9)

createTemplate: (input: {
  projectId: string;
  name: string;
  type: 'sms' | 'email';
  subject?: string;
  body: string;
}): Promise<{ success: boolean; data?: unknown; error?: string }> =>
  ipcRenderer.invoke('create-template', input),

getTemplate: (id: string): Promise<{ success: boolean; data?: unknown; error?: string }> =>
  ipcRenderer.invoke('get-template', id),

getTemplatesByProject: (projectId: string): Promise<{ success: boolean; data?: unknown[]; error?: string }> =>
  ipcRenderer.invoke('get-templates-by-project', projectId),

updateTemplate: (id: string, updates: {
  name?: string;
  subject?: string;
  body?: string;
  isDefault?: boolean;
}): Promise<{ success: boolean; error?: string }> =>
  ipcRenderer.invoke('update-template', id, updates),

deleteTemplateById: (id: string): Promise<{ success: boolean; error?: string }> =>
  ipcRenderer.invoke('delete-template', id),

previewTemplate: (template: string): Promise<{ success: boolean; data?: string; error?: string }> =>
  ipcRenderer.invoke('preview-template', template),

getAvailableVariables: (): Promise<{ success: boolean; data?: Array<{ key: string; label: string; example: string; category: string }> }> =>
  ipcRenderer.invoke('get-available-variables'),
```

  </action>
  <verify>
- `npx tsc --noEmit` passes
- IPC handlers registered for all 7 template operations
  </verify>
  <done>
- Template CRUD functions in database.ts
- 7 IPC handlers for template operations
- Preload exposes template API methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Create template UI components and store</name>
  <files>
    src/renderer/stores/templateStore.ts
    src/renderer/components/templates/TemplateEditor.tsx
    src/renderer/components/templates/TemplateList.tsx
    src/renderer/components/templates/VariableDropdown.tsx
    src/renderer/routes/ProjectLayout.tsx
  </files>
  <action>
Create `src/renderer/stores/templateStore.ts`:

```typescript
import { create } from "zustand";
import type {
  MessageTemplate,
  CreateTemplateInput,
  UpdateTemplateInput,
  TemplateVariable,
} from "../types/communication";

interface TemplateState {
  templates: MessageTemplate[];
  selectedTemplateId: string | null;
  availableVariables: TemplateVariable[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setTemplates: (templates: MessageTemplate[]) => void;
  selectTemplate: (id: string | null) => void;
  setAvailableVariables: (variables: TemplateVariable[]) => void;
  setIsLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;

  // Async actions
  loadTemplates: (projectId: string) => Promise<void>;
  loadVariables: () => Promise<void>;
  createTemplate: (
    input: CreateTemplateInput,
  ) => Promise<MessageTemplate | null>;
  updateTemplate: (
    id: string,
    updates: UpdateTemplateInput,
  ) => Promise<boolean>;
  deleteTemplate: (id: string) => Promise<boolean>;
}

export const useTemplateStore = create<TemplateState>((set, get) => ({
  templates: [],
  selectedTemplateId: null,
  availableVariables: [],
  isLoading: false,
  error: null,

  setTemplates: (templates) => set({ templates }),
  selectTemplate: (id) => set({ selectedTemplateId: id }),
  setAvailableVariables: (variables) => set({ availableVariables: variables }),
  setIsLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),

  loadTemplates: async (projectId) => {
    set({ isLoading: true, error: null });
    const result = await window.api.getTemplatesByProject(projectId);
    if (result.success && result.data) {
      set({ templates: result.data as MessageTemplate[], isLoading: false });
    } else {
      set({
        error: result.error || "Failed to load templates",
        isLoading: false,
      });
    }
  },

  loadVariables: async () => {
    const result = await window.api.getAvailableVariables();
    if (result.success && result.data) {
      set({ availableVariables: result.data as TemplateVariable[] });
    }
  },

  createTemplate: async (input) => {
    const result = await window.api.createTemplate(input);
    if (result.success && result.data) {
      const template = result.data as MessageTemplate;
      set((state) => ({ templates: [template, ...state.templates] }));
      return template;
    }
    return null;
  },

  updateTemplate: async (id, updates) => {
    const result = await window.api.updateTemplate(id, updates);
    if (result.success) {
      set((state) => ({
        templates: state.templates.map((t) =>
          t.id === id
            ? { ...t, ...updates, updatedAt: new Date().toISOString() }
            : t,
        ),
      }));
      return true;
    }
    return false;
  },

  deleteTemplate: async (id) => {
    const result = await window.api.deleteTemplateById(id);
    if (result.success) {
      set((state) => ({
        templates: state.templates.filter((t) => t.id !== id),
        selectedTemplateId:
          state.selectedTemplateId === id ? null : state.selectedTemplateId,
      }));
      return true;
    }
    return false;
  },
}));
```

Create `src/renderer/components/templates/VariableDropdown.tsx`:

```typescript
import { Button } from '../ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '../ui/dropdown-menu';
import { ChevronDown } from 'lucide-react';
import type { TemplateVariable } from '../../types/communication';

interface VariableDropdownProps {
  variables: TemplateVariable[];
  onInsert: (variableKey: string) => void;
}

export function VariableDropdown({ variables, onInsert }: VariableDropdownProps) {
  const candidateVars = variables.filter(v => v.category === 'candidate');
  const roleVars = variables.filter(v => v.category === 'role');
  const recruiterVars = variables.filter(v => v.category === 'recruiter');

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm">
          Insert Variable <ChevronDown className="ml-2 h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="start" className="w-56">
        <DropdownMenuLabel>Candidate</DropdownMenuLabel>
        {candidateVars.map(v => (
          <DropdownMenuItem key={v.key} onClick={() => onInsert(v.key)}>
            <span className="font-medium">{v.label}</span>
            <span className="ml-auto text-xs text-muted-foreground">{v.example}</span>
          </DropdownMenuItem>
        ))}
        <DropdownMenuSeparator />
        <DropdownMenuLabel>Role</DropdownMenuLabel>
        {roleVars.map(v => (
          <DropdownMenuItem key={v.key} onClick={() => onInsert(v.key)}>
            <span className="font-medium">{v.label}</span>
            <span className="ml-auto text-xs text-muted-foreground">{v.example}</span>
          </DropdownMenuItem>
        ))}
        <DropdownMenuSeparator />
        <DropdownMenuLabel>Recruiter</DropdownMenuLabel>
        {recruiterVars.map(v => (
          <DropdownMenuItem key={v.key} onClick={() => onInsert(v.key)}>
            <span className="font-medium">{v.label}</span>
            <span className="ml-auto text-xs text-muted-foreground">{v.example}</span>
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export default VariableDropdown;
```

Create `src/renderer/components/templates/TemplateEditor.tsx`:

Build a side-by-side editor:

- Left side: Template form (name, type, subject for email, body textarea)
- Right side: Live preview (updates as user types)
- Top toolbar: Variable dropdown, Save button, Cancel button
- For SMS: Show character count and segment estimate (160 chars per segment)
- For email: Subject line required
- Preview calls previewTemplate via IPC or does client-side substitution with example data

```typescript
// Key features:
// - useState for form fields (name, type, subject, body)
// - useMemo to compute preview from body using example variables (client-side for instant feedback)
// - VariableDropdown that inserts {{variable}} at cursor or appends
// - Save button calls createTemplate or updateTemplate depending on mode
// - Cancel button resets form or closes editor
```

Create `src/renderer/components/templates/TemplateList.tsx`:

- List templates with name, type badge (SMS/Email), and created date
- Click to select for editing
- Delete button with confirmation
- "New Template" button to start creating
- Filter tabs: All, SMS, Email
- Empty state: "No templates yet. Create your first template."

Update `ProjectLayout.tsx`:

- Add link/route for templates management (e.g., button in header that opens Templates sheet, or navigate to /project/:id/templates)
- Could be accessed from a dropdown menu or dedicated button
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npx vitest run` passes
- TemplateEditor, TemplateList, VariableDropdown all export default components
  </verify>
  <done>
- TemplateEditor shows side-by-side edit and preview
- VariableDropdown allows inserting variables by category
- TemplateList shows all templates with filtering
- Templates can be created, edited, and deleted
- Store manages template state and API calls
  </done>
  </task>

</tasks>

<verification>
1. Navigate to a project, access template management
2. Click "New Template", select SMS, enter name and body with {{candidate_name}}
3. See live preview show "John Smith" where variable was
4. Save template, see it appear in list
5. Edit template, change body, save again
6. Delete template with confirmation
7. Create email template with subject and body
8. `npx tsc --noEmit` passes
9. `npx vitest run` passes
</verification>

<success_criteria>

- User can create SMS and email templates with names
- User can insert variables from categorized dropdown
- Live preview shows rendered template with example data
- Templates persist in database and reload on app restart
- User can edit and delete existing templates
  </success_criteria>

<output>
After completion, create `.planning/phases/09-communication-infrastructure/09-02-SUMMARY.md`
</output>
