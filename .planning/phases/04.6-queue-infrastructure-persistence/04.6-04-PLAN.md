---
phase: 04.6-queue-infrastructure-persistence
plan: 04
type: execute
wave: 3
depends_on: ["04.6-02", "04.6-03"]
files_modified:
  - src/renderer/stores/queueStore.ts
  - src/renderer/components/queue/DropZone.tsx
  - src/renderer/App.tsx
autonomous: true

must_haves:
  truths:
    - "DropZone uses enqueueCV instead of extractCV for file submission"
    - "Renderer subscribes to queue status updates on mount"
    - "Queue items persist across navigation between projects"
    - "Real-time status updates reflected in queue UI"
  artifacts:
    - path: "src/renderer/stores/queueStore.ts"
      provides: "Queue store with loadFromDatabase including queued items"
      contains: "onQueueStatusUpdate"
    - path: "src/renderer/components/queue/DropZone.tsx"
      provides: "DropZone using enqueueCV"
      contains: "enqueueCV"
  key_links:
    - from: "src/renderer/App.tsx"
      to: "queue-status-update subscription"
      via: "useEffect with onQueueStatusUpdate"
      pattern: "window\\.api\\.onQueueStatusUpdate"
    - from: "src/renderer/components/queue/DropZone.tsx"
      to: "window.api.enqueueCV"
      via: "enqueue call"
      pattern: "window\\.api\\.enqueueCV"
---

<objective>
Update renderer to use queue infrastructure for CV processing.

Purpose: Connect the renderer to the new queue system. DropZone enqueues CVs (instant), and App subscribes to push updates for real-time status changes. Queue loads both completed AND queued items from database.

Output: Renderer using queue-based submission with real-time updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.6-queue-infrastructure-persistence/04.6-RESEARCH.md
@.planning/phases/04.6-queue-infrastructure-persistence/04.6-02-SUMMARY.md
@.planning/phases/04.6-queue-infrastructure-persistence/04.6-03-SUMMARY.md
@src/renderer/stores/queueStore.ts
@src/renderer/components/queue/DropZone.tsx
@src/renderer/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update queueStore to load queued items and handle push updates</name>
  <files>src/renderer/stores/queueStore.ts</files>
  <action>
Update `src/renderer/stores/queueStore.ts`:

1. Import the new QueueStatusUpdate type:
```typescript
import type { QueueItem, QueueStatus, ProcessingStage, QueueStatusUpdate } from '../types/cv';
```

2. Update `loadFromDatabase` to also load queued/processing items:
```typescript
loadFromDatabase: async () => {
  try {
    const projectId = useProjectStore.getState().activeProjectId;

    // Load completed CVs
    const completedResult = await window.api.getAllCVs(projectId || undefined);
    const completedItems: QueueItem[] = completedResult.success && completedResult.data
      ? completedResult.data.map((cv) => ({
          id: cv.id,
          fileName: cv.file_name,
          fileType: cv.file_name.split('.').pop()?.toLowerCase() || 'unknown',
          filePath: cv.file_path || '',
          status: 'completed' as QueueStatus,
          parseConfidence: cv.parse_confidence,
          createdAt: cv.created_at,
        }))
      : [];

    // Load queued/processing CVs
    const queuedResult = await window.api.getQueuedCVs(projectId || undefined);
    const queuedItems: QueueItem[] = queuedResult.success && queuedResult.data
      ? queuedResult.data.map((cv) => ({
          id: cv.id,
          fileName: cv.file_name,
          fileType: cv.file_name.split('.').pop()?.toLowerCase() || 'unknown',
          filePath: cv.file_path,
          status: cv.status === 'queued' ? 'queued' as QueueStatus :
                  cv.status === 'processing' ? 'submitted' as QueueStatus :
                  cv.status as QueueStatus,
          stage: cv.status === 'processing' ? 'Extracting...' as ProcessingStage : undefined,
          error: cv.error_message || undefined,
          createdAt: cv.created_at,
        }))
      : [];

    // Combine and sort by createdAt (newest first)
    const allItems = [...queuedItems, ...completedItems];
    allItems.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    set({ items: allItems });
  } catch (err) {
    console.error('Failed to load CVs from database:', err);
  }
},
```

3. Add a new action for handling queue status updates:
```typescript
handleQueueStatusUpdate: (update: QueueStatusUpdate) => {
  const { items, updateStatus, updateStage } = get();

  switch (update.status) {
    case 'queued':
      // Item already added via addItem, nothing to do
      break;

    case 'processing':
      // Find item and update to submitted/extracting
      updateStage(update.id, 'Extracting...');
      break;

    case 'completed':
      updateStatus(update.id, 'completed', {
        data: update.data,
        parseConfidence: update.parseConfidence,
      });
      break;

    case 'failed':
      updateStatus(update.id, 'failed', { error: update.error });
      break;
  }
},
```

4. Update the interface to include the new action:
```typescript
interface QueueStore {
  // ... existing properties ...
  handleQueueStatusUpdate: (update: QueueStatusUpdate) => void;
}
```
  </action>
  <verify>TypeScript compiles. loadFromDatabase loads both queued and completed items.</verify>
  <done>queueStore loads queued items from database and handles push updates.</done>
</task>

<task type="auto">
  <name>Task 2: Update DropZone to use enqueueCV</name>
  <files>src/renderer/components/queue/DropZone.tsx</files>
  <action>
Update `src/renderer/components/queue/DropZone.tsx` to use the new queue API:

1. Simplify processFile to use enqueueCV (which is instant):
```typescript
const processFile = useCallback(
  async (fileName: string, filePath: string) => {
    const fileType = fileName.split('.').pop()?.toLowerCase() || 'unknown';

    try {
      // Enqueue CV - this is instant, just persists to DB
      const result = await window.api.enqueueCV(fileName, filePath, activeProjectId || undefined);

      if (result.success && result.id) {
        // Add to queue store with 'queued' status
        // Status updates will come via push notifications
        addItem({
          id: result.id,
          fileName,
          fileType,
          filePath,
          status: 'queued',
          stage: 'Queued...',
        });
      } else {
        // Failed to enqueue - add as failed item locally
        addItem({
          fileName,
          fileType,
          filePath,
          status: 'failed',
          error: result.error || 'Failed to enqueue',
        });
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      addItem({
        fileName,
        fileType,
        filePath,
        status: 'failed',
        error: errorMessage,
      });
    }
  },
  [addItem, activeProjectId]
);
```

2. Remove unused imports and state that are no longer needed:
- Remove: `updateStatus`, `updateStage`, `updateItemId` from useQueueStore destructuring
- The DropZone no longer manages status transitions - the QueueManager does that

3. Keep handleDrop the same (processes files sequentially), but it's now faster since enqueue is instant:
```typescript
const handleDrop = useCallback(
  async (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    const validExtensions = ['.pdf', '.docx', '.doc'];

    // Process files - enqueue is instant, so this is fast
    for (const file of files) {
      const ext = '.' + file.name.split('.').pop()?.toLowerCase();
      if (!validExtensions.includes(ext)) {
        console.warn(`Skipping unsupported file: ${file.name}`);
        continue;
      }

      const filePath = window.electronFile.getPath(file);
      if (filePath) {
        await processFile(file.name, filePath);
      }
    }
  },
  [processFile]
);
```
  </action>
  <verify>TypeScript compiles. DropZone uses enqueueCV and adds items with 'queued' status.</verify>
  <done>DropZone uses enqueueCV for instant submission. Status updates come via push.</done>
</task>

<task type="auto">
  <name>Task 3: Subscribe to queue status updates in App.tsx</name>
  <files>src/renderer/App.tsx</files>
  <action>
Update `src/renderer/App.tsx` to subscribe to queue status updates:

1. Import the queueStore:
```typescript
import { useQueueStore } from './stores/queueStore';
```

2. Add a useEffect to subscribe to queue status updates. This should be near the top of the App component, before the return statement:
```typescript
// Subscribe to queue status updates from main process
useEffect(() => {
  const handleStatusUpdate = useQueueStore.getState().handleQueueStatusUpdate;

  window.api.onQueueStatusUpdate((update) => {
    console.log('Queue status update:', update);
    handleStatusUpdate(update);
  });

  // Cleanup on unmount
  return () => {
    window.api.removeQueueStatusListener();
  };
}, []);
```

Note: This effect runs once on app mount and sets up the listener. The cleanup ensures no memory leaks.
  </action>
  <verify>TypeScript compiles. Console logs queue status updates when CVs are processed.</verify>
  <done>App.tsx subscribes to queue status updates on mount and cleans up on unmount.</done>
</task>

</tasks>

<verification>
1. App starts without errors
2. Drop a CV file - it appears as "Queued..." immediately
3. Status changes to "Extracting..." when Python starts processing
4. Status changes to "Completed" or "Failed" when done
5. Navigate to Dashboard and back - queued items persist
6. TypeScript compiles: `npm run typecheck` passes
</verification>

<success_criteria>
- CVs persist immediately on drop (before processing starts)
- Status updates appear in real-time
- Queue survives navigation between projects
- Timeout only triggers AFTER Python starts processing
</success_criteria>

<output>
After completion, create `.planning/phases/04.6-queue-infrastructure-persistence/04.6-04-SUMMARY.md`
</output>
