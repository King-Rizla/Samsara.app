---
phase: 10-outreach-workflow-engine
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/main/replyPoller.ts
  - src/main/workingHours.ts
  - src/main/callbackScheduler.ts
  - src/main/workflowMachine.ts
  - src/main/workflowService.ts
  - src/main/database.ts
  - src/main/index.ts
  - src/main/preload.ts
autonomous: true

must_haves:
  truths:
    - "System polls for inbound SMS replies every 30 seconds"
    - "Reply with positive intent triggers AI call escalation"
    - "Reply with negative intent archives the workflow"
    - "Messages queued outside working hours are sent when hours resume"
    - "Missed timeout escalations are re-triggered on app startup for contacted workflows past their timeout window"
    - "Project settings control escalation timeout and working hours"
    - "Post-failed-screening candidate reply triggers callback scheduling flow (WRK-05)"
  artifacts:
    - path: "src/main/replyPoller.ts"
      provides: "Inbound SMS polling and intent classification"
      exports:
        [
          "startReplyPolling",
          "stopReplyPolling",
          "classifyIntent",
          "processInboundMessages",
        ]
    - path: "src/main/workingHours.ts"
      provides: "Working hours check and message queueing"
      exports:
        [
          "isWithinWorkingHours",
          "getNextWorkingHoursStart",
          "queueMessageForWorkingHours",
        ]
    - path: "src/main/callbackScheduler.ts"
      provides: "Post-failed-screening callback slot generation and scheduling (WRK-05)"
      exports:
        [
          "generateCallbackSlots",
          "scheduleCallback",
          "sendCallbackOptions",
          "processCallbackReply",
        ]
  key_links:
    - from: "src/main/replyPoller.ts"
      to: "src/main/workflowService.ts"
      via: "sends REPLY_DETECTED events to workflow actors"
      pattern: "sendWorkflowEvent.*REPLY_DETECTED"
    - from: "src/main/workingHours.ts"
      to: "src/main/communicationService.ts"
      via: "delays message sending until working hours"
      pattern: "sendSMS|sendEmail"
    - from: "src/main/callbackScheduler.ts"
      to: "src/main/workingHours.ts"
      via: "uses working hours to generate valid callback slots"
      pattern: "isWithinWorkingHours|getNextWorkingHoursStart"
    - from: "src/main/replyPoller.ts"
      to: "src/main/callbackScheduler.ts"
      via: "routes failed-screening replies to callback processing"
      pattern: "processCallbackReply"
---

<objective>
Implement reply detection polling, intent classification, working hours queueing, and escalation timeout handling for app restart recovery.

Purpose: The workflow engine needs to detect candidate replies to trigger escalation, respect working hours to avoid late-night messages, and recover missed escalations after app restarts. This plan adds the temporal and reactive behaviors that make the state machine respond to real-world events.

Output:

- Reply polling service that detects inbound SMS and classifies intent
- Working hours service that queues messages and delays outreach
- Project settings for escalation timeout and working hours
- App restart catch-up for missed escalations
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-outreach-workflow-engine/10-RESEARCH.md
@.planning/phases/10-outreach-workflow-engine/10-CONTEXT.md
@.planning/phases/10-outreach-workflow-engine/10-01-SUMMARY.md
@src/main/workflowService.ts
@src/main/communicationService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reply polling service with intent classification</name>
  <files>
    src/main/replyPoller.ts
    src/main/database.ts
  </files>
  <action>
    1. Create src/main/replyPoller.ts:

    Define keyword lists (per CONTEXT.md - Claude's discretion on exact lists):
    ```typescript
    const POSITIVE_KEYWORDS = ['yes', 'interested', 'call', 'available', 'sure', 'okay', 'ok', 'sounds good', 'tell me more', 'when', 'what time'];
    const NEGATIVE_KEYWORDS = ['no', 'stop', 'unsubscribe', 'not interested', 'remove', 'no thanks', 'busy', 'wrong number'];
    ```

    Implement classifyIntent(body: string): 'positive' | 'negative' | 'ambiguous'
    - Check negative first (more specific)
    - Check positive
    - Default to 'ambiguous' (per CONTEXT.md: treat as positive)

    Implement pollInboundMessages(projectId: string): Promise<InboundMessage[]>
    - Get Twilio credentials from credentialManager
    - Use Twilio SDK to list inbound messages (direction === 'inbound') from last 30 minutes
    - Filter to messages sent TO our number
    - Return array of {from, body, timestamp, sid}

    Implement processInboundMessages(messages, projectId):
    - Build phone-to-candidateId map from outreach_workflows + cvs tables
    - For each inbound message:
      - Look up candidateId by normalized phone
      - If found and workflow exists, classify intent and call sendWorkflowEvent(candidateId, 'REPLY_DETECTED', {intent})
      - Store inbound message in messages table with direction='inbound', status='received'
      - Use the external_id column (message SID) + processed_at timestamp to track processing

    MESSAGE SID TRACKING SCHEMA (add to database.ts migration v7 or v8):
    - Add 'processed_at TEXT' column to messages table
    - Add UNIQUE constraint on external_id (the Twilio SID) in messages table
    - Query: SELECT 1 FROM messages WHERE external_id = ? to check if already processed
    - When storing inbound message, set processed_at = ISO timestamp
    - This approach uses the existing messages table rather than a separate processed_sids table

    Implement polling management:
    - startReplyPolling(projectId): setInterval every 30 seconds, store interval reference
    - stopReplyPolling(): clearInterval
    - Export functions

    2. Add database helper in database.ts or inline:
    - getCandidateIdByPhone(phone, projectId): Query cvs joined with outreach_workflows to find candidate
    - isMessageProcessed(sid): Check if SID already in messages table

  </action>
  <verify>
    - npx tsc --noEmit passes
    - replyPoller.ts exports classifyIntent, startReplyPolling, stopReplyPolling, processInboundMessages
    - Keyword lists cover common positive/negative responses
  </verify>
  <done>
    Reply polling service polls Twilio every 30 seconds for inbound SMS, classifies intent, and sends REPLY_DETECTED events to matching workflow actors. Inbound messages are stored in database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement working hours and message queueing</name>
  <files>
    src/main/workingHours.ts
    src/main/database.ts
    src/main/workflowMachine.ts
  </files>
  <action>
    1. Create src/main/workingHours.ts:

    Define WorkingHoursConfig interface:
    ```typescript
    interface WorkingHoursConfig {
      enabled: boolean;
      startHour: number;  // 0-23
      startMinute: number;  // 0-59
      endHour: number;
      endMinute: number;
      timezone: string;  // e.g., 'America/New_York'
      workDays: number[];  // 0=Sunday, 1=Monday, etc.
    }
    ```

    Implement isWithinWorkingHours(config: WorkingHoursConfig): boolean
    - If !config.enabled, return true (always within hours)
    - Get current time in configured timezone
    - Check if current day is in workDays
    - Check if current time is between start and end
    - Return boolean

    Implement getNextWorkingHoursStart(config: WorkingHoursConfig): Date
    - Calculate next valid working hours start time
    - Used for scheduling delayed messages

    Implement queueMessageForWorkingHours(projectId, candidateId, type, payload):
    - Check if within working hours
    - If yes, return {send: true}
    - If no, calculate delay until working hours start
    - Store in message_queue table (or use XState delayed action)
    - Return {send: false, scheduledFor: Date}

    2. Add database migration or table for project outreach settings:
    ```sql
    -- Add to migration v7 or create v8 if already migrated
    CREATE TABLE IF NOT EXISTS project_outreach_settings (
      project_id TEXT PRIMARY KEY,
      escalation_timeout_ms INTEGER DEFAULT 1800000,  -- 30 min default
      ai_call_enabled INTEGER DEFAULT 1,
      working_hours_enabled INTEGER DEFAULT 0,
      working_hours_start TEXT DEFAULT '09:00',
      working_hours_end TEXT DEFAULT '17:00',
      working_hours_timezone TEXT DEFAULT 'America/New_York',
      working_hours_days TEXT DEFAULT '[1,2,3,4,5]',
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
    );
    ```

    3. Add getProjectOutreachSettings(projectId) and updateProjectOutreachSettings(projectId, settings) to database.ts

    4. Update workflowMachine.ts sendInitialMessages actor to check working hours before sending:
    - Import working hours functions
    - If outside working hours, queue message and schedule delayed send
    - Otherwise send immediately

  </action>
  <verify>
    - npx tsc --noEmit passes
    - workingHours.ts exports isWithinWorkingHours, getNextWorkingHoursStart
    - Project outreach settings table created in migration
    - getProjectOutreachSettings returns config or default values
  </verify>
  <done>
    Working hours service checks project configuration and queues messages for delivery during business hours. Project outreach settings stored in database with defaults (30 min timeout, AI calls enabled, working hours disabled by default).
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire polling and settings to app lifecycle</name>
  <files>
    src/main/index.ts
    src/main/preload.ts
    src/main/workflowService.ts
  </files>
  <action>
    1. Update src/main/index.ts:
       - Import startReplyPolling, stopReplyPolling from replyPoller
       - Start reply polling when OutreachSection is mounted (via IPC: 'start-reply-polling')
       - Stop reply polling when OutreachSection unmounts (via IPC: 'stop-reply-polling')
       - Add IPC handlers:
         - 'start-reply-polling': (_, projectId) => startReplyPolling(projectId)
         - 'stop-reply-polling': () => stopReplyPolling()
         - 'get-project-outreach-settings': (_, projectId) => getProjectOutreachSettings(projectId)
         - 'update-project-outreach-settings': (_, projectId, settings) => updateProjectOutreachSettings(projectId, settings)

    2. Update src/main/preload.ts:
       - Add to window.api:
         - startReplyPolling: (projectId) => ipcRenderer.invoke('start-reply-polling', projectId)
         - stopReplyPolling: () => ipcRenderer.invoke('stop-reply-polling')
         - getProjectOutreachSettings: (projectId) => ipcRenderer.invoke('get-project-outreach-settings', projectId)
         - updateProjectOutreachSettings: (projectId, settings) => ipcRenderer.invoke('update-project-outreach-settings', projectId, settings)

    3. Update workflowService.ts initializeWorkflows():
       - After restoring workflows, call executeMissedEscalations()
       - For each 'contacted' workflow where contactedAt + escalationTimeoutMs < now, send TIMEOUT event
       - Log "Executing missed escalation for {candidateId}"

    4. Enhance restoreActiveWorkflows() in workflowPersistence.ts:
       - Track which workflows need immediate escalation
       - Return both actors map and list of candidates needing escalation
       - Let initializeWorkflows() handle the escalation dispatch to avoid circular dependency

  </action>
  <verify>
    - npx tsc --noEmit passes
    - npm test passes
    - Reply polling IPC handlers registered
    - Project outreach settings IPC handlers registered
    - Missed escalation logic present in initializeWorkflows
  </verify>
  <done>
    Reply polling starts when OutreachSection mounts and stops on unmount. Project outreach settings accessible via IPC. App startup executes any missed escalations for workflows that should have timed out while app was closed.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement post-failed-screening callback scheduling (WRK-05)</name>
  <files>
    src/main/callbackScheduler.ts
    src/main/workflowMachine.ts
    src/main/database.ts
  </files>
  <action>
    1. Create src/main/callbackScheduler.ts:

    Define CallbackSlot interface:
    ```typescript
    interface CallbackSlot {
      id: string;
      candidateId: string;
      projectId: string;
      scheduledAt: string;  // ISO timestamp
      status: 'pending' | 'confirmed' | 'completed' | 'cancelled';
      recruiterNotes?: string;
    }
    ```

    Implement generateCallbackSlots(projectId: string, count: number = 3): CallbackSlot[]
    - Get project working hours settings
    - Generate next N available 30-minute slots during working hours
    - Skip already-booked slots (query callback_slots table)
    - Return array of available slot options

    Implement scheduleCallback(candidateId, projectId, slotTime): Promise<CallbackSlot>
    - Create callback_slots record with status='pending'
    - Return the created slot

    Implement sendCallbackOptions(candidateId, projectId): Promise<void>
    - Generate 3 callback slot options
    - Format as SMS message: "Thanks for your interest! When works for a quick call? Reply 1, 2, or 3:\n1) Mon 2pm\n2) Tue 10am\n3) Wed 3pm"
    - Send via sendSMS
    - Store pending callback request in database

    Implement processCallbackReply(candidateId, body: string): Promise<boolean>
    - Parse reply (1, 2, 3, or free-form time)
    - If valid slot selection, confirm callback and notify recruiter
    - Return true if processed, false if unrecognized

    2. Add database migration for callback_slots table:
    ```sql
    CREATE TABLE IF NOT EXISTS callback_slots (
      id TEXT PRIMARY KEY,
      candidate_id TEXT NOT NULL,
      project_id TEXT NOT NULL,
      scheduled_at TEXT NOT NULL,
      status TEXT DEFAULT 'pending',
      recruiter_notes TEXT,
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      FOREIGN KEY (candidate_id) REFERENCES cvs(id) ON DELETE CASCADE,
      FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_callback_slots_project ON callback_slots(project_id, status);
    CREATE INDEX IF NOT EXISTS idx_callback_slots_candidate ON callback_slots(candidate_id);
    ```

    3. Update workflowMachine.ts:
    - Add 'scheduling_callback' state between 'failed' and a new 'callback_scheduled' state
    - In 'failed' state: on REPLY_DETECTED -> 'scheduling_callback'
    - In 'scheduling_callback': invoke sendCallbackOptions actor, on success -> 'callback_scheduled'
    - In 'callback_scheduled': on CALLBACK_CONFIRMED -> 'archived' (with recruiter notified), on TIMEOUT -> 'archived'

    4. Update replyPoller.ts processInboundMessages:
    - Check if candidate is in 'callback_scheduled' state
    - If so, call processCallbackReply instead of normal intent classification
    - On successful callback confirmation, send CALLBACK_CONFIRMED event

  </action>
  <verify>
    - npx tsc --noEmit passes
    - callbackScheduler.ts exports generateCallbackSlots, scheduleCallback, sendCallbackOptions
    - workflowMachine.ts has 'scheduling_callback' and 'callback_scheduled' states
    - callback_slots table created in migration
  </verify>
  <done>
    Post-failed-screening reply triggers callback scheduling flow. System generates available time slots based on working hours, sends options via SMS, processes candidate's slot selection, and notifies recruiter of confirmed callback. This completes WRK-05 requirement.
  </done>
</task>

</tasks>

<verification>
Run these checks to verify the plan is complete:

1. TypeScript compilation:

   ```bash
   npx tsc --noEmit
   ```

2. Test suite:

   ```bash
   npm test
   ```

3. File structure verification:

   ```bash
   ls src/main/replyPoller.ts src/main/workingHours.ts
   ```

4. Manual verification points:
   - Reply polling starts on OutreachSection mount
   - Project settings can be retrieved and updated
   - Working hours check returns correct boolean for various times
     </verification>

<success_criteria>

- Reply polling detects inbound SMS and classifies intent correctly
- REPLY_DETECTED events are sent to matching workflow actors
- Working hours check prevents messages outside business hours
- Project outreach settings are stored and retrieved from database
- Missed escalations execute on app restart
- All existing tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/10-outreach-workflow-engine/10-02-SUMMARY.md`
</output>
