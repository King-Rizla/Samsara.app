---
phase: 04.5-project-homepage-organization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/index.ts
  - src/main/preload.ts
autonomous: true

must_haves:
  truths:
    - "IPC handlers for project CRUD are registered in main process"
    - "Preload exposes project API methods to renderer"
    - "getAllCVs and getAllJDs IPC handlers accept projectId filter"
  artifacts:
    - path: "src/main/index.ts"
      provides: "IPC handlers for project operations"
      contains: "ipcMain.handle('create-project'"
    - path: "src/main/preload.ts"
      provides: "Renderer API for project operations"
      contains: "createProject:"
  key_links:
    - from: "src/main/preload.ts"
      to: "src/main/index.ts"
      via: "ipcRenderer.invoke -> ipcMain.handle"
---

<objective>
Add IPC handlers and preload API for project operations.

Purpose: Enable the renderer process to perform project CRUD operations via secure Electron IPC bridge. This is the communication layer between frontend and database.

Output: IPC handlers in main process and corresponding preload API methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.5-project-homepage-organization/04.5-RESEARCH.md
@src/main/index.ts
@src/main/preload.ts
@src/main/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project IPC handlers to main process</name>
  <files>src/main/index.ts</files>
  <action>
1. Add imports for project database functions (they should be in database.ts from Plan 01):
```typescript
import {
  // ... existing imports ...
  createProject,
  getAllProjects,
  getProject,
  updateProject,
  deleteProject,
  getAggregateStats,
} from './database';
```

2. Add IPC handlers for project operations (after existing handlers, before app.on('window-all-closed')):

```typescript
// ============================================================================
// Project IPC Handlers
// ============================================================================

ipcMain.handle('create-project', async (_event, input: { name: string; client_name?: string; description?: string }) => {
  try {
    const project = createProject(input);
    return { success: true, data: project };
  } catch (error) {
    console.error('Failed to create project:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create project' };
  }
});

ipcMain.handle('get-all-projects', async (_event, includeArchived?: boolean) => {
  try {
    const projects = getAllProjects(includeArchived);
    return { success: true, data: projects };
  } catch (error) {
    console.error('Failed to get projects:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to get projects' };
  }
});

ipcMain.handle('get-project', async (_event, id: string) => {
  try {
    const project = getProject(id);
    if (!project) {
      return { success: false, error: 'Project not found' };
    }
    return { success: true, data: project };
  } catch (error) {
    console.error('Failed to get project:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to get project' };
  }
});

ipcMain.handle('update-project', async (_event, id: string, updates: { name?: string; client_name?: string; description?: string; is_archived?: boolean }) => {
  try {
    const success = updateProject(id, updates);
    if (!success) {
      return { success: false, error: 'Project not found' };
    }
    return { success: true };
  } catch (error) {
    console.error('Failed to update project:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update project' };
  }
});

ipcMain.handle('delete-project', async (_event, id: string) => {
  try {
    const success = deleteProject(id);
    if (!success) {
      return { success: false, error: 'Project not found' };
    }
    return { success: true };
  } catch (error) {
    console.error('Failed to delete project:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to delete project' };
  }
});

ipcMain.handle('get-aggregate-stats', async () => {
  try {
    const stats = getAggregateStats();
    return { success: true, data: stats };
  } catch (error) {
    console.error('Failed to get aggregate stats:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to get aggregate stats' };
  }
});
```

3. Modify existing 'get-all-cvs' handler to accept projectId:
```typescript
// Update existing handler signature
ipcMain.handle('get-all-cvs', async (_event, projectId?: string) => {
  try {
    const cvs = getAllCVs(projectId);  // Pass projectId to database function
    // ... rest unchanged
  }
});
```

4. Modify existing 'get-all-jds' handler to accept projectId:
```typescript
ipcMain.handle('get-all-jds', async (_event, projectId?: string) => {
  try {
    const jds = getAllJDs(projectId);  // Pass projectId to database function
    // ... rest unchanged
  }
});
```
  </action>
  <verify>
- TypeScript compiles without errors
- All 6 project IPC handlers registered
- get-all-cvs and get-all-jds accept optional projectId parameter
  </verify>
  <done>Project IPC handlers registered in main process with correct parameter signatures</done>
</task>

<task type="auto">
  <name>Task 2: Add project API to preload</name>
  <files>src/main/preload.ts</files>
  <action>
1. Add TypeScript interfaces for project types at the top with other interfaces:
```typescript
interface ProjectSummary {
  id: string;
  name: string;
  client_name: string | null;
  description: string | null;
  is_archived: boolean;
  created_at: string;
  updated_at: string;
  cv_count: number;
  jd_count: number;
}

interface CreateProjectInput {
  name: string;
  client_name?: string;
  description?: string;
}

interface ProjectResult {
  success: boolean;
  data?: ProjectSummary;
  error?: string;
}

interface ProjectsResult {
  success: boolean;
  data?: ProjectSummary[];
  error?: string;
}

interface AggregateStatsResult {
  success: boolean;
  data?: { total_cvs: number; total_jds: number };
  error?: string;
}
```

2. Add project methods to the `api` object exposed via contextBridge:
```typescript
contextBridge.exposeInMainWorld('api', {
  // ... existing methods ...

  // Project operations

  /**
   * Create a new project.
   * Returns { success: boolean, data?: ProjectSummary, error?: string }
   */
  createProject: (input: CreateProjectInput): Promise<ProjectResult> =>
    ipcRenderer.invoke('create-project', input),

  /**
   * Get all projects with CV/JD counts.
   * Returns { success: boolean, data?: ProjectSummary[], error?: string }
   */
  getAllProjects: (includeArchived?: boolean): Promise<ProjectsResult> =>
    ipcRenderer.invoke('get-all-projects', includeArchived),

  /**
   * Get a single project by ID.
   * Returns { success: boolean, data?: ProjectSummary, error?: string }
   */
  getProject: (id: string): Promise<ProjectResult> =>
    ipcRenderer.invoke('get-project', id),

  /**
   * Update a project.
   * Returns { success: boolean, error?: string }
   */
  updateProject: (id: string, updates: { name?: string; client_name?: string; description?: string; is_archived?: boolean }): Promise<{ success: boolean; error?: string }> =>
    ipcRenderer.invoke('update-project', id, updates),

  /**
   * Delete a project and all its data.
   * Returns { success: boolean, error?: string }
   */
  deleteProject: (id: string): Promise<{ success: boolean; error?: string }> =>
    ipcRenderer.invoke('delete-project', id),

  /**
   * Get aggregate stats across all projects.
   * Returns { success: boolean, data?: { total_cvs, total_jds }, error?: string }
   */
  getAggregateStats: (): Promise<AggregateStatsResult> =>
    ipcRenderer.invoke('get-aggregate-stats'),
});
```

3. Update existing getAllCVs and getAllJDs to accept projectId:
```typescript
  getAllCVs: (projectId?: string): Promise<GetAllCVsResult> =>
    ipcRenderer.invoke('get-all-cvs', projectId),

  getAllJDs: (projectId?: string): Promise<{ success: boolean; data?: unknown[]; error?: string }> =>
    ipcRenderer.invoke('get-all-jds', projectId),
```
  </action>
  <verify>
- TypeScript compiles without errors
- Preload exposes all 6 project methods: createProject, getAllProjects, getProject, updateProject, deleteProject, getAggregateStats
- getAllCVs and getAllJDs accept optional projectId parameter
  </verify>
  <done>Project API exposed to renderer via preload with type-safe interfaces</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. App launches successfully
3. In DevTools console, verify API methods exist:
   - `window.api.createProject`
   - `window.api.getAllProjects`
   - `window.api.getProject`
   - `window.api.updateProject`
   - `window.api.deleteProject`
   - `window.api.getAggregateStats`
4. Test basic call: `await window.api.getAllProjects()` returns { success: true, data: [...] }
</verification>

<success_criteria>
- All project IPC handlers registered and responding
- Preload API exposes type-safe project methods
- getAllCVs and getAllJDs can filter by projectId
- End-to-end: renderer can create/read/update/delete projects
</success_criteria>

<output>
After completion, create `.planning/phases/04.5-project-homepage-organization/04.5-02-SUMMARY.md`
</output>
