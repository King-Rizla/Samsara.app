---
phase: 10-outreach-workflow-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/workflowMachine.ts
  - src/main/workflowService.ts
  - src/main/workflowPersistence.ts
  - src/main/database.ts
  - src/main/index.ts
  - src/main/preload.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Graduating a candidate creates a workflow instance in 'pending' state"
    - "Graduation triggers immediate transition to 'contacted' and sends SMS + email"
    - "Workflow state persists to SQLite and survives app restart"
    - "Recruiter can graduate individual candidates via IPC"
    - "Recruiter can batch-graduate multiple candidates via IPC"
  artifacts:
    - path: "src/main/workflowMachine.ts"
      provides: "XState v5 state machine definition for outreach workflow"
      exports: ["outreachMachine"]
    - path: "src/main/workflowService.ts"
      provides: "Actor management, graduation functions"
      exports:
        [
          "graduateCandidate",
          "graduateCandidates",
          "getWorkflowActors",
          "sendWorkflowEvent",
        ]
    - path: "src/main/workflowPersistence.ts"
      provides: "SQLite snapshot save/restore functions"
      exports:
        [
          "saveWorkflowSnapshot",
          "loadWorkflowSnapshot",
          "restoreActiveWorkflows",
        ]
  key_links:
    - from: "src/main/workflowService.ts"
      to: "src/main/workflowMachine.ts"
      via: "imports outreachMachine, creates actors"
      pattern: "createActor.*outreachMachine"
    - from: "src/main/workflowMachine.ts"
      to: "src/main/communicationService.ts"
      via: "machine actors import and call sendSMS, sendEmail directly"
      pattern: "import.*sendSMS.*sendEmail.*from.*communicationService"
    - from: "src/main/workflowPersistence.ts"
      to: "src/main/database.ts"
      via: "persists snapshots to outreach_workflows table"
      pattern: "getDatabase.*outreach_workflows"
---

<objective>
Implement XState v5 state machine for outreach workflow with SQLite persistence and candidate graduation flow.

Purpose: The state machine is the heart of automated outreach - it manages the lifecycle of each candidate from graduation through contact, reply detection, and screening. SQLite persistence ensures workflow state survives app restarts.

Output:

- XState v5 machine definition with all workflow states
- Actor management service with graduation functions
- Persistence layer for SQLite snapshot storage
- Database migration v7 for workflow tables
- IPC handlers for graduation operations
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-outreach-workflow-engine/10-RESEARCH.md
@.planning/phases/10-outreach-workflow-engine/10-CONTEXT.md
@src/main/communicationService.ts
@src/main/database.ts
@src/main/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install XState and create workflow state machine</name>
  <files>
    package.json
    src/main/workflowMachine.ts
  </files>
  <action>
    1. Install xstate and @xstate/react:
       ```bash
       npm install xstate @xstate/react
       ```

    2. Create src/main/workflowMachine.ts with XState v5 setup() pattern:

    Define types:
    - WorkflowState: 'pending' | 'contacted' | 'replied' | 'screening' | 'passed' | 'failed' | 'paused' | 'archived'
    - WorkflowContext: candidateId, projectId, matchScore, candidateName, phone?, email?, escalationTimeoutMs, replyDetected, replyIntent, screeningOutcome, timestamps (startedAt, contactedAt, repliedAt, screeningAt, completedAt), lastError?
    - WorkflowEvent: GRADUATE | REPLY_DETECTED | TIMEOUT | SCREENING_COMPLETE | PAUSE | RESUME | CANCEL | FORCE_CALL | SKIP_TO_SCREENING

    Use setup() for strongly-typed machine:
    - Define actions: sendInitialOutreach (assigns contactedAt), markReplied, markScreeningStarted, markCompleted
    - Define guards: hasPhone, hasEmail, isPositiveReply (intent === 'positive' || intent === 'ambiguous'), aiCallEnabled
    - Define actors: sendInitialMessages (fromPromise that calls sendSMS + sendEmail), triggerAICall (placeholder for Phase 11)

    IMPORTANT: Actor wiring for sendSMS/sendEmail:
    - In workflowMachine.ts, import { sendSMS, sendEmail } from './communicationService'
    - The sendInitialMessages actor (fromPromise) calls these imported functions directly
    - Do NOT pass sendSMS/sendEmail through machine context - import them at module level

    State machine structure:
    - pending: on GRADUATE -> contacted
    - contacted: invoke sendInitialMessages, after escalationTimeout -> screening (if aiCallEnabled), on REPLY_DETECTED -> replied (if positive) or archived (if negative), on PAUSE/CANCEL/SKIP_TO_SCREENING
    - replied: always -> screening (if aiCallEnabled)
    - screening: invoke triggerAICall (placeholder), on SCREENING_COMPLETE -> passed or failed, on PAUSE/CANCEL
    - passed: final state
    - failed: on REPLY_DETECTED -> schedule callback (WRK-05)
    - paused: on RESUME -> contacted, on CANCEL -> archived, on FORCE_CALL -> screening
    - archived: final state

    Use dynamic delays for escalationTimeout: ({ context }) => context.escalationTimeoutMs

    Export: outreachMachine

  </action>
  <verify>
    - File exists at src/main/workflowMachine.ts
    - TypeScript compiles: npx tsc --noEmit
    - Package.json includes xstate and @xstate/react
  </verify>
  <done>
    XState v5 machine definition exists with all workflow states, transitions, actions, guards, and actors defined using setup() pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workflow persistence and service layers</name>
  <files>
    src/main/workflowPersistence.ts
    src/main/workflowService.ts
    src/main/database.ts
  </files>
  <action>
    1. Add database migration v7 to src/main/database.ts:
       ```sql
       -- outreach_workflows table for XState snapshot persistence
       CREATE TABLE IF NOT EXISTS outreach_workflows (
         candidate_id TEXT PRIMARY KEY,
         project_id TEXT NOT NULL,
         snapshot_json TEXT NOT NULL,
         current_state TEXT NOT NULL,
         match_score INTEGER,
         created_at TEXT NOT NULL,
         updated_at TEXT NOT NULL,
         FOREIGN KEY (candidate_id) REFERENCES cvs(id) ON DELETE CASCADE,
         FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
       );

       CREATE INDEX IF NOT EXISTS idx_workflows_project_state ON outreach_workflows(project_id, current_state);
       CREATE INDEX IF NOT EXISTS idx_workflows_match_score ON outreach_workflows(project_id, match_score DESC);

       -- Add graduated_at and outreach_status columns to cvs table
       ALTER TABLE cvs ADD COLUMN graduated_at TEXT;
       ALTER TABLE cvs ADD COLUMN outreach_status TEXT DEFAULT 'not_graduated';

       CREATE INDEX IF NOT EXISTS idx_cvs_outreach_status ON cvs(project_id, outreach_status);
       ```
       Use column-exists checks before ALTER TABLE.

    2. Create src/main/workflowPersistence.ts:
       - saveWorkflowSnapshot(candidateId, snapshot): INSERT OR REPLACE into outreach_workflows with JSON.stringify(snapshot)
       - loadWorkflowSnapshot(candidateId): SELECT and JSON.parse snapshot_json, return null if not found
       - restoreActiveWorkflows(): SELECT all non-final workflows (json_extract(snapshot_json, '$.status') != 'done'), createActor with persisted snapshot, start actors, return Map<candidateId, actor>
       - Include executeMissedEscalations() helper: For each 'contacted' state actor, check if elapsed time >= escalationTimeoutMs, send TIMEOUT event if so

    3. Create src/main/workflowService.ts:
       - Map<string, Actor> workflowActors for active workflows
       - graduateCandidate(candidateId, projectId, context): Create actor, subscribe to state changes (save snapshot on each transition), start actor, update cvs.graduated_at, send GRADUATE event
       - graduateCandidates(candidateIds, projectId, escalationTimeoutMs): Batch graduation, return {success: string[], failed: string[]}
       - getWorkflowActors(): Return the actors map
       - sendWorkflowEvent(candidateId, event): Get actor from map, send event
       - getWorkflowsByProject(projectId): Query outreach_workflows table, return summary data for UI
       - initializeWorkflows(): Called on app startup, calls restoreActiveWorkflows()

       Import sendSMS, sendEmail from communicationService for the machine actors.

  </action>
  <verify>
    - npx tsc --noEmit passes
    - Migration v7 block present in database.ts
    - workflowPersistence.ts exports saveWorkflowSnapshot, loadWorkflowSnapshot, restoreActiveWorkflows
    - workflowService.ts exports graduateCandidate, graduateCandidates, sendWorkflowEvent, getWorkflowsByProject, initializeWorkflows
  </verify>
  <done>
    Persistence layer saves/restores XState snapshots to SQLite. Service layer manages workflow actors and provides graduation functions. Database migration v7 creates outreach_workflows table and adds graduated_at column to cvs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire IPC handlers and app initialization</name>
  <files>
    src/main/index.ts
    src/main/preload.ts
  </files>
  <action>
    1. In src/main/index.ts:
       - Import initializeWorkflows from workflowService
       - Call initializeWorkflows() after database initialization in app.whenReady()
       - Add IPC handlers:
         - 'graduate-candidate': (_, candidateId, projectId, context) => graduateCandidate(...)
         - 'graduate-candidates': (_, candidateIds, projectId, escalationTimeoutMs) => graduateCandidates(...)
         - 'send-workflow-event': (_, candidateId, eventType, payload?) => sendWorkflowEvent(candidateId, {type: eventType, ...payload})
         - 'get-workflows-by-project': (_, projectId) => getWorkflowsByProject(projectId)
         - 'get-workflow-candidate': (_, candidateId) => Get workflow snapshot and format for UI

    2. In src/main/preload.ts:
       - Add to contextBridge.exposeInMainWorld('api', {...}):
         - graduateCandidate: (candidateId, projectId, context) => ipcRenderer.invoke('graduate-candidate', candidateId, projectId, context)
         - graduateCandidates: (candidateIds, projectId, escalationTimeoutMs) => ipcRenderer.invoke('graduate-candidates', candidateIds, projectId, escalationTimeoutMs)
         - sendWorkflowEvent: (candidateId, eventType, payload?) => ipcRenderer.invoke('send-workflow-event', candidateId, eventType, payload)
         - getWorkflowsByProject: (projectId) => ipcRenderer.invoke('get-workflows-by-project', projectId)
         - getWorkflowCandidate: (candidateId) => ipcRenderer.invoke('get-workflow-candidate', candidateId)

    3. Update types for window.api if needed (src/renderer/types/global.d.ts or similar)

  </action>
  <verify>
    - npx tsc --noEmit passes
    - npm test passes (all existing tests)
    - IPC handlers registered in index.ts
    - Preload exposes graduation and workflow methods
  </verify>
  <done>
    Workflow initialization runs on app startup, restoring persisted workflows. IPC handlers allow renderer to graduate candidates and send workflow events. All plumbing complete for renderer integration.
  </done>
</task>

</tasks>

<verification>
Run these checks to verify the plan is complete:

1. TypeScript compilation:

   ```bash
   npx tsc --noEmit
   ```

2. Test suite:

   ```bash
   npm test
   ```

3. File structure verification:

   ```bash
   ls src/main/workflowMachine.ts src/main/workflowService.ts src/main/workflowPersistence.ts
   ```

4. Package verification:
   ```bash
   npm ls xstate @xstate/react
   ```
   </verification>

<success_criteria>

- XState v5 state machine compiles without errors
- Database migration v7 creates outreach_workflows table
- Workflow actors persist to SQLite on state changes
- App startup restores active workflows from database
- IPC handlers enable renderer to graduate candidates
- All 152+ existing tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/10-outreach-workflow-engine/10-01-SUMMARY.md`
</output>
