---
phase: 10-outreach-workflow-engine
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/main/replyPoller.ts
  - src/main/workingHours.ts
  - src/main/workflowService.ts
  - src/main/database.ts
  - src/main/index.ts
  - src/main/preload.ts
autonomous: true

must_haves:
  truths:
    - "System polls for inbound SMS replies every 30 seconds"
    - "Reply with positive intent triggers AI call escalation"
    - "Reply with negative intent archives the workflow"
    - "Messages queued outside working hours are sent when hours resume"
    - "Missed escalations execute in order when app reopens"
    - "Project settings control escalation timeout and working hours"
  artifacts:
    - path: "src/main/replyPoller.ts"
      provides: "Inbound SMS polling and intent classification"
      exports:
        [
          "startReplyPolling",
          "stopReplyPolling",
          "classifyIntent",
          "processInboundMessages",
        ]
    - path: "src/main/workingHours.ts"
      provides: "Working hours check and message queueing"
      exports:
        [
          "isWithinWorkingHours",
          "getNextWorkingHoursStart",
          "queueMessageForWorkingHours",
        ]
  key_links:
    - from: "src/main/replyPoller.ts"
      to: "src/main/workflowService.ts"
      via: "sends REPLY_DETECTED events to workflow actors"
      pattern: "sendWorkflowEvent.*REPLY_DETECTED"
    - from: "src/main/workingHours.ts"
      to: "src/main/communicationService.ts"
      via: "delays message sending until working hours"
      pattern: "sendSMS|sendEmail"
---

<objective>
Implement reply detection polling, intent classification, working hours queueing, and escalation timeout handling for app restart recovery.

Purpose: The workflow engine needs to detect candidate replies to trigger escalation, respect working hours to avoid late-night messages, and recover missed escalations after app restarts. This plan adds the temporal and reactive behaviors that make the state machine respond to real-world events.

Output:

- Reply polling service that detects inbound SMS and classifies intent
- Working hours service that queues messages and delays outreach
- Project settings for escalation timeout and working hours
- App restart catch-up for missed escalations
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-outreach-workflow-engine/10-RESEARCH.md
@.planning/phases/10-outreach-workflow-engine/10-CONTEXT.md
@.planning/phases/10-outreach-workflow-engine/10-01-SUMMARY.md
@src/main/workflowService.ts
@src/main/communicationService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reply polling service with intent classification</name>
  <files>
    src/main/replyPoller.ts
    src/main/database.ts
  </files>
  <action>
    1. Create src/main/replyPoller.ts:

    Define keyword lists (per CONTEXT.md - Claude's discretion on exact lists):
    ```typescript
    const POSITIVE_KEYWORDS = ['yes', 'interested', 'call', 'available', 'sure', 'okay', 'ok', 'sounds good', 'tell me more', 'when', 'what time'];
    const NEGATIVE_KEYWORDS = ['no', 'stop', 'unsubscribe', 'not interested', 'remove', 'no thanks', 'busy', 'wrong number'];
    ```

    Implement classifyIntent(body: string): 'positive' | 'negative' | 'ambiguous'
    - Check negative first (more specific)
    - Check positive
    - Default to 'ambiguous' (per CONTEXT.md: treat as positive)

    Implement pollInboundMessages(projectId: string): Promise<InboundMessage[]>
    - Get Twilio credentials from credentialManager
    - Use Twilio SDK to list inbound messages (direction === 'inbound') from last 30 minutes
    - Filter to messages sent TO our number
    - Return array of {from, body, timestamp, sid}

    Implement processInboundMessages(messages, projectId):
    - Build phone-to-candidateId map from outreach_workflows + cvs tables
    - For each inbound message:
      - Look up candidateId by normalized phone
      - If found and workflow exists, classify intent and call sendWorkflowEvent(candidateId, 'REPLY_DETECTED', {intent})
      - Store inbound message in messages table with direction='inbound', status='received'
      - Mark message SID as processed to avoid re-processing (add processed_sids table or use message SID check)

    Implement polling management:
    - startReplyPolling(projectId): setInterval every 30 seconds, store interval reference
    - stopReplyPolling(): clearInterval
    - Export functions

    2. Add database helper in database.ts or inline:
    - getCandidateIdByPhone(phone, projectId): Query cvs joined with outreach_workflows to find candidate
    - isMessageProcessed(sid): Check if SID already in messages table

  </action>
  <verify>
    - npx tsc --noEmit passes
    - replyPoller.ts exports classifyIntent, startReplyPolling, stopReplyPolling, processInboundMessages
    - Keyword lists cover common positive/negative responses
  </verify>
  <done>
    Reply polling service polls Twilio every 30 seconds for inbound SMS, classifies intent, and sends REPLY_DETECTED events to matching workflow actors. Inbound messages are stored in database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement working hours and message queueing</name>
  <files>
    src/main/workingHours.ts
    src/main/database.ts
    src/main/workflowMachine.ts
  </files>
  <action>
    1. Create src/main/workingHours.ts:

    Define WorkingHoursConfig interface:
    ```typescript
    interface WorkingHoursConfig {
      enabled: boolean;
      startHour: number;  // 0-23
      startMinute: number;  // 0-59
      endHour: number;
      endMinute: number;
      timezone: string;  // e.g., 'America/New_York'
      workDays: number[];  // 0=Sunday, 1=Monday, etc.
    }
    ```

    Implement isWithinWorkingHours(config: WorkingHoursConfig): boolean
    - If !config.enabled, return true (always within hours)
    - Get current time in configured timezone
    - Check if current day is in workDays
    - Check if current time is between start and end
    - Return boolean

    Implement getNextWorkingHoursStart(config: WorkingHoursConfig): Date
    - Calculate next valid working hours start time
    - Used for scheduling delayed messages

    Implement queueMessageForWorkingHours(projectId, candidateId, type, payload):
    - Check if within working hours
    - If yes, return {send: true}
    - If no, calculate delay until working hours start
    - Store in message_queue table (or use XState delayed action)
    - Return {send: false, scheduledFor: Date}

    2. Add database migration or table for project outreach settings:
    ```sql
    -- Add to migration v7 or create v8 if already migrated
    CREATE TABLE IF NOT EXISTS project_outreach_settings (
      project_id TEXT PRIMARY KEY,
      escalation_timeout_ms INTEGER DEFAULT 1800000,  -- 30 min default
      ai_call_enabled INTEGER DEFAULT 1,
      working_hours_enabled INTEGER DEFAULT 0,
      working_hours_start TEXT DEFAULT '09:00',
      working_hours_end TEXT DEFAULT '17:00',
      working_hours_timezone TEXT DEFAULT 'America/New_York',
      working_hours_days TEXT DEFAULT '[1,2,3,4,5]',
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
    );
    ```

    3. Add getProjectOutreachSettings(projectId) and updateProjectOutreachSettings(projectId, settings) to database.ts

    4. Update workflowMachine.ts sendInitialMessages actor to check working hours before sending:
    - Import working hours functions
    - If outside working hours, queue message and schedule delayed send
    - Otherwise send immediately

  </action>
  <verify>
    - npx tsc --noEmit passes
    - workingHours.ts exports isWithinWorkingHours, getNextWorkingHoursStart
    - Project outreach settings table created in migration
    - getProjectOutreachSettings returns config or default values
  </verify>
  <done>
    Working hours service checks project configuration and queues messages for delivery during business hours. Project outreach settings stored in database with defaults (30 min timeout, AI calls enabled, working hours disabled by default).
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire polling and settings to app lifecycle</name>
  <files>
    src/main/index.ts
    src/main/preload.ts
    src/main/workflowService.ts
  </files>
  <action>
    1. Update src/main/index.ts:
       - Import startReplyPolling, stopReplyPolling from replyPoller
       - Start reply polling when OutreachSection is mounted (via IPC: 'start-reply-polling')
       - Stop reply polling when OutreachSection unmounts (via IPC: 'stop-reply-polling')
       - Add IPC handlers:
         - 'start-reply-polling': (_, projectId) => startReplyPolling(projectId)
         - 'stop-reply-polling': () => stopReplyPolling()
         - 'get-project-outreach-settings': (_, projectId) => getProjectOutreachSettings(projectId)
         - 'update-project-outreach-settings': (_, projectId, settings) => updateProjectOutreachSettings(projectId, settings)

    2. Update src/main/preload.ts:
       - Add to window.api:
         - startReplyPolling: (projectId) => ipcRenderer.invoke('start-reply-polling', projectId)
         - stopReplyPolling: () => ipcRenderer.invoke('stop-reply-polling')
         - getProjectOutreachSettings: (projectId) => ipcRenderer.invoke('get-project-outreach-settings', projectId)
         - updateProjectOutreachSettings: (projectId, settings) => ipcRenderer.invoke('update-project-outreach-settings', projectId, settings)

    3. Update workflowService.ts initializeWorkflows():
       - After restoring workflows, call executeMissedEscalations()
       - For each 'contacted' workflow where contactedAt + escalationTimeoutMs < now, send TIMEOUT event
       - Log "Executing missed escalation for {candidateId}"

    4. Enhance restoreActiveWorkflows() in workflowPersistence.ts:
       - Track which workflows need immediate escalation
       - Return both actors map and list of candidates needing escalation
       - Let initializeWorkflows() handle the escalation dispatch to avoid circular dependency

  </action>
  <verify>
    - npx tsc --noEmit passes
    - npm test passes
    - Reply polling IPC handlers registered
    - Project outreach settings IPC handlers registered
    - Missed escalation logic present in initializeWorkflows
  </verify>
  <done>
    Reply polling starts when OutreachSection mounts and stops on unmount. Project outreach settings accessible via IPC. App startup executes any missed escalations for workflows that should have timed out while app was closed.
  </done>
</task>

</tasks>

<verification>
Run these checks to verify the plan is complete:

1. TypeScript compilation:

   ```bash
   npx tsc --noEmit
   ```

2. Test suite:

   ```bash
   npm test
   ```

3. File structure verification:

   ```bash
   ls src/main/replyPoller.ts src/main/workingHours.ts
   ```

4. Manual verification points:
   - Reply polling starts on OutreachSection mount
   - Project settings can be retrieved and updated
   - Working hours check returns correct boolean for various times
     </verification>

<success_criteria>

- Reply polling detects inbound SMS and classifies intent correctly
- REPLY_DETECTED events are sent to matching workflow actors
- Working hours check prevents messages outside business hours
- Project outreach settings are stored and retrieved from database
- Missed escalations execute on app restart
- All existing tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/10-outreach-workflow-engine/10-02-SUMMARY.md`
</output>
