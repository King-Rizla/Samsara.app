# Phase 4.7: Dashboard Enhancements - Research

**Researched:** 2026-01-27
**Domain:** React UI (drag-drop, usage tracking, settings)
**Confidence:** HIGH

## Summary

This phase enhances the existing dashboard with three main capabilities: (1) drag-drop project quick-access in the sidebar, (2) token/API usage tracking per project with aggregated totals, and (3) settings UI for configuring usage limits with warnings. The research identifies the standard approach for each area using the project's existing tech stack.

The sidebar already exists using shadcn/ui's SidebarProvider pattern. Adding drag-drop requires a React drag-drop library since HTML5 drag-drop does not work well within Electron windows. Token tracking requires extending the Python sidecar responses to include token counts from both OpenAI (via `usage` object) and Ollama (via `eval_count`/`prompt_eval_count`), storing them in SQLite with a new usage tracking table, and aggregating for display. Settings UI extends the existing settings infrastructure with new fields for usage limits.

**Primary recommendation:** Use @dnd-kit/core for drag-drop (lightweight, hook-based, works well within Electron), extend Python responses to include token counts, add SQLite usage tracking table with triggers for daily aggregation, and extend the existing LLMSettings component with usage limit controls.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @dnd-kit/core | ^6.x | Drag-drop primitives | Lightweight (~10kb), hook-based (useDraggable/useDroppable), no wrapper DOM nodes, built for React |
| @dnd-kit/sortable | ^8.x | Sortable list preset | Pairs with core for reorderable sidebar items |
| better-sqlite3 | ^12.6.2 | Usage data persistence | Already used in project, supports triggers and WAL mode |
| zustand | ^5.0.10 | Settings state | Already used for all stores in project |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @dnd-kit/utilities | ^3.x | CSS transform helpers | For smooth drag animations |
| lucide-react | ^0.563.0 | Icons for usage stats | Already installed, use GaugeCircle, AlertTriangle |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| @dnd-kit | react-dnd | react-dnd is more verbose, requires HTML5 backend which has issues in Electron |
| @dnd-kit | pragmatic-drag-and-drop | Newer (Atlassian), smaller bundle, but less mature ecosystem and documentation |
| @dnd-kit | react-beautiful-dnd | Deprecated by Atlassian, fork (hello-pangea/dnd) is list-only, no custom drop targets |

**Installation:**
```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── main/
│   ├── database.ts          # Add usage tracking table + CRUD
│   └── settings.ts          # Add usage limit fields
├── renderer/
│   ├── components/
│   │   ├── sidebar/
│   │   │   └── AppSidebar.tsx      # Add drop zone for quick-access projects
│   │   ├── dashboard/
│   │   │   ├── ProjectCard.tsx     # Add draggable + token display
│   │   │   └── StatsStrip.tsx      # Add token/API stats
│   │   └── settings/
│   │       ├── LLMSettings.tsx     # Existing - add usage limit controls
│   │       └── UsageLimits.tsx     # New component for limit configuration
│   ├── stores/
│   │   ├── usageStore.ts           # New store for usage tracking
│   │   └── settingsStore.ts        # New store for settings state
│   └── types/
│       └── usage.ts                # Usage tracking types
python-src/
├── main.py                         # Return token usage in responses
└── extractors/llm/
    ├── client.py                   # Capture Ollama token counts
    └── openai_client.py            # Capture OpenAI token counts
```

### Pattern 1: Drag-Drop with @dnd-kit
**What:** Project cards are draggable, sidebar has a drop zone for "pinned" projects
**When to use:** User wants quick-access to frequently used projects
**Example:**
```typescript
// Source: https://docs.dndkit.com
import { DndContext, useDraggable, useDroppable, DragEndEvent } from '@dnd-kit/core';

function DraggableProjectCard({ project }: { project: Project }) {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: project.id,
    data: { type: 'project', project },
  });

  const style = transform ? {
    transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`,
  } : undefined;

  return (
    <div ref={setNodeRef} style={style} {...listeners} {...attributes}>
      <ProjectCard project={project} />
    </div>
  );
}

function SidebarDropZone({ onDrop }: { onDrop: (projectId: string) => void }) {
  const { setNodeRef, isOver } = useDroppable({ id: 'sidebar-quick-access' });

  return (
    <div ref={setNodeRef} className={isOver ? 'bg-primary/10' : ''}>
      <span>Drop here for quick access</span>
    </div>
  );
}
```

### Pattern 2: Token Usage Tracking in Python
**What:** Extract token counts from LLM responses and return to Electron
**When to use:** Every LLM call (CV extraction, JD extraction)
**Example:**
```python
# Source: Ollama API docs, OpenAI API docs
# In client.py (Ollama)
response = self._client.chat(...)
token_usage = {
    'prompt_tokens': response.prompt_eval_count or 0,
    'completion_tokens': response.eval_count or 0,
    'total_tokens': (response.prompt_eval_count or 0) + (response.eval_count or 0),
}

# In openai_client.py
response = self._client.beta.chat.completions.parse(...)
token_usage = {
    'prompt_tokens': response.usage.prompt_tokens,
    'completion_tokens': response.usage.completion_tokens,
    'total_tokens': response.usage.total_tokens,
}

# Return in main.py response
return {
    'id': request_id,
    'success': True,
    'data': {
        **parsed_cv,
        'token_usage': token_usage,  # Add this field
    }
}
```

### Pattern 3: SQLite Usage Tracking Table with Aggregation
**What:** Store raw usage events and auto-aggregate daily totals
**When to use:** Every successful LLM call
**Example:**
```sql
-- Source: SQLite documentation patterns
-- Raw usage events
CREATE TABLE IF NOT EXISTS usage_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id TEXT NOT NULL,
    event_type TEXT NOT NULL,  -- 'cv_extraction', 'jd_extraction'
    prompt_tokens INTEGER NOT NULL DEFAULT 0,
    completion_tokens INTEGER NOT NULL DEFAULT 0,
    total_tokens INTEGER NOT NULL DEFAULT 0,
    llm_mode TEXT NOT NULL,    -- 'local' or 'cloud'
    created_at TEXT NOT NULL,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- Daily aggregation table
CREATE TABLE IF NOT EXISTS usage_daily (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id TEXT NOT NULL,
    date TEXT NOT NULL,
    total_tokens INTEGER DEFAULT 0,
    request_count INTEGER DEFAULT 0,
    UNIQUE(project_id, date),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- Trigger for auto-aggregation
CREATE TRIGGER IF NOT EXISTS update_daily_usage
AFTER INSERT ON usage_events
BEGIN
    INSERT INTO usage_daily (project_id, date, total_tokens, request_count)
    VALUES (NEW.project_id, DATE(NEW.created_at), NEW.total_tokens, 1)
    ON CONFLICT(project_id, date) DO UPDATE SET
        total_tokens = total_tokens + NEW.total_tokens,
        request_count = request_count + 1;
END;

-- Index for performance
CREATE INDEX IF NOT EXISTS idx_usage_events_project ON usage_events(project_id);
CREATE INDEX IF NOT EXISTS idx_usage_daily_project_date ON usage_daily(project_id, date);
```

### Pattern 4: Settings Extension for Usage Limits
**What:** Extend existing AppSettings interface with usage limit fields
**When to use:** User configures global or per-project limits
**Example:**
```typescript
// Source: Existing settings.ts pattern
export interface AppSettings {
  llmMode: 'local' | 'cloud';
  openaiApiKey?: string;
  // New usage limit fields
  globalTokenLimit?: number;        // Monthly token limit (null = unlimited)
  globalWarningThreshold?: number;  // Percent (e.g., 80 means warn at 80%)
  projectLimits?: Record<string, {
    tokenLimit?: number;
    warningThreshold?: number;
  }>;
}
```

### Anti-Patterns to Avoid
- **Hand-rolling drag-drop with mouse events:** Complex to handle touch, accessibility, and smooth animations. Use @dnd-kit.
- **Polling for usage updates:** Use IPC push events when usage changes, not polling.
- **Storing raw token counts in project table:** Use separate usage table with foreign key - keeps project table lean.
- **Calculating aggregates on every dashboard load:** Use SQLite triggers to maintain daily aggregates incrementally.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Drag-drop | Mouse/touch event handlers | @dnd-kit | Accessibility, animations, collision detection are complex |
| CSS transforms during drag | Manual transform calculation | @dnd-kit/utilities CSS.Transform | Handles vendor prefixes, 3D transforms |
| Token counting | Manual text tokenization | LLM response.usage | OpenAI/Ollama already count tokens accurately |
| Daily aggregation | Application-level rollup | SQLite triggers | Atomic, survives crashes, no app logic needed |
| Usage warning UI | Custom alert component | shadcn Alert + lucide-react AlertTriangle | Already styled consistently |

**Key insight:** The LLM APIs already provide token counts in their responses - we just need to capture and store them. Don't attempt to count tokens client-side.

## Common Pitfalls

### Pitfall 1: Drag-Drop Z-Index and Overflow Issues
**What goes wrong:** Dragged element gets clipped by parent containers with overflow:hidden
**Why it happens:** DOM hierarchy clips children regardless of z-index
**How to avoid:** Use DragOverlay from @dnd-kit which renders a portal outside the DOM tree
**Warning signs:** Dragged element disappears when passing over sidebar or other containers

### Pitfall 2: Ollama Token Counts Undefined in Streaming
**What goes wrong:** `prompt_eval_count` may be undefined when streaming
**Why it happens:** Ollama only sends token counts in the final response chunk
**How to avoid:** Always use non-streaming mode for extraction (current approach), or collect from final chunk if streaming
**Warning signs:** Token count always shows 0 for local mode

### Pitfall 3: Race Conditions on Settings Save
**What goes wrong:** Multiple rapid saves overwrite each other
**Why it happens:** File-based settings without locking
**How to avoid:** Debounce settings saves, use optimistic UI updates
**Warning signs:** Settings appear to save then revert

### Pitfall 4: Token Limits Not Applied to Queue Processing
**What goes wrong:** User sets limit, but batch processing continues past limit
**Why it happens:** Limit check only at UI layer, not in processing queue
**How to avoid:** Check usage against limit before EACH extraction in main process QueueManager
**Warning signs:** Usage exceeds limit by multiple items

### Pitfall 5: Project Deletion Orphans Usage Data
**What goes wrong:** Usage events persist after project deleted
**Why it happens:** Missing foreign key CASCADE or manual cleanup
**How to avoid:** ON DELETE CASCADE on foreign keys (already done in schema example above)
**Warning signs:** Aggregate stats show tokens for deleted projects

## Code Examples

Verified patterns from official sources:

### DndContext Setup with Drag Overlay
```typescript
// Source: https://docs.dndkit.com/api-documentation/context-provider
import {
  DndContext,
  DragOverlay,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';

function DashboardWithDragDrop() {
  const [activeProject, setActiveProject] = useState<Project | null>(null);

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 8 }, // Prevent accidental drags
    }),
    useSensor(KeyboardSensor)
  );

  const handleDragStart = (event: DragStartEvent) => {
    if (event.active.data.current?.type === 'project') {
      setActiveProject(event.active.data.current.project);
    }
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    setActiveProject(null);

    if (over?.id === 'sidebar-quick-access' && active.data.current?.type === 'project') {
      // Pin project to sidebar
      addQuickAccessProject(active.data.current.project.id);
    }
  };

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <AppSidebar />
      <Dashboard />
      <DragOverlay>
        {activeProject ? <ProjectCardPreview project={activeProject} /> : null}
      </DragOverlay>
    </DndContext>
  );
}
```

### Usage Store with Zustand
```typescript
// Source: Zustand patterns from existing stores in project
import { create } from 'zustand';

interface UsageState {
  // Current period usage
  globalUsage: { tokens: number; requests: number };
  projectUsage: Record<string, { tokens: number; requests: number }>;

  // Limits from settings
  globalLimit: number | null;
  warningThreshold: number;

  // Actions
  loadUsage: () => Promise<void>;
  recordUsage: (projectId: string, tokens: number) => void;
  isOverLimit: (projectId?: string) => boolean;
  isNearLimit: (projectId?: string) => boolean;
}

export const useUsageStore = create<UsageState>((set, get) => ({
  globalUsage: { tokens: 0, requests: 0 },
  projectUsage: {},
  globalLimit: null,
  warningThreshold: 80,

  loadUsage: async () => {
    const result = await window.api.getUsageStats();
    if (result.success) {
      set({
        globalUsage: result.data.global,
        projectUsage: result.data.byProject,
      });
    }
  },

  recordUsage: (projectId, tokens) => {
    set((state) => ({
      globalUsage: {
        tokens: state.globalUsage.tokens + tokens,
        requests: state.globalUsage.requests + 1,
      },
      projectUsage: {
        ...state.projectUsage,
        [projectId]: {
          tokens: (state.projectUsage[projectId]?.tokens ?? 0) + tokens,
          requests: (state.projectUsage[projectId]?.requests ?? 0) + 1,
        },
      },
    }));
  },

  isOverLimit: (projectId) => {
    const { globalUsage, globalLimit } = get();
    if (globalLimit === null) return false;
    return globalUsage.tokens >= globalLimit;
  },

  isNearLimit: (projectId) => {
    const { globalUsage, globalLimit, warningThreshold } = get();
    if (globalLimit === null) return false;
    return globalUsage.tokens >= (globalLimit * warningThreshold / 100);
  },
}));
```

### Usage Warning Alert Component
```typescript
// Source: shadcn/ui Alert component pattern
import { AlertTriangle } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from '../ui/alert';
import { useUsageStore } from '../../stores/usageStore';

export function UsageWarning() {
  const { isNearLimit, isOverLimit, globalUsage, globalLimit } = useUsageStore();

  if (!globalLimit) return null;

  if (isOverLimit()) {
    return (
      <Alert variant="destructive" className="mb-4">
        <AlertTriangle className="h-4 w-4" />
        <AlertTitle>Usage Limit Reached</AlertTitle>
        <AlertDescription>
          You have reached your token limit ({globalUsage.tokens.toLocaleString()} / {globalLimit.toLocaleString()}).
          Processing is paused. Increase your limit in Settings to continue.
        </AlertDescription>
      </Alert>
    );
  }

  if (isNearLimit()) {
    return (
      <Alert variant="warning" className="mb-4">
        <AlertTriangle className="h-4 w-4" />
        <AlertTitle>Approaching Usage Limit</AlertTitle>
        <AlertDescription>
          You have used {globalUsage.tokens.toLocaleString()} of {globalLimit.toLocaleString()} tokens
          ({Math.round(globalUsage.tokens / globalLimit * 100)}%).
        </AlertDescription>
      </Alert>
    );
  }

  return null;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| react-beautiful-dnd | @dnd-kit or pragmatic-drag-and-drop | 2024 (Atlassian deprecation) | Use @dnd-kit for new projects |
| HTML5 Drag API | Framework-specific solutions | N/A | HTML5 API has cross-browser issues in Electron |
| Manual token counting | Use LLM response.usage | Always | APIs provide accurate counts |

**Deprecated/outdated:**
- react-beautiful-dnd: Deprecated by Atlassian in 2024, use @dnd-kit or hello-pangea/dnd fork
- react-sortable-hoc: No longer maintained, use @dnd-kit/sortable

## Open Questions

Things that couldn't be fully resolved:

1. **Quick Access Persistence Scope**
   - What we know: Pinned projects need to persist across sessions
   - What's unclear: Store in SQLite (with projects table) or settings.json?
   - Recommendation: Add `is_pinned` boolean to projects table - keeps project state together

2. **Token Cost Estimation for Local Mode**
   - What we know: OpenAI has clear per-token pricing, Ollama is free but uses compute
   - What's unclear: Should we show estimated "cost" for local mode based on equivalent cloud pricing?
   - Recommendation: Show token counts only (no cost) for local mode, show estimated cost for cloud mode

3. **Usage Reset Period**
   - What we know: Limits should have a period (daily, monthly, etc.)
   - What's unclear: What period makes most sense for recruiters?
   - Recommendation: Default to monthly with option to reset manually; use first day of month as reset

## Sources

### Primary (HIGH confidence)
- [@dnd-kit Documentation](https://docs.dndkit.com) - Draggable, Droppable, DragOverlay APIs
- [OpenAI API Reference - Usage](https://platform.openai.com/docs/api-reference/usage) - Token usage object structure
- [Ollama API Documentation](https://github.com/ollama/ollama/blob/main/docs/api.md) - eval_count/prompt_eval_count fields
- [shadcn/ui Dialog](https://ui.shadcn.com/docs/components/dialog) - Settings dialog patterns
- Existing codebase: database.ts, settings.ts, LLMSettings.tsx - Current patterns

### Secondary (MEDIUM confidence)
- [Top 5 Drag-and-Drop Libraries for React 2026](https://puckeditor.com/blog/top-5-drag-and-drop-libraries-for-react) - Library comparison
- [SQLite Forum - Schema Design](https://www.sqliteforum.com/p/effective-schema-design-for-sqlite) - Usage tracking patterns

### Tertiary (LOW confidence)
- Community patterns for Electron drag-drop (limited official guidance)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - @dnd-kit is well-documented and actively maintained, usage tracking is straightforward
- Architecture: HIGH - Follows existing patterns in codebase, SQLite triggers are standard
- Pitfalls: MEDIUM - Based on web search and documentation, some specific to this codebase

**Research date:** 2026-01-27
**Valid until:** 2026-02-27 (30 days - stable domain)
