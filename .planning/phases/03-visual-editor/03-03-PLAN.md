---
phase: 03-visual-editor
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/renderer/App.tsx
  - src/renderer/components/queue/QueueTabs.tsx
  - src/renderer/components/queue/QueueList.tsx
  - src/renderer/components/queue/QueueItem.tsx
  - src/renderer/components/queue/QueueControls.tsx
  - src/renderer/components/queue/DropZone.tsx
autonomous: true

must_haves:
  truths:
    - "User sees three tabs: Completed, Submitted, Failed"
    - "Tab headers show item counts"
    - "Queue items display filename and filetype"
    - "User can select items with checkboxes"
    - "Shift-click selects range of items"
    - "User can retry failed items"
    - "User can delete selected items"
    - "Drag-drop zone accepts CV files"
    - "Processing items show stage text (Parsing.../Extracting.../Saving...)"
  artifacts:
    - path: "src/renderer/components/queue/QueueTabs.tsx"
      provides: "Tab container with counts"
      exports: ["QueueTabs"]
    - path: "src/renderer/components/queue/QueueList.tsx"
      provides: "List of queue items for a tab"
      exports: ["QueueList"]
    - path: "src/renderer/components/queue/QueueItem.tsx"
      provides: "Single queue item row"
      exports: ["QueueItem"]
    - path: "src/renderer/components/queue/QueueControls.tsx"
      provides: "Bulk action buttons"
      exports: ["QueueControls"]
    - path: "src/renderer/components/queue/DropZone.tsx"
      provides: "Drag-drop file input"
      exports: ["DropZone"]
  key_links:
    - from: "src/renderer/components/queue/QueueTabs.tsx"
      to: "src/renderer/stores/queueStore.ts"
      via: "useQueueStore hook"
      pattern: "useQueueStore"
    - from: "src/renderer/components/queue/QueueItem.tsx"
      to: "src/renderer/stores/queueStore.ts"
      via: "toggleSelect, selectRange"
      pattern: "toggleSelect|selectRange"
    - from: "src/renderer/components/queue/DropZone.tsx"
      to: "window.api.extractCV"
      via: "IPC extraction call"
      pattern: "window\\.api\\.extractCV"
---

<objective>
Build the queue management UI with three tabs, item display, selection, and bulk actions.

Purpose: Replace the single-CV view with a full queue interface. Users can track processing status, select multiple items for bulk operations, retry failures, and delete items.

Output: Working queue UI with Completed/Submitted/Failed tabs, drag-drop intake, multi-select, and bulk actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-visual-editor/03-CONTEXT.md
@.planning/phases/03-visual-editor/03-RESEARCH.md

# Prior plan outputs
@src/renderer/stores/queueStore.ts
@src/renderer/types/cv.ts
@src/renderer/components/ui/tabs.tsx
@src/renderer/components/ui/button.tsx
@src/renderer/components/ui/badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueueTabs and QueueList components</name>
  <files>src/renderer/components/queue/QueueTabs.tsx, src/renderer/components/queue/QueueList.tsx</files>
  <action>
Create `src/renderer/components/queue/QueueTabs.tsx`:

```tsx
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs';
import { useQueueStore } from '../../stores/queueStore';
import { QueueList } from './QueueList';
import { QueueControls } from './QueueControls';
import { DropZone } from './DropZone';

export function QueueTabs() {
  const items = useQueueStore((state) => state.items);

  const counts = {
    completed: items.filter((i) => i.status === 'completed').length,
    submitted: items.filter((i) => i.status === 'submitted').length,
    failed: items.filter((i) => i.status === 'failed').length,
  };

  return (
    <div className="flex flex-col h-full">
      <Tabs defaultValue="completed" className="flex-1 flex flex-col">
        <div className="flex items-center justify-between px-4 py-2 border-b border-border">
          <TabsList className="bg-transparent">
            <TabsTrigger
              value="completed"
              className="data-[state=active]:bg-status-completed/20 data-[state=active]:text-status-completed"
            >
              Completed ({counts.completed})
            </TabsTrigger>
            <TabsTrigger
              value="submitted"
              className="data-[state=active]:bg-status-submitted/20 data-[state=active]:text-status-submitted"
            >
              Submitted ({counts.submitted})
            </TabsTrigger>
            <TabsTrigger
              value="failed"
              className="data-[state=active]:bg-status-failed/20 data-[state=active]:text-status-failed"
            >
              Failed ({counts.failed})
            </TabsTrigger>
          </TabsList>

          <QueueControls />
        </div>

        <div className="flex-1 overflow-hidden">
          <TabsContent value="completed" className="h-full m-0 p-0">
            <QueueList status="completed" />
          </TabsContent>
          <TabsContent value="submitted" className="h-full m-0 p-0">
            <QueueList status="submitted" />
          </TabsContent>
          <TabsContent value="failed" className="h-full m-0 p-0">
            <QueueList status="failed" />
          </TabsContent>
        </div>
      </Tabs>

      {/* Drop zone at bottom */}
      <DropZone />
    </div>
  );
}
```

Create `src/renderer/components/queue/QueueList.tsx`:

```tsx
import { useQueueStore } from '../../stores/queueStore';
import { QueueItem } from './QueueItem';
import type { QueueStatus } from '../../types/cv';

interface QueueListProps {
  status: QueueStatus;
}

export function QueueList({ status }: QueueListProps) {
  const items = useQueueStore((state) =>
    state.items.filter((item) => item.status === status)
  );

  if (items.length === 0) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        <p>
          {status === 'completed' && 'No completed CVs yet'}
          {status === 'submitted' && 'No CVs processing'}
          {status === 'failed' && 'No failed CVs'}
        </p>
      </div>
    );
  }

  return (
    <div className="h-full overflow-y-auto">
      <div className="divide-y divide-border">
        {items.map((item) => (
          <QueueItem key={item.id} item={item} />
        ))}
      </div>
    </div>
  );
}
```
  </action>
  <verify>
    - Files exist at correct paths
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>QueueTabs and QueueList components created with tab counts and filtered item display</done>
</task>

<task type="auto">
  <name>Task 2: Create QueueItem with selection and status display</name>
  <files>src/renderer/components/queue/QueueItem.tsx</files>
  <action>
Create `src/renderer/components/queue/QueueItem.tsx`:

```tsx
import { useCallback } from 'react';
import { useQueueStore } from '../../stores/queueStore';
import { useEditorStore } from '../../stores/editorStore';
import { Badge } from '../ui/badge';
import { cn } from '../../lib/utils';
import type { QueueItem as QueueItemType } from '../../types/cv';

interface QueueItemProps {
  item: QueueItemType;
}

export function QueueItem({ item }: QueueItemProps) {
  const selectedIds = useQueueStore((state) => state.selectedIds);
  const toggleSelect = useQueueStore((state) => state.toggleSelect);
  const selectRange = useQueueStore((state) => state.selectRange);

  const setActiveCV = useEditorStore((state) => state.setActiveCV);
  const loadCV = useEditorStore((state) => state.loadCV);

  const isSelected = selectedIds.has(item.id);

  const handleCheckboxChange = useCallback(() => {
    toggleSelect(item.id);
  }, [toggleSelect, item.id]);

  const handleClick = useCallback(
    (e: React.MouseEvent) => {
      // Shift-click for range selection
      if (e.shiftKey) {
        e.preventDefault();
        selectRange(item.id);
        return;
      }

      // Regular click to view/edit (only for completed items)
      if (item.status === 'completed') {
        loadCV(item.id);
      }
    },
    [selectRange, loadCV, item.id, item.status]
  );

  const getStatusBadge = () => {
    if (item.status === 'submitted' && item.stage) {
      return (
        <Badge className="bg-status-submitted/20 text-status-submitted border border-status-submitted">
          {item.stage}
        </Badge>
      );
    }

    if (item.status === 'failed') {
      return (
        <Badge className="bg-status-failed/20 text-status-failed border border-status-failed">
          {item.error || 'Failed'}
        </Badge>
      );
    }

    if (item.status === 'completed' && item.parseConfidence !== undefined) {
      const isLow = item.parseConfidence < 0.7;
      return (
        <Badge
          className={cn(
            'border',
            isLow
              ? 'bg-warning/20 text-warning border-warning'
              : 'bg-status-completed/20 text-status-completed border-status-completed'
          )}
          title={isLow ? 'Low confidence - may need review' : 'High confidence'}
        >
          {Math.round(item.parseConfidence * 100)}%
        </Badge>
      );
    }

    return null;
  };

  return (
    <div
      className={cn(
        'flex items-center gap-3 px-4 py-3 hover:bg-card cursor-pointer transition-colors',
        isSelected && 'bg-primary/10',
        item.status === 'completed' && 'hover:bg-card'
      )}
      onClick={handleClick}
    >
      {/* Checkbox */}
      <input
        type="checkbox"
        checked={isSelected}
        onChange={handleCheckboxChange}
        onClick={(e) => e.stopPropagation()}
        className="w-4 h-4 rounded border-border bg-background text-primary focus:ring-primary focus:ring-offset-0"
      />

      {/* File info */}
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className="font-medium truncate">{item.fileName}</span>
          <span className="text-xs text-muted-foreground uppercase">
            {item.fileType}
          </span>
        </div>
      </div>

      {/* Status badge */}
      {getStatusBadge()}
    </div>
  );
}
```

The component includes:
- Checkbox for selection (click doesn't propagate to row click)
- Shift-click range selection
- Filename + filetype display
- Status badge with stage text for processing, error for failed, confidence for completed
- Hover states with card background
- Click to view/edit for completed items
  </action>
  <verify>
    - File exists at src/renderer/components/queue/QueueItem.tsx
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>QueueItem component created with checkbox selection, shift-click range, status display, and click-to-view</done>
</task>

<task type="auto">
  <name>Task 3: Create QueueControls and DropZone components</name>
  <files>src/renderer/components/queue/QueueControls.tsx, src/renderer/components/queue/DropZone.tsx, src/renderer/App.tsx</files>
  <action>
Create `src/renderer/components/queue/QueueControls.tsx`:

```tsx
import { useQueueStore } from '../../stores/queueStore';
import { Button } from '../ui/button';

export function QueueControls() {
  const selectedIds = useQueueStore((state) => state.selectedIds);
  const items = useQueueStore((state) => state.items);
  const clearSelection = useQueueStore((state) => state.clearSelection);
  const retryFailed = useQueueStore((state) => state.retryFailed);
  const deleteSelected = useQueueStore((state) => state.deleteSelected);

  const selectedCount = selectedIds.size;

  // Check if any selected items are failed (for retry button)
  const hasFailedSelected = [...selectedIds].some((id) => {
    const item = items.find((i) => i.id === id);
    return item?.status === 'failed';
  });

  if (selectedCount === 0) {
    return null;
  }

  const handleRetry = async () => {
    const failedIds = [...selectedIds].filter((id) => {
      const item = items.find((i) => i.id === id);
      return item?.status === 'failed';
    });
    await retryFailed(failedIds);
  };

  const handleDelete = async () => {
    await deleteSelected();
  };

  return (
    <div className="flex items-center gap-2">
      <span className="text-sm text-muted-foreground">
        {selectedCount} selected
      </span>

      {hasFailedSelected && (
        <Button
          variant="outline"
          size="sm"
          onClick={handleRetry}
          className="btn-terminal"
        >
          Retry
        </Button>
      )}

      <Button
        variant="outline"
        size="sm"
        onClick={handleDelete}
        className="text-destructive hover:text-destructive hover:bg-destructive/10 hover:border-destructive"
      >
        Delete
      </Button>

      <Button
        variant="ghost"
        size="sm"
        onClick={clearSelection}
        className="text-muted-foreground"
      >
        Clear
      </Button>
    </div>
  );
}
```

Create `src/renderer/components/queue/DropZone.tsx`:

```tsx
import { useState, useCallback } from 'react';
import { useQueueStore } from '../../stores/queueStore';
import { cn } from '../../lib/utils';

export function DropZone() {
  const [isDragging, setIsDragging] = useState(false);
  const addItem = useQueueStore((state) => state.addItem);
  const updateStatus = useQueueStore((state) => state.updateStatus);
  const updateStage = useQueueStore((state) => state.updateStage);

  const processFile = useCallback(
    async (file: File, filePath: string) => {
      const fileType = file.name.split('.').pop()?.toLowerCase() || 'unknown';
      const itemId = crypto.randomUUID();

      // Add to queue as submitted
      addItem({
        id: itemId,
        fileName: file.name,
        fileType,
        filePath,
        status: 'submitted',
        stage: 'Parsing...',
      });

      try {
        // Update stage as processing continues
        updateStage(itemId, 'Extracting...');

        const result = await window.api.extractCV(filePath);

        if (result.success && result.data) {
          updateStage(itemId, 'Saving...');

          // Small delay to show saving stage
          await new Promise((resolve) => setTimeout(resolve, 200));

          updateStatus(itemId, 'completed', {
            data: result.data,
            parseConfidence: result.data.parse_confidence,
          });
        } else {
          updateStatus(itemId, 'failed', {
            error: result.error || 'Extraction failed',
          });
        }
      } catch (err) {
        updateStatus(itemId, 'failed', {
          error: err instanceof Error ? err.message : 'Unknown error',
        });
      }
    },
    [addItem, updateStatus, updateStage]
  );

  const handleDrop = useCallback(
    async (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);

      const files = Array.from(e.dataTransfer.files);
      const validExtensions = ['.pdf', '.docx', '.doc'];

      for (const file of files) {
        const ext = '.' + file.name.split('.').pop()?.toLowerCase();
        if (!validExtensions.includes(ext)) {
          console.warn(`Skipping unsupported file: ${file.name}`);
          continue;
        }

        const filePath = window.electronFile.getPath(file);
        if (filePath) {
          processFile(file, filePath);
        }
      }
    },
    [processFile]
  );

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  }, []);

  const handleClick = useCallback(async () => {
    const result = await window.api.selectCVFile();

    if (result.success && result.filePath && result.fileName) {
      const fileType = result.fileName.split('.').pop()?.toLowerCase() || 'unknown';
      processFile(
        { name: result.fileName } as File,
        result.filePath
      );
    }
  }, [processFile]);

  return (
    <div
      className={cn(
        'border-t border-border p-4 cursor-pointer transition-colors',
        isDragging ? 'bg-primary/10 border-primary' : 'hover:bg-card'
      )}
      onDrop={handleDrop}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onClick={handleClick}
    >
      <div className="flex items-center justify-center gap-2 text-muted-foreground">
        <span className="text-2xl">+</span>
        <span>Drop CV files here or click to select</span>
      </div>
    </div>
  );
}
```

Update `src/renderer/App.tsx` to use the queue components:

```tsx
import { useEffect } from 'react';
import { QueueTabs } from './components/queue/QueueTabs';
import { useQueueStore } from './stores/queueStore';
import { useEditorStore } from './stores/editorStore';
import './styles/globals.css';

export function App() {
  const loadFromDatabase = useQueueStore((state) => state.loadFromDatabase);
  const activeCVId = useEditorStore((state) => state.activeCVId);

  // Load existing CVs from database on mount
  useEffect(() => {
    loadFromDatabase();
  }, [loadFromDatabase]);

  return (
    <div className="h-screen flex flex-col bg-background">
      {/* Header */}
      <header className="flex items-center justify-between px-4 py-2 border-b border-border">
        <div>
          <h1 className="text-lg font-bold text-primary">Samsara</h1>
        </div>
        {activeCVId && (
          <span className="text-xs text-muted-foreground">
            Editing: {activeCVId.slice(0, 8)}...
          </span>
        )}
      </header>

      {/* Main content */}
      <main className="flex-1 overflow-hidden">
        <QueueTabs />
      </main>
    </div>
  );
}
```

Create an index file to export all queue components (optional but clean):

Create `src/renderer/components/queue/index.ts`:
```typescript
export { QueueTabs } from './QueueTabs';
export { QueueList } from './QueueList';
export { QueueItem } from './QueueItem';
export { QueueControls } from './QueueControls';
export { DropZone } from './DropZone';
```
  </action>
  <verify>
    - All files exist in src/renderer/components/queue/
    - TypeScript compiles: `npx tsc --noEmit`
    - `npm run start` shows queue UI with three tabs
    - Drag-drop zone visible at bottom
    - Dropping a PDF/DOCX file adds it to Submitted tab with stage indicator
    - Item moves to Completed or Failed tab after processing
    - Checkbox selection works
    - Shift-click selects range
    - Bulk delete removes selected items
    - Retry button appears when failed items selected
  </verify>
  <done>QueueControls and DropZone created, App.tsx updated to show full queue UI with tabs, selection, and bulk actions</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Tab display**: Three tabs visible (Completed, Submitted, Failed) with counts
2. **Tab colors**: Active tab has correct status color highlight
3. **Queue items**: Each item shows filename, filetype, and status badge
4. **Selection**:
   - Click checkbox to select single item
   - Shift-click selects range from last selected
   - Selection count shown in controls
5. **Bulk actions**:
   - Delete button removes selected items from database
   - Retry button appears for failed items, re-processes them
   - Clear button deselects all
6. **Drop zone**:
   - Drag file over shows highlight
   - Drop processes file(s)
   - Click opens native file dialog
7. **Processing flow**:
   - New file appears in Submitted tab
   - Stage text updates (Parsing... -> Extracting... -> Saving...)
   - Moves to Completed or Failed tab when done
</verification>

<success_criteria>
- QueueTabs renders with three tabs and accurate counts
- QueueList filters and displays items by status
- QueueItem shows checkbox, filename, filetype, and status badge
- Shift-click range selection works correctly
- QueueControls shows Delete for any selection, Retry for failed
- DropZone accepts drag-drop and click-to-select
- Processing updates status and stage in real-time
- Completed items can be clicked to set active CV (for Plan 04)
</success_criteria>

<output>
After completion, create `.planning/phases/03-visual-editor/03-03-SUMMARY.md`
</output>
