---
phase: 14-mvp-packaging-and-release
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - python-src/parsers/pdf_parser.py
autonomous: true

must_haves:
  truths:
    - "When PyMuPDF fails to extract text, pdfplumber is used as a full text fallback"
    - "Malformed PDFs are cleaned before extraction attempt"
    - "Image-only PDFs return a clear error message instead of crashing"
    - "Parser errors are caught and reported with specific failure reasons"
  artifacts:
    - path: "python-src/parsers/pdf_parser.py"
      provides: "Resilient PDF parsing with cascading fallback strategy"
      contains: "pdfplumber.*fallback"
  key_links:
    - from: "python-src/parsers/pdf_parser.py"
      to: "pdfplumber"
      via: "full text extraction fallback (not just tables)"
      pattern: "pdfplumber.*extract_text|pdfplumber.*get_text"
---

<objective>
Improve PDF parsing reliability by adding pdfplumber as a full text extraction fallback, PDF pre-cleaning for malformed files, and better error reporting for specific failure modes.

Purpose: Reduce PDF parsing failure rate from 30-40% to under 10% by handling the common failure cases (malformed PDFs, PyMuPDF crashes, edge-case layouts).
Output: A more resilient pdf_parser.py with cascading fallback strategy.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-mvp-packaging-and-release/14-RESEARCH.md
@python-src/parsers/pdf_parser.py
@python-src/parsers/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PDF pre-cleaning and pdfplumber text fallback</name>
  <files>python-src/parsers/pdf_parser.py</files>
  <action>
    NOTE: This plan executes on `master` branch first. The changes will be cherry-picked or merged to `mvp` branch by Plan 04.

    1. Add a PDF pre-cleaning step at the start of the main parse function:
       - Before extraction, run `doc.tobytes(garbage=3, clean=True)` to repair malformed PDFs
       - Reopen the cleaned bytes as a new document
       - Wrap in try/except — if cleaning fails, continue with original document

    2. Add pdfplumber as a FULL text extraction fallback (currently only used for tables):
       - After the PyMuPDF text extraction attempt, check if the result is empty or suspiciously short (< 50 chars for a multi-page PDF)
       - If so, fall back to pdfplumber's `page.extract_text()` for each page
       - Concatenate pdfplumber text results as the primary text output
       - Log which fallback was used for debugging

    3. Improve the `check_pdf_readable` function:
       - Instead of immediately returning False for image-only PDFs, return a specific error code/message: "image-only-pdf"
       - This distinguishes between "broken PDF" and "needs OCR" for better error reporting
       - Do NOT add OCR support (skip Tesseract for MVP) — just make the error message clear

    4. Add error recovery for PyMuPDF crashes:
       - Wrap the entire PyMuPDF extraction in try/except
       - On ANY exception (including segfaults caught as RuntimeError), fall back to pdfplumber-only extraction
       - Log the PyMuPDF failure reason

    5. Ensure all error paths return a ParseResult with a meaningful `error` field rather than raising exceptions that crash the sidecar.

  </action>
  <verify>
    ```bash
    cd python-src && python -m pytest tests/ -v -k "pdf" 2>/dev/null || echo "No PDF tests yet"
    cd python-src && python -c "from parsers.pdf_parser import parse_pdf; print('Import OK')"
    ```
  </verify>
  <done>pdf_parser.py has pre-cleaning step, pdfplumber full text fallback, improved error messages for image-only PDFs, and PyMuPDF crash recovery. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add PDF parser resilience tests</name>
  <files>python-src/tests/test_pdf_resilience.py</files>
  <action>
    Create tests for the new fallback behavior:

    1. Test that pre-cleaning is attempted (mock `doc.tobytes` to verify it's called with `garbage=3, clean=True`)
    2. Test pdfplumber fallback: mock PyMuPDF to return empty text, verify pdfplumber extraction is attempted
    3. Test PyMuPDF crash recovery: mock PyMuPDF to raise RuntimeError, verify pdfplumber fallback runs
    4. Test image-only PDF error message: mock `check_pdf_readable` to return image-only status, verify error message mentions "image-only"
    5. Test that parse errors return ParseResult with error field (not raised exceptions)

    Use unittest.mock to mock PyMuPDF behavior without needing actual PDF test files. Follow existing test patterns in the python-src/tests/ directory.

  </action>
  <verify>
    ```bash
    cd python-src && python -m pytest tests/test_pdf_resilience.py -v
    ```
  </verify>
  <done>All 5 resilience tests pass, covering pre-cleaning, pdfplumber fallback, crash recovery, image-only error, and error field propagation</done>
</task>

</tasks>

<verification>
- `cd python-src && python -m pytest tests/ -v` — all tests pass
- `cd python-src && python -m ruff check parsers/pdf_parser.py` — lint clean
- `grep "pdfplumber" python-src/parsers/pdf_parser.py` shows full text fallback (not just table extraction)
- `grep "garbage=3" python-src/parsers/pdf_parser.py` shows pre-cleaning
</verification>

<success_criteria>
PDF parser has cascading fallback strategy: clean PDF -> PyMuPDF extraction -> pdfplumber full text fallback -> clear error reporting. All tests pass. Image-only PDFs get a specific error message instead of a crash.
</success_criteria>

<output>
After completion, create `.planning/phases/14-mvp-packaging-and-release/14-02-SUMMARY.md`
</output>
