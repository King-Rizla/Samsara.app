# Phase 4.6: Queue Infrastructure & Persistence - Research

**Researched:** 2026-01-27
**Domain:** Electron IPC queue management, SQLite job persistence, real-time status updates
**Confidence:** HIGH (existing codebase patterns + Electron official docs)

## Summary

This phase addresses a critical architecture gap: the current implementation processes CVs synchronously on drop, starting the timeout immediately on submission rather than when Python actually begins processing. With the Python sidecar processing files sequentially, submitting multiple files causes cascading timeouts.

The solution involves three key changes:
1. **Database-backed queue** - CVs persist to SQLite with status column immediately on drop (not after processing)
2. **Queue manager in main process** - Serializes requests to Python sidecar, manages timeouts per-item
3. **Real-time IPC updates** - Uses `webContents.send` to push status changes to renderer

**Primary recommendation:** Add a `cv_queue` table (or status column on cvs table) for persistence, implement a QueueManager class in the main process that processes one item at a time, and use `webContents.send` for push-based status updates.

## Standard Stack

### Core (Already in Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| better-sqlite3 | existing | SQLite persistence | Already used with WAL mode; synchronous API ideal for queue operations |
| Zustand | existing | UI state management | Already used; will sync with main process queue state |
| spawn + readline | existing | Python IPC | Already established pattern per prior decision [01-03] |

### Supporting (No New Dependencies Needed)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| BrowserWindow.webContents.send | Electron built-in | Push updates to renderer | Status changes, progress updates |
| ipcRenderer.on | Electron built-in | Receive push updates | Subscribe to queue status events |
| EventEmitter | Node.js built-in | Internal queue events | QueueManager state transitions |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| SQLite queue | BullMQ/Redis | Overkill - requires Redis, not local-first |
| SQLite queue | In-memory Map | Lost on crash, doesn't survive navigation |
| Custom QueueManager | electron-common-ipc | Adds dependency for simple use case |
| Push via webContents | Zutron/Zubridge | Adds complexity; only need queue updates, not full state sync |

**Installation:**
```bash
# No new dependencies required - all functionality available in existing stack
```

## Architecture Patterns

### Recommended Changes to Project Structure
```
src/main/
  database.ts        # Add: cv_queue table OR status column on cvs
  pythonManager.ts   # Keep: No changes needed
  queueManager.ts    # NEW: QueueManager class
  index.ts           # Modify: Wire up QueueManager, add IPC listeners

src/renderer/
  stores/queueStore.ts  # Modify: Add queued status, listen for push updates
  types/cv.ts           # Modify: Add 'queued' to QueueStatus
```

### Pattern 1: Database-Backed Queue with Status Column
**What:** Add status column to track CV lifecycle: queued -> processing -> completed/failed
**When to use:** When queue items need to survive navigation and app restarts
**Example:**
```typescript
// Source: Project database.ts patterns + SQLite queue best practices
// Option A: Add status column to existing cvs table (simpler)
ALTER TABLE cvs ADD COLUMN status TEXT DEFAULT 'completed';
-- Status values: 'queued', 'processing', 'completed', 'failed'
-- Existing CVs default to 'completed'

// Option B: Separate cv_queue table (cleaner separation)
CREATE TABLE cv_queue (
  id TEXT PRIMARY KEY,
  project_id TEXT,
  file_path TEXT NOT NULL,
  file_name TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'queued',  -- queued, processing, completed, failed
  error TEXT,
  created_at TEXT NOT NULL,
  started_at TEXT,  -- When Python began processing (for timeout calc)
  completed_at TEXT,
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);
```

### Pattern 2: Main Process Queue Manager
**What:** Singleton class that manages queue processing, one item at a time
**When to use:** When Python sidecar can only handle one request at a time
**Example:**
```typescript
// Source: Node.js queue patterns + existing pythonManager.ts
class QueueManager {
  private processing = false;
  private mainWindow: BrowserWindow | null = null;

  constructor(private db: Database.Database) {}

  setMainWindow(win: BrowserWindow) {
    this.mainWindow = win;
  }

  async enqueue(item: QueueItem): Promise<string> {
    // 1. Persist to database immediately
    const id = this.insertQueueItem(item);

    // 2. Notify UI
    this.notifyStatusChange(id, 'queued');

    // 3. Start processing if idle
    this.processNext();

    return id;
  }

  private async processNext() {
    if (this.processing) return;

    const next = this.getNextPending();
    if (!next) return;

    this.processing = true;

    // Mark as processing in DB
    this.updateStatus(next.id, 'processing');
    this.notifyStatusChange(next.id, 'processing');

    // Start timeout NOW (when processing actually begins)
    const timeoutMs = 120000;
    const timeoutId = setTimeout(() => {
      this.handleTimeout(next.id);
    }, timeoutMs);

    try {
      const result = await extractCV(next.file_path);
      clearTimeout(timeoutId);
      // Save to cvs table, update queue status
      this.completeItem(next.id, result);
    } catch (error) {
      clearTimeout(timeoutId);
      this.failItem(next.id, error.message);
    }

    this.processing = false;
    this.processNext(); // Process next in queue
  }

  private notifyStatusChange(id: string, status: string, data?: any) {
    if (this.mainWindow) {
      this.mainWindow.webContents.send('queue-status-update', { id, status, data });
    }
  }
}
```

### Pattern 3: Push-Based UI Updates
**What:** Main process pushes status updates to renderer via webContents.send
**When to use:** For real-time queue status without polling
**Example:**
```typescript
// Preload (src/main/preload.ts)
contextBridge.exposeInMainWorld('api', {
  // ... existing methods
  onQueueStatusUpdate: (callback: (data: QueueStatusUpdate) => void) => {
    ipcRenderer.on('queue-status-update', (_event, data) => callback(data));
  },
  removeQueueStatusListener: () => {
    ipcRenderer.removeAllListeners('queue-status-update');
  },
});

// Renderer (src/renderer/stores/queueStore.ts)
// Call this on app mount
function subscribeToQueueUpdates() {
  window.api.onQueueStatusUpdate((update) => {
    const store = useQueueStore.getState();
    if (update.status === 'processing') {
      store.updateStage(update.id, 'Extracting...');
    } else if (update.status === 'completed') {
      store.updateStatus(update.id, 'completed', update.data);
    } else if (update.status === 'failed') {
      store.updateStatus(update.id, 'failed', { error: update.error });
    }
  });
}
```

### Anti-Patterns to Avoid
- **Starting timeout on submission:** The current bug - timeout should start when Python actually begins processing
- **Processing in renderer:** CV extraction should be managed by main process, not initiated per-item from renderer
- **Polling for status:** Use push via webContents.send instead of repeated IPC invoke calls
- **Storing queue only in Zustand:** Queue state is lost on navigation/refresh; must persist to SQLite

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Sequential processing | Custom Promise chain | QueueManager with processing flag | Handles edge cases (crash recovery, timeout) |
| Real-time updates | Polling with setInterval | webContents.send | More efficient, lower latency |
| Persistent queue | In-memory array | SQLite table | Survives navigation, crash recovery |
| Timeout management | Single global timeout | Per-item timeout starting on process start | Current bug is exactly this |

**Key insight:** The complexity is in state transitions and crash recovery, not the queue data structure itself. SQLite + simple QueueManager handles this better than hand-rolled in-memory solutions.

## Common Pitfalls

### Pitfall 1: Timeout Starting on Submission
**What goes wrong:** User drops 5 files, timeout (120s) starts immediately for all. First file takes 90s, remaining 4 timeout before Python even sees them.
**Why it happens:** Current code starts timeout when IPC request is sent, not when Python begins processing.
**How to avoid:** Start timeout in QueueManager when item moves from 'queued' to 'processing'.
**Warning signs:** Users report "Extraction timed out" for files that haven't been processed yet.

### Pitfall 2: Queue State Lost on Navigation
**What goes wrong:** User drops files in Project A, navigates to Project B, queue UI resets.
**Why it happens:** Zustand store is per-renderer, navigation remounts components.
**How to avoid:** Persist queue to SQLite, load on mount, filter by project_id for display.
**Warning signs:** "Submitted" items disappear when switching projects or refreshing.

### Pitfall 3: Concurrent Processing Attempts
**What goes wrong:** Multiple extractCV calls sent to Python simultaneously, causing timeout cascade.
**Why it happens:** DropZone processes files in parallel (current code has `await` but in a loop).
**How to avoid:** QueueManager enforces single processing with `this.processing` flag.
**Warning signs:** Multiple "Extracting..." items shown, high timeout rate.

### Pitfall 4: Race Condition in Status Updates
**What goes wrong:** UI shows 'completed' before database is updated, user clicks to view empty CV.
**Why it happens:** Main process sends status update before INSERT completes.
**How to avoid:** Atomic operation: INSERT to cvs, UPDATE queue status, THEN notify UI.
**Warning signs:** "CV not found" errors when clicking freshly completed items.

### Pitfall 5: Memory Leak from Event Listeners
**What goes wrong:** Multiple `onQueueStatusUpdate` listeners accumulate.
**Why it happens:** Components subscribe on mount but don't clean up.
**How to avoid:** Use `removeQueueStatusListener` in cleanup/useEffect return.
**Warning signs:** Multiple status updates per event, memory growth.

## Code Examples

Verified patterns from project codebase:

### Enqueue CV on Drop (modified DropZone)
```typescript
// Source: Current DropZone.tsx pattern adapted
const handleDrop = useCallback(async (e: React.DragEvent) => {
  e.preventDefault();
  setIsDragging(false);

  const files = Array.from(e.dataTransfer.files);
  const validExtensions = ['.pdf', '.docx', '.doc'];

  for (const file of files) {
    const ext = '.' + file.name.split('.').pop()?.toLowerCase();
    if (!validExtensions.includes(ext)) continue;

    const filePath = window.electronFile.getPath(file);
    if (!filePath) continue;

    // Enqueue instead of process immediately
    const result = await window.api.enqueueCV({
      fileName: file.name,
      filePath,
      projectId: activeProjectId,
    });

    if (result.success) {
      // Add to local store as 'queued' - will be updated via push
      addItem({
        id: result.id,
        fileName: file.name,
        filePath,
        status: 'queued',
        stage: 'Queued...',
      });
    }
  }
}, [addItem, activeProjectId]);
```

### Database Status Update (atomic operation)
```typescript
// Source: Project database.ts patterns
export function completeQueueItem(queueId: string, cvData: ParsedCV, filePath: string, projectId: string): string {
  const database = getDatabase();
  const now = new Date().toISOString();

  // Use transaction for atomicity
  const transaction = database.transaction(() => {
    // 1. Insert CV record
    const cvId = insertCV(cvData, filePath, projectId);

    // 2. Update queue status
    database.prepare(`
      UPDATE cv_queue SET status = 'completed', completed_at = ?, cv_id = ? WHERE id = ?
    `).run(now, cvId, queueId);

    return cvId;
  });

  return transaction();
}
```

### Subscribe to Queue Updates (renderer)
```typescript
// Source: Electron IPC patterns
// In App.tsx or top-level component
useEffect(() => {
  const unsubscribe = window.api.onQueueStatusUpdate((update) => {
    const { updateStatus, updateStage, updateItemId } = useQueueStore.getState();

    switch (update.status) {
      case 'processing':
        updateStage(update.id, 'Extracting...');
        break;
      case 'completed':
        if (update.cvId && update.cvId !== update.id) {
          updateItemId(update.id, update.cvId);
        }
        updateStatus(update.cvId || update.id, 'completed', {
          parseConfidence: update.data?.parse_confidence,
        });
        break;
      case 'failed':
        updateStatus(update.id, 'failed', { error: update.error });
        break;
    }
  });

  return () => {
    window.api.removeQueueStatusListener();
  };
}, []);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Immediate processing | Queue-based processing | This phase | Enables bulk processing without timeouts |
| Renderer-initiated extraction | Main process QueueManager | This phase | Single source of truth, proper timeout handling |
| Polling for status | webContents.send push | Electron 7+ (2019) | Lower latency, less overhead |
| In-memory queue | SQLite-backed queue | This phase | Survives navigation/restart |

**Deprecated/outdated:**
- `ipcRenderer.send` + `ipcMain.on` for request/response: Use `ipcRenderer.invoke` + `ipcMain.handle` for two-way
- Synchronous IPC (`ipcRenderer.sendSync`): Blocks renderer, never use

## Open Questions

1. **Queue table vs status column on cvs?**
   - What we know: Both approaches work; queue table is cleaner, status column is simpler
   - What's unclear: Whether failed items should persist (queue table) or be transient
   - Recommendation: Use status column on cvs table for simplicity; add error column. Failed items can be retried.

2. **What happens to queued items on app restart?**
   - What we know: SQLite persists, Python sidecar restarts fresh
   - What's unclear: Should 'processing' items revert to 'queued' on startup?
   - Recommendation: On app start, reset any 'processing' items to 'queued' (they didn't complete)

3. **Should queue be global or per-project?**
   - What we know: CVs belong to projects; queue should respect this
   - What's unclear: Can user process across projects simultaneously?
   - Recommendation: Single global queue (Python can only process one), but items have project_id. Display filters by current project.

## Sources

### Primary (HIGH confidence)
- [Electron IPC Documentation](https://www.electronjs.org/docs/latest/tutorial/ipc) - webContents.send patterns
- [Electron webContents API](https://www.electronjs.org/docs/latest/api/web-contents) - send method reference
- Project codebase: `src/main/database.ts`, `src/main/pythonManager.ts`, `src/renderer/stores/queueStore.ts`

### Secondary (MEDIUM confidence)
- [Node.js Sequential Job Processing](https://shabir.medium.com/sequential-job-processing-in-nodejs-4408bce3943b) - Queue patterns
- [SQLite Job Queue Pattern](https://jasongorman.uk/writing/sqlite-background-job-system/) - Status column approach
- [Electron Advanced Architecture](https://blog.logrocket.com/advanced-electron-js-architecture/) - Main/renderer communication

### Tertiary (LOW confidence)
- [GitHub electron/electron#13968](https://github.com/electron/electron/issues/13968) - IPC FIFO behavior (unconfirmed guarantee)
- [Zutron library](https://github.com/goosewobbler/zutron) - Considered but not recommended for this use case

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Uses existing project dependencies, no new libraries needed
- Architecture: HIGH - Based on Electron official docs and existing codebase patterns
- Pitfalls: HIGH - Derived from analyzing current bug and common queue implementation issues

**Research date:** 2026-01-27
**Valid until:** 2026-02-27 (30 days - stable patterns)
