---
phase: 04-jd-matching
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/renderer/lib/skillVariants.ts
  - src/renderer/lib/matchingEngine.ts
  - src/main/index.ts
  - src/main/database.ts
  - src/main/preload.ts
  - src/renderer/stores/jdStore.ts
  - src/renderer/types/jd.ts
autonomous: true

must_haves:
  truths:
    - "System calculates match score (0-100%) for CV against JD"
    - "Matching uses hybrid approach: exact + variant + substring matching"
    - "Required skills weighted 70%, preferred skills weighted 30%"
    - "Match results include matched skills and missing required/preferred lists"
    - "Match results persist to SQLite for retrieval"
  artifacts:
    - path: "src/renderer/lib/skillVariants.ts"
      provides: "Skill variant mapping and normalization functions"
      contains: "SKILL_VARIANTS"
      min_lines: 60
    - path: "src/renderer/lib/matchingEngine.ts"
      provides: "calculateMatchScore function with hybrid matching"
      contains: "calculateMatchScore"
      min_lines: 80
    - path: "src/main/database.ts"
      provides: "insertMatchResult, getMatchResults functions"
      contains: "insertMatchResult"
    - path: "src/main/preload.ts"
      provides: "matchCVsToJD IPC method"
      contains: "matchCVsToJD"
  key_links:
    - from: "src/renderer/lib/matchingEngine.ts"
      to: "src/renderer/lib/skillVariants.ts"
      via: "import getSkillVariants"
      pattern: "getSkillVariants"
    - from: "src/main/index.ts"
      to: "src/main/database.ts"
      via: "insertMatchResult call"
      pattern: "insertMatchResult"
---

<objective>
Implement the CV-JD matching algorithm and scoring engine.

Purpose: Calculate match scores between CVs and job descriptions using a hybrid matching approach (exact, variant, substring) with weighted scoring (70% required, 30% preferred). This is the core intelligence of the JD matching feature.

Output:
- Skill variant mapping with common aliases
- Matching engine with hybrid scoring algorithm
- IPC handler for batch matching
- Database persistence for match results
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-jd-matching/04-RESEARCH.md
@.planning/phases/04-jd-matching/04-01-SUMMARY.md

# Types from Plan 01
@src/renderer/types/jd.ts
@src/renderer/types/cv.ts

# Database from Plan 01
@src/main/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill variant mapping and normalization</name>
  <files>
    src/renderer/lib/skillVariants.ts
  </files>
  <action>
Create `src/renderer/lib/skillVariants.ts` with comprehensive skill variant mappings:

```typescript
/**
 * Skill variant mapping for matching skills across different naming conventions.
 * Keys are canonical (lowercase) skill names, values are common aliases.
 */
export const SKILL_VARIANTS: Record<string, string[]> = {
  // Programming languages
  'javascript': ['js', 'ecmascript', 'es6', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020'],
  'typescript': ['ts'],
  'python': ['py', 'python3', 'python 3'],
  'c#': ['csharp', 'c sharp', 'dotnet', '.net', 'c-sharp'],
  'c++': ['cpp', 'cplusplus', 'c plus plus'],
  'golang': ['go'],
  'ruby': ['rb'],
  'rust': ['rs'],

  // Frontend frameworks
  'react': ['reactjs', 'react.js', 'react js'],
  'angular': ['angularjs', 'angular.js', 'angular 2', 'angular2'],
  'vue': ['vuejs', 'vue.js', 'vue js', 'vue 3', 'vue3'],
  'svelte': ['sveltejs', 'svelte.js'],
  'next.js': ['nextjs', 'next js', 'next'],
  'nuxt': ['nuxtjs', 'nuxt.js'],

  // Backend frameworks
  'node.js': ['nodejs', 'node js', 'node'],
  'express': ['expressjs', 'express.js'],
  'django': ['django rest', 'drf'],
  'flask': ['flask api'],
  'spring': ['spring boot', 'springboot'],
  'fastapi': ['fast api'],
  '.net core': ['dotnet core', 'asp.net core', 'aspnet core'],

  // Databases
  'postgresql': ['postgres', 'psql', 'pgsql'],
  'mongodb': ['mongo'],
  'mysql': ['mariadb'],
  'sql server': ['mssql', 'microsoft sql', 'ms sql'],
  'redis': ['redis cache'],
  'elasticsearch': ['elastic', 'es'],

  // Cloud
  'aws': ['amazon web services', 'amazon aws', 'amazon cloud'],
  'azure': ['microsoft azure', 'ms azure'],
  'gcp': ['google cloud', 'google cloud platform'],
  'kubernetes': ['k8s'],
  'docker': ['containerization', 'containers'],

  // Tools & practices
  'git': ['github', 'gitlab', 'bitbucket', 'version control'],
  'ci/cd': ['continuous integration', 'continuous deployment', 'jenkins', 'github actions'],
  'agile': ['scrum', 'kanban', 'agile methodology'],
  'devops': ['dev ops', 'development operations'],
  'test-driven development': ['tdd', 'test driven'],
  'restful api': ['rest api', 'rest', 'restful'],
  'graphql': ['graph ql'],

  // Soft skills
  'communication': ['communication skills', 'verbal communication', 'written communication'],
  'leadership': ['team leadership', 'leading teams', 'team lead'],
  'project management': ['project mgmt', 'pm', 'managing projects'],
  'problem solving': ['problem-solving', 'analytical skills', 'critical thinking'],
  'teamwork': ['team work', 'collaboration', 'team player'],
};

/**
 * Normalize a skill name for consistent matching.
 * - Lowercase
 * - Trim whitespace
 * - Normalize multiple spaces to single space
 * - Remove special characters except -, +, #, .
 */
export function normalizeSkill(skill: string): string {
  return skill
    .toLowerCase()
    .trim()
    .replace(/\s+/g, ' ')
    .replace(/[^\w\s\-\+\#\.]/g, '');
}

/**
 * Get all known variants of a skill (including the canonical name).
 * Returns empty array if skill has no known variants.
 */
export function getSkillVariants(skill: string): string[] {
  const normalized = normalizeSkill(skill);

  // Check if skill is a canonical key
  if (SKILL_VARIANTS[normalized]) {
    return [normalized, ...SKILL_VARIANTS[normalized]];
  }

  // Check if skill is a variant - find its canonical form
  for (const [canonical, variants] of Object.entries(SKILL_VARIANTS)) {
    if (variants.includes(normalized)) {
      return [canonical, ...variants];
    }
  }

  // No known variants
  return [];
}

/**
 * Check if two skills match (considering variants).
 */
export function skillsMatch(skill1: string, skill2: string): boolean {
  const norm1 = normalizeSkill(skill1);
  const norm2 = normalizeSkill(skill2);

  // Exact match
  if (norm1 === norm2) return true;

  // Check variants
  const variants1 = getSkillVariants(norm1);
  const variants2 = getSkillVariants(norm2);

  // If either has variants, check for overlap
  if (variants1.length > 0 && variants2.length > 0) {
    return variants1.some(v => variants2.includes(v));
  }

  // Substring matching for compound skills
  // "Microsoft Excel" matches "Excel", "React Native" matches "React"
  if (norm1.includes(norm2) || norm2.includes(norm1)) {
    return true;
  }

  return false;
}
```
  </action>
  <verify>
```bash
cd "C:\Users\edwar\Documents\dev\Projects\Samsara"
# Verify file exists and compiles
npx tsc --noEmit src/renderer/lib/skillVariants.ts 2>&1 | head -10

# Quick unit test via node
npx tsx -e "
import { normalizeSkill, skillsMatch, getSkillVariants } from './src/renderer/lib/skillVariants';

// Test normalization
console.log('Normalize test:', normalizeSkill('  JavaScript  ') === 'javascript');

// Test exact match
console.log('Exact match:', skillsMatch('Python', 'python'));

// Test variant match
console.log('Variant match:', skillsMatch('JS', 'JavaScript'));

// Test substring match
console.log('Substring match:', skillsMatch('Microsoft Excel', 'Excel'));

console.log('All tests passed!');
"
```
  </verify>
  <done>
- SKILL_VARIANTS mapping created with programming languages, frameworks, databases, cloud, tools, soft skills
- normalizeSkill() function for consistent skill comparison
- getSkillVariants() function to retrieve all aliases for a skill
- skillsMatch() function with hybrid matching (exact + variant + substring)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create matching engine with weighted scoring</name>
  <files>
    src/renderer/lib/matchingEngine.ts
  </files>
  <action>
Create `src/renderer/lib/matchingEngine.ts`:

```typescript
import type { JobDescription, MatchResult, SkillRequirement } from '../types/jd';
import type { ParsedCV, SkillGroup } from '../types/cv';
import { normalizeSkill, skillsMatch } from './skillVariants';

/**
 * Flatten CV skills from grouped format into a normalized array.
 */
function flattenCVSkills(skillGroups: SkillGroup[]): string[] {
  const allSkills: string[] = [];

  for (const group of skillGroups) {
    for (const skill of group.skills) {
      allSkills.push(normalizeSkill(skill));
    }
  }

  return allSkills;
}

/**
 * Check if a JD skill requirement is matched by any CV skill.
 */
function findMatchingSkill(
  requirement: SkillRequirement,
  cvSkills: string[]
): string | null {
  const normalizedReq = normalizeSkill(requirement.skill);

  for (const cvSkill of cvSkills) {
    if (skillsMatch(normalizedReq, cvSkill)) {
      return cvSkill;  // Return the CV skill that matched
    }
  }

  return null;
}

/**
 * Calculate match score between a CV and a Job Description.
 *
 * Scoring algorithm:
 * - Required skills: 70% weight
 * - Preferred skills: 30% weight
 *
 * If a category has no requirements, full credit is given for that category.
 *
 * @returns MatchResult with score (0-100) and detailed breakdown
 */
export function calculateMatchScore(
  cv: ParsedCV,
  jd: JobDescription
): MatchResult {
  const cvSkills = flattenCVSkills(cv.skills);

  const matchedRequired: string[] = [];
  const missingRequired: string[] = [];
  const matchedPreferred: string[] = [];
  const missingPreferred: string[] = [];

  // Check required skills
  for (const req of jd.required_skills) {
    const match = findMatchingSkill(req, cvSkills);
    if (match) {
      matchedRequired.push(req.skill);
    } else {
      missingRequired.push(req.skill);
    }
  }

  // Check preferred skills
  for (const pref of jd.preferred_skills) {
    const match = findMatchingSkill(pref, cvSkills);
    if (match) {
      matchedPreferred.push(pref.skill);
    } else {
      missingPreferred.push(pref.skill);
    }
  }

  // Calculate weighted score
  const requiredWeight = 0.7;
  const preferredWeight = 0.3;

  // If no required skills specified, give full credit for required portion
  const requiredScore = jd.required_skills.length > 0
    ? (matchedRequired.length / jd.required_skills.length) * requiredWeight
    : requiredWeight;

  // If no preferred skills specified, give full credit for preferred portion
  const preferredScore = jd.preferred_skills.length > 0
    ? (matchedPreferred.length / jd.preferred_skills.length) * preferredWeight
    : preferredWeight;

  const matchScore = Math.round((requiredScore + preferredScore) * 100);

  return {
    cv_id: '', // Will be set by caller
    jd_id: jd.id,
    match_score: matchScore,
    matched_skills: [...matchedRequired, ...matchedPreferred],
    missing_required: missingRequired,
    missing_preferred: missingPreferred,
    calculated_at: new Date().toISOString(),
  };
}

/**
 * Calculate match scores for multiple CVs against a single JD.
 * Returns results sorted by match score (highest first).
 */
export function calculateBatchMatchScores(
  cvs: Array<{ id: string; cv: ParsedCV }>,
  jd: JobDescription
): MatchResult[] {
  const results: MatchResult[] = [];

  for (const { id, cv } of cvs) {
    const result = calculateMatchScore(cv, jd);
    result.cv_id = id;
    results.push(result);
  }

  // Sort by match score descending
  results.sort((a, b) => b.match_score - a.match_score);

  return results;
}

/**
 * Get a human-readable match quality label.
 */
export function getMatchQuality(score: number): {
  label: string;
  color: 'green' | 'yellow' | 'orange' | 'red';
} {
  if (score >= 75) {
    return { label: 'Strong Match', color: 'green' };
  } else if (score >= 50) {
    return { label: 'Good Match', color: 'yellow' };
  } else if (score >= 25) {
    return { label: 'Partial Match', color: 'orange' };
  } else {
    return { label: 'Weak Match', color: 'red' };
  }
}
```
  </action>
  <verify>
```bash
cd "C:\Users\edwar\Documents\dev\Projects\Samsara"
# Verify file compiles
npx tsc --noEmit src/renderer/lib/matchingEngine.ts 2>&1 | head -10

# Test matching logic
npx tsx -e "
import { calculateMatchScore, getMatchQuality } from './src/renderer/lib/matchingEngine';

// Mock CV with skills
const mockCV = {
  contact: {},
  work_history: [],
  education: [],
  skills: [
    { category: 'Programming', skills: ['Python', 'JavaScript', 'TypeScript'] },
    { category: 'Frameworks', skills: ['React', 'Node.js', 'Django'] },
  ],
  certifications: [],
  languages: [],
  other_sections: {},
  raw_text: '',
  section_order: [],
  parse_confidence: 0.8,
  warnings: [],
};

// Mock JD
const mockJD = {
  id: 'test-jd',
  title: 'Senior Developer',
  raw_text: '',
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  required_skills: [
    { skill: 'Python', importance: 'required' as const },
    { skill: 'React', importance: 'required' as const },
    { skill: 'AWS', importance: 'required' as const },  // Missing
  ],
  preferred_skills: [
    { skill: 'TypeScript', importance: 'preferred' as const },
    { skill: 'GraphQL', importance: 'preferred' as const },  // Missing
  ],
  certifications: [],
};

const result = calculateMatchScore(mockCV, mockJD);
console.log('Match score:', result.match_score);
console.log('Matched skills:', result.matched_skills);
console.log('Missing required:', result.missing_required);
console.log('Missing preferred:', result.missing_preferred);

const quality = getMatchQuality(result.match_score);
console.log('Quality:', quality.label);
"
```
  </verify>
  <done>
- flattenCVSkills() extracts all skills from CV skill groups
- findMatchingSkill() checks if JD requirement matches any CV skill
- calculateMatchScore() implements 70/30 weighted scoring algorithm
- calculateBatchMatchScores() processes multiple CVs and sorts by score
- getMatchQuality() provides human-readable match labels
  </done>
</task>

<task type="auto">
  <name>Task 3: Add database functions and IPC handlers for matching</name>
  <files>
    src/main/database.ts
    src/main/index.ts
    src/main/preload.ts
    src/renderer/stores/jdStore.ts
    src/renderer/types/jd.ts
  </files>
  <action>
**1. Add to `src/main/database.ts`:**

Add match result storage functions:

```typescript
export interface MatchResultRecord {
  cv_id: string;
  jd_id: string;
  match_score: number;
  matched_skills_json: string | null;
  missing_required_json: string | null;
  missing_preferred_json: string | null;
  calculated_at: string;
}

/**
 * Insert or update a match result.
 */
export function insertMatchResult(result: {
  cv_id: string;
  jd_id: string;
  match_score: number;
  matched_skills: string[];
  missing_required: string[];
  missing_preferred: string[];
  calculated_at: string;
}): void {
  const database = getDatabase();

  const stmt = database.prepare(`
    INSERT OR REPLACE INTO cv_jd_matches (
      cv_id, jd_id, match_score,
      matched_skills_json, missing_required_json, missing_preferred_json,
      calculated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?)
  `);

  stmt.run(
    result.cv_id,
    result.jd_id,
    result.match_score,
    JSON.stringify(result.matched_skills),
    JSON.stringify(result.missing_required),
    JSON.stringify(result.missing_preferred),
    result.calculated_at
  );
}

/**
 * Get all match results for a JD, sorted by score descending.
 */
export function getMatchResultsForJD(jdId: string): MatchResultRecord[] {
  const database = getDatabase();

  const stmt = database.prepare(`
    SELECT * FROM cv_jd_matches
    WHERE jd_id = ?
    ORDER BY match_score DESC
  `);

  return stmt.all(jdId) as MatchResultRecord[];
}

/**
 * Delete all match results for a JD.
 */
export function deleteMatchResultsForJD(jdId: string): void {
  const database = getDatabase();
  const stmt = database.prepare('DELETE FROM cv_jd_matches WHERE jd_id = ?');
  stmt.run(jdId);
}

/**
 * Get match result for a specific CV-JD pair.
 */
export function getMatchResult(cvId: string, jdId: string): MatchResultRecord | null {
  const database = getDatabase();
  const stmt = database.prepare(`
    SELECT * FROM cv_jd_matches
    WHERE cv_id = ? AND jd_id = ?
  `);
  return (stmt.get(cvId, jdId) as MatchResultRecord) || null;
}
```

**2. Add to `src/main/index.ts`:**

Add match IPC handlers:

```typescript
import {
  insertMatchResult,
  getMatchResultsForJD,
  getCVFull,
  getJD
} from './database';

// Import matching engine (need to make it available in main process)
// Since matching engine uses renderer types, we'll do calculation in main process
// by duplicating the core logic or passing to renderer

ipcMain.handle('match-cvs-to-jd', async (_event, jdId: string, cvIds: string[]) => {
  try {
    const jd = getJD(jdId);
    if (!jd) {
      return { success: false, error: 'JD not found' };
    }

    // Parse JD skills from JSON
    const requiredSkills = JSON.parse(jd.required_skills_json || '[]');
    const preferredSkills = JSON.parse(jd.preferred_skills_json || '[]');

    const results = [];

    for (const cvId of cvIds) {
      const cv = getCVFull(cvId);
      if (!cv) continue;

      // Calculate match using simplified main-process logic
      const cvSkills = flattenSkills(cv.skills);
      const matchResult = calculateMatch(
        cvId,
        jdId,
        cvSkills,
        requiredSkills,
        preferredSkills
      );

      // Store in database
      insertMatchResult(matchResult);
      results.push(matchResult);
    }

    // Sort by score descending
    results.sort((a, b) => b.match_score - a.match_score);

    return { success: true, results };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Match calculation failed'
    };
  }
});

ipcMain.handle('get-match-results', async (_event, jdId: string) => {
  try {
    const results = getMatchResultsForJD(jdId);

    // Parse JSON fields
    const parsed = results.map(r => ({
      cv_id: r.cv_id,
      jd_id: r.jd_id,
      match_score: r.match_score,
      matched_skills: JSON.parse(r.matched_skills_json || '[]'),
      missing_required: JSON.parse(r.missing_required_json || '[]'),
      missing_preferred: JSON.parse(r.missing_preferred_json || '[]'),
      calculated_at: r.calculated_at,
    }));

    return { success: true, data: parsed };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get match results'
    };
  }
});

// Helper functions for main process matching
function flattenSkills(skillGroups: Array<{ category: string; skills: string[] }>): string[] {
  const skills: string[] = [];
  for (const group of skillGroups) {
    skills.push(...group.skills.map(s => s.toLowerCase().trim()));
  }
  return skills;
}

function skillMatches(needle: string, haystack: string[]): boolean {
  const normalized = needle.toLowerCase().trim();

  // Exact match
  if (haystack.includes(normalized)) return true;

  // Substring match
  for (const skill of haystack) {
    if (skill.includes(normalized) || normalized.includes(skill)) {
      return true;
    }
  }

  return false;
}

function calculateMatch(
  cvId: string,
  jdId: string,
  cvSkills: string[],
  requiredSkills: Array<{ skill: string }>,
  preferredSkills: Array<{ skill: string }>
) {
  const matchedRequired: string[] = [];
  const missingRequired: string[] = [];
  const matchedPreferred: string[] = [];
  const missingPreferred: string[] = [];

  for (const req of requiredSkills) {
    if (skillMatches(req.skill, cvSkills)) {
      matchedRequired.push(req.skill);
    } else {
      missingRequired.push(req.skill);
    }
  }

  for (const pref of preferredSkills) {
    if (skillMatches(pref.skill, cvSkills)) {
      matchedPreferred.push(pref.skill);
    } else {
      missingPreferred.push(pref.skill);
    }
  }

  const requiredScore = requiredSkills.length > 0
    ? (matchedRequired.length / requiredSkills.length) * 0.7
    : 0.7;

  const preferredScore = preferredSkills.length > 0
    ? (matchedPreferred.length / preferredSkills.length) * 0.3
    : 0.3;

  return {
    cv_id: cvId,
    jd_id: jdId,
    match_score: Math.round((requiredScore + preferredScore) * 100),
    matched_skills: [...matchedRequired, ...matchedPreferred],
    missing_required: missingRequired,
    missing_preferred: missingPreferred,
    calculated_at: new Date().toISOString(),
  };
}
```

**3. Add to `src/main/preload.ts`:**

Add match IPC methods:

```typescript
// Match operations
matchCVsToJD: (jdId: string, cvIds: string[]): Promise<{ success: boolean; results?: unknown[]; error?: string }> =>
  ipcRenderer.invoke('match-cvs-to-jd', jdId, cvIds),

getMatchResults: (jdId: string): Promise<{ success: boolean; data?: unknown[]; error?: string }> =>
  ipcRenderer.invoke('get-match-results', jdId),
```

**4. Update `src/renderer/stores/jdStore.ts`:**

Add matching actions:

```typescript
// Add to interface
matchCVs: (cvIds: string[]) => Promise<{ success: boolean; error?: string }>;
loadMatchResults: () => Promise<void>;

// Add to store implementation
matchCVs: async (cvIds) => {
  const { activeJDId } = get();
  if (!activeJDId) {
    return { success: false, error: 'No JD selected' };
  }

  try {
    const result = await window.api.matchCVsToJD(activeJDId, cvIds);
    if (result.success && result.results) {
      set({ matchResults: result.results as MatchResult[] });
      return { success: true };
    }
    return { success: false, error: result.error || 'Matching failed' };
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Matching failed'
    };
  }
},

loadMatchResults: async () => {
  const { activeJDId } = get();
  if (!activeJDId) return;

  try {
    const result = await window.api.getMatchResults(activeJDId);
    if (result.success && result.data) {
      set({ matchResults: result.data as MatchResult[] });
    }
  } catch (err) {
    console.error('Failed to load match results:', err);
  }
},
```

**5. Ensure `src/renderer/types/jd.ts` has Window API types updated:**

Add to the global Window interface:

```typescript
matchCVsToJD: (jdId: string, cvIds: string[]) => Promise<{ success: boolean; results?: MatchResult[]; error?: string }>;
getMatchResults: (jdId: string) => Promise<{ success: boolean; data?: MatchResult[]; error?: string }>;
```
  </action>
  <verify>
```bash
cd "C:\Users\edwar\Documents\dev\Projects\Samsara"
# Verify full build compiles
npm run build 2>&1 | tail -20

# Check new IPC handlers exist
grep -n "match-cvs-to-jd\|get-match-results" src/main/index.ts | head -10
grep -n "matchCVsToJD\|getMatchResults" src/main/preload.ts | head -10
```
  </verify>
  <done>
- insertMatchResult(), getMatchResultsForJD(), getMatchResult() database functions added
- match-cvs-to-jd IPC handler calculates and stores matches for multiple CVs
- get-match-results IPC handler retrieves stored matches sorted by score
- Main process matching logic (simplified version of renderer engine)
- Preload exposures for matchCVsToJD and getMatchResults
- jdStore updated with matchCVs() and loadMatchResults() actions
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build**: `npm run build` passes without errors
2. **Unit test skill matching**: Run tsx test snippet from Task 1
3. **Unit test scoring**: Run tsx test snippet from Task 2
4. **IPC handlers**: Verify handlers registered in main process

Full integration test (manual):
1. Start app
2. Create a JD via JDInput
3. Have some CVs in queue
4. Call matchCVsToJD via console: `window.api.matchCVsToJD('jd-id', ['cv-id-1', 'cv-id-2'])`
5. Verify results returned with scores
6. Call getMatchResults to verify persistence
</verification>

<success_criteria>
- [ ] `src/renderer/lib/skillVariants.ts` with SKILL_VARIANTS mapping and helper functions
- [ ] `src/renderer/lib/matchingEngine.ts` with calculateMatchScore implementing 70/30 weighting
- [ ] Database functions for match result CRUD operations
- [ ] IPC handlers match-cvs-to-jd and get-match-results working
- [ ] Preload exposures for matching operations
- [ ] jdStore extended with matchCVs() and loadMatchResults() actions
- [ ] Build compiles without errors
- [ ] Matching correctly identifies exact, variant, and substring skill matches
</success_criteria>

<output>
After completion, create `.planning/phases/04-jd-matching/04-02-SUMMARY.md`
</output>
