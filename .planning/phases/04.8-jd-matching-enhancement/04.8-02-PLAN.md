---
phase: 04.8-jd-matching-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["04.8-01"]
files_modified:
  - python-src/extractors/llm/schemas.py
  - python-src/extractors/llm/prompts.py
autonomous: true

must_haves:
  truths:
    - "JD extraction generates skill variants for each skill"
    - "JD extraction generates three-tier boolean strings (wide/midline/narrow)"
    - "JD extraction generates search hints (titles, industries, negatives)"
    - "Single LLM call extracts both requirements AND matching metadata"
  artifacts:
    - path: "python-src/extractors/llm/schemas.py"
      provides: "Extended LLMJDExtraction with matching_metadata"
      contains: "LLMMatchingMetadata"
    - path: "python-src/extractors/llm/prompts.py"
      provides: "Enhanced JD_EXTRACTION_PROMPT"
      contains: "MATCHING METADATA"
  key_links:
    - from: "LLMJDExtraction"
      to: "LLMMatchingMetadata"
      via: "matching_metadata field"
      pattern: "matching_metadata.*LLMMatchingMetadata"
---

<objective>
Enhance Python JD extraction to generate matching metadata (skill variants, booleans, search hints) in a single LLM call.

Purpose: Maximize the value of each JD parsing LLM call by extracting not just requirements, but also semantic skill variants, pre-generated boolean search strings, and search hints for improved matching and future auto-sourcing.

Output: Extended Pydantic schemas and enhanced prompt that generate comprehensive matching metadata alongside standard JD extraction.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-RESEARCH.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-01-SUMMARY.md

# Key existing code
@python-src/extractors/llm/schemas.py
@python-src/extractors/llm/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matching metadata Pydantic schemas</name>
  <files>python-src/extractors/llm/schemas.py</files>
  <action>
Add new Pydantic models for matching metadata after the existing JD schemas:

```python
# ============================================================================
# JD Matching Metadata Schemas (Phase 4.8)
# ============================================================================

class LLMExpandedSkill(BaseModel):
    """A skill with semantic variants for improved matching."""

    skill: str = Field(
        description="Original skill name from JD (e.g., 'Python', 'React')"
    )
    variants: List[str] = Field(
        default_factory=list,
        description="Alternative names, abbreviations, synonyms (e.g., 'JavaScript' -> ['JS', 'ECMAScript', 'ES6']). Limit to 5 most common."
    )
    related_tools: List[str] = Field(
        default_factory=list,
        description="Related frameworks, libraries, tools that demonstrate this skill (e.g., 'Python' -> ['Django', 'Flask', 'FastAPI']). Limit to 5 most relevant."
    )


class LLMBooleanStrings(BaseModel):
    """Pre-generated boolean search strings for recruiting platforms."""

    wide: str = Field(
        description="Broad search with many OR terms: (\"Python\" OR \"Django\" OR \"Flask\") OR (\"AWS\" OR \"Cloud\"). Keep under 250 chars."
    )
    midline: str = Field(
        description="Balanced search: (\"Python\" OR \"Py\") AND (\"AWS\" OR \"Amazon Web Services\"). Keep under 250 chars."
    )
    narrow: str = Field(
        description="Strict search with required terms only: \"Python\" AND \"AWS\" AND \"Senior\". Keep under 200 chars."
    )


class LLMSearchHints(BaseModel):
    """Search hints for future auto-sourcing feature."""

    suggested_titles: List[str] = Field(
        default_factory=list,
        description="Related job titles to search (e.g., 'Backend Developer', 'Python Engineer'). Limit to 5."
    )
    industries: List[str] = Field(
        default_factory=list,
        description="Relevant industries (e.g., 'FinTech', 'SaaS', 'Healthcare'). Limit to 3."
    )
    negative_keywords: List[str] = Field(
        default_factory=list,
        description="Terms to exclude from searches (e.g., 'Junior', 'Intern', 'Entry-level'). Limit to 5."
    )


class LLMMatchingMetadata(BaseModel):
    """Enhanced matching data generated from JD analysis."""

    expanded_skills: List[LLMExpandedSkill] = Field(
        default_factory=list,
        description="All skills from required_skills and preferred_skills with variants and related tools"
    )
    boolean_strings: LLMBooleanStrings = Field(
        description="Pre-generated boolean search strings in three tiers"
    )
    search_hints: LLMSearchHints = Field(
        default_factory=LLMSearchHints,
        description="Search hints for candidate sourcing"
    )
```

Then update LLMJDExtraction to include the matching_metadata field:

```python
class LLMJDExtraction(BaseModel):
    """Complete JD extraction in a single LLM call - ENHANCED with matching metadata."""

    title: str = Field(
        description="Job title (e.g., 'Senior Software Engineer', 'Product Manager')"
    )
    company: Optional[str] = Field(
        default=None,
        description="Company name if mentioned"
    )

    required_skills: List[LLMSkillRequirement] = Field(
        default_factory=list,
        description="Skills explicitly marked as required, mandatory, or must-have"
    )
    preferred_skills: List[LLMSkillRequirement] = Field(
        default_factory=list,
        description="Skills marked as preferred, desired, nice-to-have, or bonus"
    )

    experience_min_years: Optional[int] = Field(
        default=None,
        description="Minimum years of experience required (e.g., '5+ years' -> 5)"
    )
    experience_max_years: Optional[int] = Field(
        default=None,
        description="Maximum years of experience if range given"
    )

    education_level: Optional[str] = Field(
        default=None,
        description="Required education level (Bachelor's, Master's, PhD)"
    )
    certifications: List[str] = Field(
        default_factory=list,
        description="Required or preferred certifications"
    )

    # NEW: Matching metadata for enhanced matching
    matching_metadata: Optional[LLMMatchingMetadata] = Field(
        default=None,
        description="Enhanced matching data including skill variants, boolean strings, and search hints"
    )
```

Note: matching_metadata is Optional to maintain backward compatibility. If the LLM fails to generate it, extraction still succeeds with requirements only.
  </action>
  <verify>
1. Python syntax check: `python -m py_compile python-src/extractors/llm/schemas.py`
2. Import check: `cd python-src && python -c "from extractors.llm.schemas import LLMJDExtraction, LLMMatchingMetadata; print('OK')"`
  </verify>
  <done>LLMMatchingMetadata and related schemas exist, LLMJDExtraction includes optional matching_metadata field</done>
</task>

<task type="auto">
  <name>Task 2: Enhance JD extraction prompt</name>
  <files>python-src/extractors/llm/prompts.py</files>
  <action>
Replace the existing JD_EXTRACTION_PROMPT with an enhanced version that instructs the LLM to generate matching metadata:

```python
JD_EXTRACTION_PROMPT = """You are a job description parser AND recruiting assistant. Extract structured requirements AND generate matching metadata in ONE response.

## PART 1: REQUIREMENTS EXTRACTION
Extract these fields:
- title: Job title exactly as written
- company: Company name if mentioned (null if not)
- required_skills: Skills marked as REQUIRED/MANDATORY/MUST-HAVE/ESSENTIAL
- preferred_skills: Skills marked as PREFERRED/DESIRED/NICE-TO-HAVE/BONUS
- experience_min_years: Minimum years (e.g., "5+ years" -> 5)
- experience_max_years: Maximum years if range given (null if not)
- education_level: Required education (Bachelor's, Master's, PhD)
- certifications: List of required/preferred certifications

Each skill: {"skill": "name", "importance": "required" or "preferred", "category": "Technical" or null}

## PART 2: MATCHING METADATA
Generate enhanced matching data:

### EXPANDED_SKILLS
For EACH skill in required_skills and preferred_skills, create an entry with:
- skill: The original skill name
- variants: Up to 5 alternative names, abbreviations, acronyms (e.g., "JavaScript" -> ["JS", "ECMAScript", "ES6+"])
- related_tools: Up to 5 frameworks/libraries that demonstrate this skill (e.g., "Python" -> ["Django", "Flask", "FastAPI"])

### BOOLEAN_STRINGS
Generate three boolean search strings using standard syntax (AND, OR, NOT, quotes for phrases, parentheses for grouping):
- wide: Broad search - OR-heavy, many alternatives. Under 250 characters.
- midline: Balanced - core skills as AND, variations as OR. Under 250 characters.
- narrow: Strict - required skills only as AND terms. Under 200 characters.

Example:
- wide: ("Software Engineer" OR "Developer" OR "Programmer") AND ("Python" OR "Django" OR "Flask" OR "JavaScript" OR "React")
- midline: ("Python" OR "Py") AND ("React" OR "ReactJS") AND "Senior"
- narrow: "Python" AND "React" AND "Senior" AND "5 years"

### SEARCH_HINTS
- suggested_titles: Up to 5 related job titles candidates might have
- industries: Up to 3 relevant industries
- negative_keywords: Up to 5 terms to exclude (e.g., "Junior", "Intern" if looking for Senior)

## OUTPUT FORMAT
Return a single JSON object with BOTH requirements AND matching_metadata:

{
  "title": "Senior Software Engineer",
  "company": "Acme Corp",
  "required_skills": [{"skill": "Python", "importance": "required", "category": "Technical"}],
  "preferred_skills": [{"skill": "Kubernetes", "importance": "preferred", "category": "DevOps"}],
  "experience_min_years": 5,
  "experience_max_years": null,
  "education_level": "Bachelor's",
  "certifications": ["AWS Certified"],
  "matching_metadata": {
    "expanded_skills": [
      {"skill": "Python", "variants": ["Py", "Python3"], "related_tools": ["Django", "Flask", "FastAPI"]},
      {"skill": "Kubernetes", "variants": ["K8s", "Kube"], "related_tools": ["Helm", "kubectl", "Docker"]}
    ],
    "boolean_strings": {
      "wide": "(\"Senior\" OR \"Lead\") AND (\"Python\" OR \"Django\" OR \"Flask\") AND (\"Kubernetes\" OR \"Docker\" OR \"AWS\")",
      "midline": "(\"Python\" OR \"Py\") AND (\"Kubernetes\" OR \"K8s\") AND \"Senior\"",
      "narrow": "\"Python\" AND \"Kubernetes\" AND \"Senior\" AND \"5 years\""
    },
    "search_hints": {
      "suggested_titles": ["Backend Developer", "Platform Engineer", "DevOps Engineer"],
      "industries": ["SaaS", "FinTech"],
      "negative_keywords": ["Junior", "Intern", "Graduate"]
    }
  }
}

## GUIDELINES
- Only extract what is EXPLICITLY stated in the JD for requirements
- Generate helpful variants and related tools based on your knowledge for matching_metadata
- Boolean strings should be immediately usable on LinkedIn Recruiter
- Keep boolean strings within character limits
- Use null for missing fields, not empty strings
- Return ONLY the JSON object, no explanation"""
```
  </action>
  <verify>
1. Python syntax check: `python -m py_compile python-src/extractors/llm/prompts.py`
2. Prompt length reasonable: `cd python-src && python -c "from extractors.llm.prompts import JD_EXTRACTION_PROMPT; print(f'Prompt length: {len(JD_EXTRACTION_PROMPT)} chars')"`
  </verify>
  <done>JD_EXTRACTION_PROMPT instructs LLM to generate matching_metadata alongside requirements</done>
</task>

<task type="auto">
  <name>Task 3: Test JD extraction with matching metadata</name>
  <files>python-src/extractors/llm/schemas.py, python-src/extractors/llm/prompts.py</files>
  <action>
Test the enhanced extraction by running the Python sidecar with a test JD. Create a quick test script:

1. Start the app: `npm run start`
2. In the app, create a new JD with this test text:

```
Senior Software Engineer - Backend

Company: TechCorp

We are looking for a Senior Software Engineer to join our backend team.

Requirements:
- 5+ years of experience in software development
- Strong proficiency in Python and Django
- Experience with PostgreSQL or MySQL
- AWS experience (EC2, S3, Lambda)

Nice to have:
- Kubernetes or Docker experience
- GraphQL knowledge
- Bachelor's degree in Computer Science
```

3. Check the console logs for the extraction response - it should include matching_metadata
4. Verify the JD was saved with matching_metadata in the database

Alternative: If the app isn't running the latest schemas, restart the Python sidecar after the changes.
  </action>
  <verify>
1. JD extraction succeeds (no errors in console)
2. Console logs show matching_metadata with expanded_skills, boolean_strings, search_hints
3. JD displays correctly in the UI (existing fields still work)
  </verify>
  <done>JD extraction generates matching_metadata with skill variants, boolean strings, and search hints</done>
</task>

</tasks>

<verification>
1. `python -m py_compile python-src/extractors/llm/schemas.py` - no errors
2. `python -m py_compile python-src/extractors/llm/prompts.py` - no errors
3. New JD extraction includes matching_metadata in response
4. Existing JD viewing functionality still works
</verification>

<success_criteria>
- LLMJDExtraction schema includes optional matching_metadata field
- JD_EXTRACTION_PROMPT instructs LLM to generate matching metadata
- JD extraction returns expanded_skills with variants and related_tools for each skill
- JD extraction returns three-tier boolean_strings (wide/midline/narrow)
- JD extraction returns search_hints (suggested_titles, industries, negative_keywords)
- Single LLM call handles both requirements AND matching metadata
</success_criteria>

<output>
After completion, create `.planning/phases/04.8-jd-matching-enhancement/04.8-02-SUMMARY.md`
</output>
