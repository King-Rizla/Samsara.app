---
phase: 11-ai-voice-screening
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/main/transcriptAnalyzer.ts
  - src/main/voicePoller.ts
  - src/main/index.ts
  - src/main/preload.ts
  - src/renderer/components/outreach/CallRecordCard.tsx
  - src/renderer/components/outreach/TranscriptViewer.tsx
  - src/renderer/components/outreach/CandidatePanel.tsx
  - src/renderer/stores/outreachStore.ts
autonomous: true

must_haves:
  truths:
    - "Completed calls are analyzed by Claude to determine pass/maybe/fail outcome"
    - "Call records show outcome badge (pass/maybe/fail) with confidence score"
    - "Full transcript is viewable in the candidate side panel"
    - "Screening outcome updates workflow state and candidate card"
  artifacts:
    - path: "src/main/transcriptAnalyzer.ts"
      provides: "Claude-based transcript analysis for pass/maybe/fail determination"
      exports: ["analyzeTranscript"]
    - path: "src/renderer/components/outreach/CallRecordCard.tsx"
      provides: "Call outcome display with duration and confidence"
      min_lines: 80
    - path: "src/renderer/components/outreach/TranscriptViewer.tsx"
      provides: "Full transcript display with speaker labels"
      min_lines: 50
  key_links:
    - from: "src/main/voicePoller.ts"
      to: "src/main/transcriptAnalyzer.ts"
      via: "analyzeTranscript called when call completes"
      pattern: "analyzeTranscript"
    - from: "src/main/transcriptAnalyzer.ts"
      to: "src/main/workflowService.ts"
      via: "reportScreeningComplete with outcome"
      pattern: "reportScreeningComplete"
    - from: "src/renderer/components/outreach/CandidatePanel.tsx"
      to: "src/renderer/components/outreach/CallRecordCard.tsx"
      via: "Renders call records in message history"
      pattern: "CallRecordCard"
---

<objective>
Implement transcript analysis with Claude and UI for displaying call outcomes and transcripts.

Purpose: Complete the voice screening loop by analyzing call transcripts to determine pass/maybe/fail outcomes, updating workflow state, and providing recruiters visibility into call results with full transcripts.

Output: Transcript analyzer using Claude API, call record UI components, and transcript viewer integrated into candidate panel.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ai-voice-screening/11-CONTEXT.md
@.planning/phases/11-ai-voice-screening/11-RESEARCH.md
@.planning/phases/11-ai-voice-screening/11-01-SUMMARY.md
@src/main/voiceService.ts
@src/main/voicePoller.ts
@src/renderer/components/outreach/CandidatePanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transcript analyzer with Claude integration</name>
  <files>
    - src/main/transcriptAnalyzer.ts
    - src/main/voicePoller.ts
  </files>
  <action>
    Create src/main/transcriptAnalyzer.ts:

    ```typescript
    /**
     * Transcript Analyzer - Phase 11 AI Voice Screening
     *
     * Uses Claude to analyze screening call transcripts and determine
     * pass/maybe/fail outcomes based on project screening criteria.
     *
     * Per CONTEXT.md:
     * - Disqualification model (filter out, not filter in)
     * - Key disqualifiers: location mismatch, salary out of range, not interested
     * - Post-call analysis (not real-time)
     */

    import Anthropic from '@anthropic-ai/sdk';
    import { getCredential } from './credentialManager';
    import { getScreeningCriteria, ScreeningCriteria } from './screeningService';

    // Types
    export interface ScreeningResult {
      outcome: 'pass' | 'maybe' | 'fail';
      confidence: number;  // 0-100
      reasoning: string;
      extractedData: {
        salaryExpectation?: string;
        location?: string;
        availability?: string;
        interestLevel?: string;
        contactPreference?: string;
      };
      disqualifiers: string[];
    }

    /**
     * Analyze a screening transcript to determine pass/maybe/fail.
     * Uses Claude to extract information and evaluate against criteria.
     *
     * Per CONTEXT.md decisions:
     * - 5 fixed question categories: salary, location, availability, interest, contact
     * - Disqualification model: filter out candidates who don't meet thresholds
     * - pass/maybe/fail outcome structure
     */
    export async function analyzeTranscript(
      transcript: string,
      projectId: string
    ): Promise<ScreeningResult> {
      const apiKey = getCredential(null, 'anthropic', 'api_key');

      if (!apiKey) {
        console.warn('[TranscriptAnalyzer] No Anthropic API key, returning maybe');
        return {
          outcome: 'maybe',
          confidence: 50,
          reasoning: 'No API key configured for transcript analysis - requires manual review',
          extractedData: {},
          disqualifiers: [],
        };
      }

      // Get screening criteria for this project
      const criteria = getScreeningCriteria(projectId);

      const client = new Anthropic({ apiKey });

      const systemPrompt = buildSystemPrompt(criteria);
      const userPrompt = buildUserPrompt(transcript);

      try {
        const response = await client.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 1024,
          messages: [
            { role: 'user', content: userPrompt },
          ],
          system: systemPrompt,
        });

        const textContent = response.content.find(c => c.type === 'text');
        if (!textContent || textContent.type !== 'text') {
          throw new Error('No text response from Claude');
        }

        // Parse JSON response - handle markdown code blocks
        let jsonText = textContent.text.trim();
        if (jsonText.startsWith('```json')) {
          jsonText = jsonText.slice(7);
        }
        if (jsonText.startsWith('```')) {
          jsonText = jsonText.slice(3);
        }
        if (jsonText.endsWith('```')) {
          jsonText = jsonText.slice(0, -3);
        }
        jsonText = jsonText.trim();

        const result = JSON.parse(jsonText) as ScreeningResult;

        // Validate and constrain outcome
        if (!['pass', 'maybe', 'fail'].includes(result.outcome)) {
          result.outcome = 'maybe';
        }
        result.confidence = Math.max(0, Math.min(100, result.confidence || 50));

        console.log(`[TranscriptAnalyzer] Analysis complete: ${result.outcome} (${result.confidence}%)`);
        return result;
      } catch (error) {
        console.error('[TranscriptAnalyzer] Analysis failed:', error);
        return {
          outcome: 'maybe',
          confidence: 50,
          reasoning: 'Analysis failed - requires manual review',
          extractedData: {},
          disqualifiers: [],
        };
      }
    }

    /**
     * Build system prompt for transcript analysis.
     */
    function buildSystemPrompt(criteria: ScreeningCriteria): string {
      return `You are analyzing a pre-screening call transcript between a recruitment AI agent and a candidate.

Your task is to:

1. Extract key information from the 5 question categories
2. Identify any disqualifying factors
3. Determine if the candidate should PASS, MAYBE, or FAIL

## Screening Criteria

${criteria.salaryMin || criteria.salaryMax ? `Salary Range: ${criteria.salaryMin ? `Min: ${criteria.salaryMin.toLocaleString()}` : ''} ${criteria.salaryMax ? `Max: ${criteria.salaryMax.toLocaleString()}` : ''}` : 'Salary: No specific range set'}
${criteria.allowedLocations?.length ? `Allowed Locations: ${criteria.allowedLocations.join(', ')}` : 'Locations: Any'}
${criteria.minimumNoticePeriod ? `Min Notice: ${criteria.minimumNoticePeriod}` : ''}
${criteria.maximumNoticePeriod ? `Max Notice: ${criteria.maximumNoticePeriod}` : ''}

## Disqualification Reasons

- Salary expectation significantly above range (>20% over max)
- Location mismatch with no willingness to relocate (if locations specified)
- Explicitly not interested in opportunities
- Unavailable for the foreseeable future
- Rude, unresponsive, or hung up during call

## Outcome Definitions

**PASS**: Meets criteria, engaged, interested, no disqualifiers
**MAYBE**: Some uncertainty, partial answers, minor concerns, needs recruiter review
**FAIL**: Clear disqualifier present

When in doubt, lean toward MAYBE - recruiters can make final decisions.

Respond with JSON only. No markdown code blocks.`;
}

    /**
     * Build user prompt with transcript.
     */
    function buildUserPrompt(transcript: string): string {
      return `Analyze this screening call transcript:

---

## ${transcript}

Return JSON with this exact structure:
{
"outcome": "pass" | "maybe" | "fail",
"confidence": number (0-100),
"reasoning": "Brief explanation of the outcome",
"extractedData": {
"salaryExpectation": "string or null - what they said about salary",
"location": "string or null - their current location",
"availability": "string or null - when they can start",
"interestLevel": "string or null - how interested they seemed",
"contactPreference": "string or null - best way to reach them"
},
"disqualifiers": ["list of disqualifying factors if any"]
}`;
}
```

    Update src/main/voicePoller.ts to use the analyzer:

    1. Import analyzeTranscript:
       ```typescript
       import { analyzeTranscript } from './transcriptAnalyzer';
       ```

    2. Update the call completion handling in pollCallStatuses:
       ```typescript
       if (status.status === 'completed' && call.cv_id) {
         // Store transcript
         // ... existing transcript storage code ...

         // Analyze transcript for pass/maybe/fail
         if (status.transcript) {
           const projectRow = db.prepare(`
             SELECT project_id FROM call_records WHERE id = ?
           `).get(call.id) as { project_id: string };

           const result = await analyzeTranscript(status.transcript, projectRow.project_id);

           // Update call record with screening outcome
           db.prepare(`
             UPDATE call_records SET
               screening_outcome = ?,
               screening_confidence = ?,
               extracted_data_json = ?
             WHERE id = ?
           `).run(
             result.outcome,
             result.confidence,
             JSON.stringify(result.extractedData),
             call.id
           );

           // Report to workflow
           const workflowOutcome = result.outcome === 'pass' ? 'passed' : 'failed';
           if (getWorkflowActor(call.cv_id)) {
             reportScreeningComplete(call.cv_id, workflowOutcome);
           }

           console.log(`[VoicePoller] Call ${call.id} analyzed: ${result.outcome} (${result.confidence}%)`);
         }
       }
       ```

    3. Make pollCallStatuses async if not already:
       ```typescript
       async function pollCallStatuses(): Promise<void> { ... }
       ```

  </action>
  <verify>
    `npm run typecheck` passes.
    transcriptAnalyzer.ts exports analyzeTranscript.
    voicePoller calls analyzeTranscript on completed calls.
  </verify>
  <done>
    Completed calls are analyzed by Claude; outcomes stored in database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create call record UI components</name>
  <files>
    - src/renderer/components/outreach/CallRecordCard.tsx
    - src/renderer/components/outreach/TranscriptViewer.tsx
  </files>
  <action>
    Create src/renderer/components/outreach/CallRecordCard.tsx:

    ```typescript
    /**
     * CallRecordCard - Display screening call outcome
     *
     * Shows call status, duration, outcome badge (pass/maybe/fail),
     * and confidence score. Includes button to view full transcript.
     */

    import {
      Phone,
      Clock,
      TrendingUp,
      AlertCircle,
      CheckCircle,
      HelpCircle,
      FileText,
    } from 'lucide-react';
    import { Card, CardContent, CardHeader, CardTitle } from '../ui/card';
    import { Badge } from '../ui/badge';
    import { Button } from '../ui/button';
    import { cn } from '../../lib/utils';

    interface CallRecord {
      id: string;
      status: 'in_progress' | 'completed' | 'failed' | 'no_answer';
      durationSeconds?: number;
      screeningOutcome?: 'pass' | 'maybe' | 'fail';
      screeningConfidence?: number;
      startedAt: string;
      endedAt?: string;
    }

    interface CallRecordCardProps {
      call: CallRecord;
      onViewTranscript: () => void;
    }

    function getOutcomeStyle(outcome?: string) {
      switch (outcome) {
        case 'pass':
          return {
            icon: CheckCircle,
            color: 'text-green-500',
            bg: 'bg-green-500/10',
            border: 'border-green-500/30',
            label: 'Passed',
          };
        case 'fail':
          return {
            icon: AlertCircle,
            color: 'text-red-500',
            bg: 'bg-red-500/10',
            border: 'border-red-500/30',
            label: 'Failed',
          };
        case 'maybe':
          return {
            icon: HelpCircle,
            color: 'text-amber-500',
            bg: 'bg-amber-500/10',
            border: 'border-amber-500/30',
            label: 'Maybe',
          };
        default:
          return {
            icon: Phone,
            color: 'text-muted-foreground',
            bg: 'bg-muted',
            border: 'border-muted',
            label: 'Unknown',
          };
      }
    }

    function getStatusLabel(status: string): string {
      switch (status) {
        case 'in_progress':
          return 'In Progress';
        case 'completed':
          return 'Completed';
        case 'failed':
          return 'Failed';
        case 'no_answer':
          return 'No Answer';
        default:
          return status;
      }
    }

    function formatDuration(seconds?: number): string {
      if (!seconds) return '--:--';
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    export function CallRecordCard({ call, onViewTranscript }: CallRecordCardProps) {
      const outcomeStyle = getOutcomeStyle(call.screeningOutcome);
      const OutcomeIcon = outcomeStyle.icon;
      const isCompleted = call.status === 'completed';

      return (
        <Card className={cn('transition-colors', outcomeStyle.bg, outcomeStyle.border)}>
          <CardHeader className="pb-2">
            <div className="flex items-center justify-between">
              <CardTitle className="text-sm font-medium flex items-center gap-2">
                <Phone className="h-4 w-4" />
                Screening Call
              </CardTitle>
              {isCompleted && call.screeningOutcome ? (
                <Badge variant="outline" className={cn('font-medium', outcomeStyle.color)}>
                  <OutcomeIcon className="h-3 w-3 mr-1" />
                  {outcomeStyle.label}
                </Badge>
              ) : (
                <Badge variant="outline" className="text-muted-foreground">
                  {getStatusLabel(call.status)}
                </Badge>
              )}
            </div>
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="flex items-center justify-between text-sm">
              <div className="flex items-center gap-2 text-muted-foreground">
                <Clock className="h-4 w-4" />
                {call.status === 'in_progress' ? 'In progress...' : `Duration: ${formatDuration(call.durationSeconds)}`}
              </div>
              {call.screeningConfidence != null && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <TrendingUp className="h-4 w-4" />
                  Confidence: {Math.round(call.screeningConfidence)}%
                </div>
              )}
            </div>

            <div className="text-xs text-muted-foreground">
              {new Date(call.startedAt).toLocaleString()}
            </div>

            {isCompleted && (
              <Button
                variant="outline"
                size="sm"
                onClick={onViewTranscript}
                className="w-full"
              >
                <FileText className="h-4 w-4 mr-2" />
                View Transcript
              </Button>
            )}
          </CardContent>
        </Card>
      );
    }
    ```

    Create src/renderer/components/outreach/TranscriptViewer.tsx:

    ```typescript
    /**
     * TranscriptViewer - Display full call transcript
     *
     * Shows conversation with speaker labels and timestamps.
     * Displays extracted data and analysis reasoning.
     */

    import { User, Bot, Info, AlertTriangle } from 'lucide-react';
    import {
      Dialog,
      DialogContent,
      DialogHeader,
      DialogTitle,
      DialogDescription,
    } from '../ui/dialog';
    import { ScrollArea } from '../ui/scroll-area';
    import { Badge } from '../ui/badge';
    import { Separator } from '../ui/separator';
    import { cn } from '../../lib/utils';

    interface TranscriptSegment {
      role: 'agent' | 'user';
      message: string;
      time_in_call_secs?: number;
    }

    interface ExtractedData {
      salaryExpectation?: string;
      location?: string;
      availability?: string;
      interestLevel?: string;
      contactPreference?: string;
    }

    interface TranscriptViewerProps {
      open: boolean;
      onOpenChange: (open: boolean) => void;
      transcript: string;
      segments?: TranscriptSegment[];
      extractedData?: ExtractedData;
      outcome?: 'pass' | 'maybe' | 'fail';
      confidence?: number;
      reasoning?: string;
      disqualifiers?: string[];
    }

    export function TranscriptViewer({
      open,
      onOpenChange,
      transcript,
      segments,
      extractedData,
      outcome,
      confidence,
      reasoning,
      disqualifiers,
    }: TranscriptViewerProps) {
      // Parse raw transcript if segments not provided
      const parsedSegments: TranscriptSegment[] = segments || parseTranscript(transcript);

      return (
        <Dialog open={open} onOpenChange={onOpenChange}>
          <DialogContent className="max-w-2xl max-h-[80vh] flex flex-col">
            <DialogHeader>
              <DialogTitle>Call Transcript</DialogTitle>
              <DialogDescription>
                Full conversation transcript with analysis results
              </DialogDescription>
            </DialogHeader>

            {/* Analysis Summary */}
            {outcome && (
              <div className="space-y-3 py-3 border-b">
                <div className="flex items-center gap-3">
                  <Badge
                    variant="outline"
                    className={cn(
                      'font-medium',
                      outcome === 'pass' && 'text-green-500 border-green-500/50',
                      outcome === 'maybe' && 'text-amber-500 border-amber-500/50',
                      outcome === 'fail' && 'text-red-500 border-red-500/50',
                    )}
                  >
                    {outcome.toUpperCase()}
                  </Badge>
                  {confidence != null && (
                    <span className="text-sm text-muted-foreground">
                      {Math.round(confidence)}% confidence
                    </span>
                  )}
                </div>

                {reasoning && (
                  <div className="flex items-start gap-2 text-sm">
                    <Info className="h-4 w-4 mt-0.5 text-muted-foreground flex-shrink-0" />
                    <p className="text-muted-foreground">{reasoning}</p>
                  </div>
                )}

                {disqualifiers && disqualifiers.length > 0 && (
                  <div className="flex items-start gap-2 text-sm">
                    <AlertTriangle className="h-4 w-4 mt-0.5 text-red-500 flex-shrink-0" />
                    <div className="space-y-1">
                      {disqualifiers.map((d, i) => (
                        <p key={i} className="text-red-500">{d}</p>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Extracted Data */}
            {extractedData && Object.values(extractedData).some(v => v) && (
              <div className="py-3 border-b">
                <h4 className="text-sm font-medium mb-2">Extracted Information</h4>
                <div className="grid grid-cols-2 gap-2 text-sm">
                  {extractedData.salaryExpectation && (
                    <div>
                      <span className="text-muted-foreground">Salary:</span>{' '}
                      {extractedData.salaryExpectation}
                    </div>
                  )}
                  {extractedData.location && (
                    <div>
                      <span className="text-muted-foreground">Location:</span>{' '}
                      {extractedData.location}
                    </div>
                  )}
                  {extractedData.availability && (
                    <div>
                      <span className="text-muted-foreground">Availability:</span>{' '}
                      {extractedData.availability}
                    </div>
                  )}
                  {extractedData.interestLevel && (
                    <div>
                      <span className="text-muted-foreground">Interest:</span>{' '}
                      {extractedData.interestLevel}
                    </div>
                  )}
                  {extractedData.contactPreference && (
                    <div>
                      <span className="text-muted-foreground">Contact:</span>{' '}
                      {extractedData.contactPreference}
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Transcript */}
            <ScrollArea className="flex-1 pr-4">
              <div className="space-y-4 py-2">
                {parsedSegments.map((segment, index) => (
                  <div
                    key={index}
                    className={cn(
                      'flex gap-3',
                      segment.role === 'agent' ? 'flex-row' : 'flex-row-reverse',
                    )}
                  >
                    <div
                      className={cn(
                        'flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center',
                        segment.role === 'agent' ? 'bg-primary/10' : 'bg-muted',
                      )}
                    >
                      {segment.role === 'agent' ? (
                        <Bot className="h-4 w-4 text-primary" />
                      ) : (
                        <User className="h-4 w-4 text-muted-foreground" />
                      )}
                    </div>
                    <div
                      className={cn(
                        'flex-1 rounded-lg p-3 max-w-[80%]',
                        segment.role === 'agent'
                          ? 'bg-primary/5 mr-auto'
                          : 'bg-muted ml-auto text-right',
                      )}
                    >
                      <p className="text-sm">{segment.message}</p>
                      {segment.time_in_call_secs != null && (
                        <p className="text-xs text-muted-foreground mt-1">
                          {formatTime(segment.time_in_call_secs)}
                        </p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>
          </DialogContent>
        </Dialog>
      );
    }

    /**
     * Parse raw transcript string into segments.
     */
    function parseTranscript(transcript: string): TranscriptSegment[] {
      const lines = transcript.split('\n\n').filter(l => l.trim());
      return lines.map(line => {
        const isAgent = line.startsWith('Agent:');
        const message = line.replace(/^(Agent|Candidate):\s*/, '').trim();
        return {
          role: isAgent ? 'agent' : 'user',
          message,
        };
      });
    }

    /**
     * Format seconds to MM:SS.
     */
    function formatTime(seconds: number): string {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    ```

  </action>
  <verify>
    `npm run typecheck` passes.
    CallRecordCard.tsx and TranscriptViewer.tsx export their components.
  </verify>
  <done>
    Call record card shows outcome badge; transcript viewer displays full conversation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate call records into candidate panel</name>
  <files>
    - src/renderer/stores/outreachStore.ts
    - src/renderer/components/outreach/CandidatePanel.tsx
    - src/main/index.ts
    - src/main/preload.ts
  </files>
  <action>
    First, add IPC handlers for call records in src/main/index.ts:

    ```typescript
    // Get call records for a candidate
    ipcMain.handle('get-call-records', (_event, cvId: string) => {
      const db = getDatabase();
      return db.prepare(`
        SELECT
          id, status, duration_seconds as durationSeconds,
          screening_outcome as screeningOutcome,
          screening_confidence as screeningConfidence,
          extracted_data_json as extractedDataJson,
          started_at as startedAt, ended_at as endedAt
        FROM call_records
        WHERE cv_id = ?
        ORDER BY started_at DESC
      `).all(cvId);
    });

    // Get transcript for a call
    ipcMain.handle('get-call-transcript', (_event, callId: string) => {
      const db = getDatabase();
      return db.prepare(`
        SELECT raw_text as rawText, segments_json as segmentsJson, summary
        FROM transcripts
        WHERE call_id = ?
        LIMIT 1
      `).get(callId);
    });
    ```

    Add to preload.ts:

    ```typescript
    getCallRecords: (cvId: string) => ipcRenderer.invoke('get-call-records', cvId),
    getCallTranscript: (callId: string) => ipcRenderer.invoke('get-call-transcript', callId),
    ```

    Update src/renderer/stores/outreachStore.ts to include call records:

    ```typescript
    // Add to OutreachState interface:
    callRecords: CallRecord[];
    isLoadingCallRecords: boolean;
    loadCallRecordsForCandidate: (cvId: string) => Promise<void>;

    // Add CallRecord type:
    interface CallRecord {
      id: string;
      status: 'in_progress' | 'completed' | 'failed' | 'no_answer';
      durationSeconds?: number;
      screeningOutcome?: 'pass' | 'maybe' | 'fail';
      screeningConfidence?: number;
      extractedDataJson?: string;
      startedAt: string;
      endedAt?: string;
    }

    // Add to store implementation:
    callRecords: [],
    isLoadingCallRecords: false,

    loadCallRecordsForCandidate: async (cvId: string) => {
      set({ isLoadingCallRecords: true });
      try {
        const records = await window.electron.getCallRecords(cvId);
        set({ callRecords: records || [] });
      } catch (error) {
        console.error('Failed to load call records:', error);
        set({ callRecords: [] });
      } finally {
        set({ isLoadingCallRecords: false });
      }
    },
    ```

    Update CandidatePanel.tsx:

    1. Import the new components:
       ```typescript
       import { CallRecordCard } from './CallRecordCard';
       import { TranscriptViewer } from './TranscriptViewer';
       ```

    2. Add state for transcript viewer:
       ```typescript
       const [showTranscript, setShowTranscript] = useState(false);
       const [selectedCallId, setSelectedCallId] = useState<string | null>(null);
       const [transcriptData, setTranscriptData] = useState<{
         rawText: string;
         segmentsJson?: string;
         extractedData?: Record<string, string>;
         outcome?: string;
         confidence?: number;
       } | null>(null);
       ```

    3. Add call records from outreach store:
       ```typescript
       const { callRecords, isLoadingCallRecords, loadCallRecordsForCandidate } = useOutreachStore();
       ```

    4. Load call records when candidate changes:
       ```typescript
       useEffect(() => {
         if (selectedCandidateId) {
           loadCallRecordsForCandidate(selectedCandidateId);
         }
       }, [selectedCandidateId, loadCallRecordsForCandidate]);
       ```

    5. Add handler for viewing transcript:
       ```typescript
       const handleViewTranscript = async (callId: string, call: CallRecord) => {
         try {
           const transcript = await window.electron.getCallTranscript(callId);
           if (transcript) {
             setTranscriptData({
               rawText: transcript.rawText,
               segmentsJson: transcript.segmentsJson,
               extractedData: call.extractedDataJson ? JSON.parse(call.extractedDataJson) : undefined,
               outcome: call.screeningOutcome,
               confidence: call.screeningConfidence,
             });
             setSelectedCallId(callId);
             setShowTranscript(true);
           }
         } catch (error) {
           console.error('Failed to load transcript:', error);
           toast.error('Failed to load transcript');
         }
       };
       ```

    6. Add call records section before Message History:
       ```tsx
       {/* Call Records */}
       {callRecords.length > 0 && (
         <div className="px-4 py-3 border-b border-border">
           <h3 className="text-sm font-medium mb-3">Screening Calls</h3>
           <div className="space-y-2">
             {callRecords.map((call) => (
               <CallRecordCard
                 key={call.id}
                 call={call}
                 onViewTranscript={() => handleViewTranscript(call.id, call)}
               />
             ))}
           </div>
         </div>
       )}
       ```

    7. Add TranscriptViewer dialog at the end (before closing fragment):
       ```tsx
       {transcriptData && (
         <TranscriptViewer
           open={showTranscript}
           onOpenChange={setShowTranscript}
           transcript={transcriptData.rawText}
           segments={transcriptData.segmentsJson ? JSON.parse(transcriptData.segmentsJson) : undefined}
           extractedData={transcriptData.extractedData}
           outcome={transcriptData.outcome as 'pass' | 'maybe' | 'fail' | undefined}
           confidence={transcriptData.confidence}
         />
       )}
       ```

  </action>
  <verify>
    `npm run typecheck` passes.
    App starts without errors.
    CandidatePanel shows call records when available.
  </verify>
  <done>
    Call records visible in candidate panel; transcripts viewable in dialog.
  </done>
</task>

</tasks>

<verification>
Run these commands to verify the plan is complete:

```bash
# TypeScript compiles
npm run typecheck

# Tests pass
npm test

# New files exist
ls src/main/transcriptAnalyzer.ts
ls src/renderer/components/outreach/CallRecordCard.tsx
ls src/renderer/components/outreach/TranscriptViewer.tsx

# App starts
npm start
```

Verify in the app:

1. App starts without errors
2. If a candidate has call records, they appear in the side panel
3. Clicking "View Transcript" opens the transcript viewer dialog
4. Outcome badges (pass/maybe/fail) display correctly
5. Extracted data and confidence scores are visible
   </verification>

<success_criteria>

- transcriptAnalyzer.ts uses Claude to analyze transcripts
- voicePoller calls analyzeTranscript on completed calls
- Screening outcome stored in call_records table
- reportScreeningComplete called with pass/fail based on analysis
- CallRecordCard shows outcome badge, duration, confidence
- TranscriptViewer shows full transcript with speaker labels
- CandidatePanel displays call records and transcript viewer
- IPC handlers for call records and transcripts work
  </success_criteria>

<output>
After completion, create `.planning/phases/11-ai-voice-screening/11-03-SUMMARY.md`
</output>
