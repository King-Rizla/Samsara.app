---
phase: 03-visual-editor
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/renderer/stores/queueStore.ts
  - src/renderer/stores/editorStore.ts
  - src/renderer/types/cv.ts
  - src/main/index.ts
  - src/main/preload.ts
  - src/main/database.ts
autonomous: true

must_haves:
  truths:
    - "Queue state persists CV items with status (submitted/completed/failed)"
    - "Selection state tracks multiple selected items"
    - "IPC can update individual CV fields in SQLite"
    - "IPC can delete CVs from database"
    - "IPC can retry processing a failed CV"
  artifacts:
    - path: "src/renderer/stores/queueStore.ts"
      provides: "Queue state management"
      exports: ["useQueueStore"]
    - path: "src/renderer/stores/editorStore.ts"
      provides: "Editor state for active CV"
      exports: ["useEditorStore"]
    - path: "src/renderer/types/cv.ts"
      provides: "TypeScript interfaces for CV data"
      exports: ["QueueItem", "ParsedCV", "ContactInfo"]
    - path: "src/main/preload.ts"
      provides: "Extended API for CV operations"
      contains: "updateCVField"
  key_links:
    - from: "src/renderer/stores/queueStore.ts"
      to: "window.api"
      via: "IPC invoke calls"
      pattern: "window\\.api\\."
    - from: "src/main/index.ts"
      to: "src/main/database.ts"
      via: "Database function calls"
      pattern: "updateCVField|deleteCV|getCV"
---

<objective>
Create Zustand stores for queue and editor state, plus IPC handlers for CV operations.

Purpose: The queue store manages items across all tabs (submitted/completed/failed) with selection state for bulk operations. The editor store tracks which CV is being viewed/edited. IPC handlers enable field updates to persist immediately to SQLite.

Output: Working state management layer that connects React UI (Plan 03) to SQLite database via Electron IPC.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-visual-editor/03-CONTEXT.md
@.planning/phases/03-visual-editor/03-RESEARCH.md

# Existing database and IPC
@src/main/database.ts
@src/main/index.ts
@src/main/preload.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types and Zustand stores</name>
  <files>src/renderer/types/cv.ts, src/renderer/stores/queueStore.ts, src/renderer/stores/editorStore.ts</files>
  <action>
Create shared TypeScript types at `src/renderer/types/cv.ts`:

```typescript
// CV data types matching database schema

export interface ContactInfo {
  name?: string;
  email?: string;
  phone?: string;
  address?: string;
  linkedin?: string;
  github?: string;
  portfolio?: string;
}

export interface WorkEntry {
  company: string;
  position: string;
  start_date?: string;
  end_date?: string;
  description: string;
  highlights: string[];
  confidence: number;
}

export interface EducationEntry {
  institution: string;
  degree: string;
  field_of_study?: string;
  start_date?: string;
  end_date?: string;
  grade?: string;
  confidence: number;
}

export interface SkillGroup {
  category: string;
  skills: string[];
}

export interface ParsedCV {
  contact: ContactInfo;
  work_history: WorkEntry[];
  education: EducationEntry[];
  skills: SkillGroup[];
  certifications: string[];
  languages: string[];
  other_sections: Record<string, string>;
  raw_text: string;
  section_order: string[];
  parse_confidence: number;
  warnings: string[];
  extract_time_ms?: number;
}

export type QueueStatus = 'submitted' | 'completed' | 'failed';
export type ProcessingStage = 'Parsing...' | 'Extracting...' | 'Saving...';

export interface QueueItem {
  id: string;
  fileName: string;
  fileType: string;  // 'pdf' | 'docx' | 'doc'
  filePath: string;
  status: QueueStatus;
  stage?: ProcessingStage;
  error?: string;
  data?: ParsedCV;
  parseConfidence?: number;
  createdAt: string;
}
```

Create queue store at `src/renderer/stores/queueStore.ts`:

```typescript
import { create } from 'zustand';
import type { QueueItem, QueueStatus, ProcessingStage, ParsedCV } from '../types/cv';

interface QueueStore {
  items: QueueItem[];
  selectedIds: Set<string>;
  lastSelectedId: string | null;  // For shift-click range selection

  // Actions
  addItem: (item: Omit<QueueItem, 'id' | 'createdAt'> & { id?: string }) => void;
  updateStatus: (id: string, status: QueueStatus, data?: Partial<QueueItem>) => void;
  updateStage: (id: string, stage: ProcessingStage) => void;
  removeItem: (id: string) => void;
  removeItems: (ids: string[]) => void;

  // Selection
  toggleSelect: (id: string) => void;
  selectRange: (toId: string) => void;
  selectAll: (status?: QueueStatus) => void;
  clearSelection: () => void;

  // Bulk operations
  retryFailed: (ids: string[]) => Promise<void>;
  deleteSelected: () => Promise<void>;

  // Load from database
  loadFromDatabase: () => Promise<void>;
}

export const useQueueStore = create<QueueStore>((set, get) => ({
  items: [],
  selectedIds: new Set(),
  lastSelectedId: null,

  addItem: (itemData) => {
    const item: QueueItem = {
      id: itemData.id || crypto.randomUUID(),
      fileName: itemData.fileName,
      fileType: itemData.fileType,
      filePath: itemData.filePath,
      status: itemData.status,
      stage: itemData.stage,
      error: itemData.error,
      data: itemData.data,
      parseConfidence: itemData.parseConfidence,
      createdAt: new Date().toISOString(),
    };
    set((state) => ({
      items: [item, ...state.items],  // New items at top
    }));
  },

  updateStatus: (id, status, data) => set((state) => ({
    items: state.items.map((item) =>
      item.id === id ? { ...item, status, stage: undefined, ...data } : item
    ),
  })),

  updateStage: (id, stage) => set((state) => ({
    items: state.items.map((item) =>
      item.id === id ? { ...item, stage } : item
    ),
  })),

  removeItem: (id) => set((state) => ({
    items: state.items.filter((item) => item.id !== id),
    selectedIds: new Set([...state.selectedIds].filter((sid) => sid !== id)),
  })),

  removeItems: (ids) => {
    const idSet = new Set(ids);
    set((state) => ({
      items: state.items.filter((item) => !idSet.has(item.id)),
      selectedIds: new Set([...state.selectedIds].filter((sid) => !idSet.has(sid))),
    }));
  },

  toggleSelect: (id) => set((state) => {
    const newSelected = new Set(state.selectedIds);
    if (newSelected.has(id)) {
      newSelected.delete(id);
    } else {
      newSelected.add(id);
    }
    return { selectedIds: newSelected, lastSelectedId: id };
  }),

  selectRange: (toId) => set((state) => {
    if (!state.lastSelectedId) {
      return { selectedIds: new Set([toId]), lastSelectedId: toId };
    }

    const items = state.items;
    const fromIndex = items.findIndex((i) => i.id === state.lastSelectedId);
    const toIndex = items.findIndex((i) => i.id === toId);

    if (fromIndex === -1 || toIndex === -1) {
      return { selectedIds: new Set([toId]), lastSelectedId: toId };
    }

    const start = Math.min(fromIndex, toIndex);
    const end = Math.max(fromIndex, toIndex);
    const rangeIds = items.slice(start, end + 1).map((i) => i.id);

    return {
      selectedIds: new Set([...state.selectedIds, ...rangeIds]),
      lastSelectedId: toId,
    };
  }),

  selectAll: (status) => set((state) => {
    const filteredItems = status
      ? state.items.filter((i) => i.status === status)
      : state.items;
    return {
      selectedIds: new Set(filteredItems.map((i) => i.id)),
    };
  }),

  clearSelection: () => set({ selectedIds: new Set(), lastSelectedId: null }),

  retryFailed: async (ids) => {
    const { items, updateStatus, updateStage } = get();
    for (const id of ids) {
      const item = items.find((i) => i.id === id);
      if (item && item.status === 'failed') {
        updateStatus(id, 'submitted', { error: undefined });
        updateStage(id, 'Parsing...');

        try {
          const result = await window.api.reprocessCV(item.filePath);
          if (result.success && result.data) {
            updateStatus(id, 'completed', {
              data: result.data,
              parseConfidence: result.data.parse_confidence,
            });
          } else {
            updateStatus(id, 'failed', { error: result.error || 'Retry failed' });
          }
        } catch (err) {
          updateStatus(id, 'failed', {
            error: err instanceof Error ? err.message : 'Retry failed',
          });
        }
      }
    }
  },

  deleteSelected: async () => {
    const { selectedIds, removeItems } = get();
    const ids = [...selectedIds];

    // Delete from database
    for (const id of ids) {
      await window.api.deleteCV(id);
    }

    // Remove from store
    removeItems(ids);
  },

  loadFromDatabase: async () => {
    try {
      const result = await window.api.getAllCVs();
      if (result.success && result.data) {
        const items: QueueItem[] = result.data.map((cv: any) => ({
          id: cv.id,
          fileName: cv.file_name,
          fileType: cv.file_name.split('.').pop()?.toLowerCase() || 'unknown',
          filePath: cv.file_path || '',
          status: 'completed' as QueueStatus,
          parseConfidence: cv.parse_confidence,
          createdAt: cv.created_at,
        }));
        set({ items });
      }
    } catch (err) {
      console.error('Failed to load CVs from database:', err);
    }
  },
}));
```

Create editor store at `src/renderer/stores/editorStore.ts`:

```typescript
import { create } from 'zustand';
import type { ParsedCV } from '../types/cv';

interface EditorStore {
  activeCVId: string | null;
  activeCV: ParsedCV | null;
  isDirty: boolean;
  pendingChanges: Map<string, unknown>;  // fieldPath -> value

  // Actions
  setActiveCV: (id: string | null, data?: ParsedCV) => void;
  updateField: (fieldPath: string, value: unknown) => void;
  saveChanges: () => Promise<void>;
  discardChanges: () => void;
  loadCV: (id: string) => Promise<void>;
}

export const useEditorStore = create<EditorStore>((set, get) => ({
  activeCVId: null,
  activeCV: null,
  isDirty: false,
  pendingChanges: new Map(),

  setActiveCV: (id, data) => set({
    activeCVId: id,
    activeCV: data || null,
    isDirty: false,
    pendingChanges: new Map(),
  }),

  updateField: (fieldPath, value) => {
    const { pendingChanges, activeCV } = get();
    const newChanges = new Map(pendingChanges);
    newChanges.set(fieldPath, value);

    // Apply change to local state for immediate UI feedback
    if (activeCV) {
      const updatedCV = applyFieldUpdate(activeCV, fieldPath, value);
      set({
        activeCV: updatedCV,
        pendingChanges: newChanges,
        isDirty: true,
      });
    }
  },

  saveChanges: async () => {
    const { activeCVId, pendingChanges } = get();
    if (!activeCVId || pendingChanges.size === 0) return;

    // Save each pending change to database
    for (const [fieldPath, value] of pendingChanges) {
      await window.api.updateCVField(activeCVId, fieldPath, value);
    }

    set({ pendingChanges: new Map(), isDirty: false });
  },

  discardChanges: () => {
    const { activeCVId } = get();
    if (activeCVId) {
      // Reload from database to discard local changes
      get().loadCV(activeCVId);
    }
  },

  loadCV: async (id) => {
    try {
      const result = await window.api.getCV(id);
      if (result.success && result.data) {
        set({
          activeCVId: id,
          activeCV: result.data,
          isDirty: false,
          pendingChanges: new Map(),
        });
      }
    } catch (err) {
      console.error('Failed to load CV:', err);
    }
  },
}));

// Helper to apply nested field updates
function applyFieldUpdate(cv: ParsedCV, fieldPath: string, value: unknown): ParsedCV {
  const parts = fieldPath.split('.');
  const result = { ...cv };

  let current: any = result;
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    const arrayMatch = part.match(/^(\w+)\[(\d+)\]$/);

    if (arrayMatch) {
      const [, arrayName, indexStr] = arrayMatch;
      const index = parseInt(indexStr, 10);
      current[arrayName] = [...current[arrayName]];
      current[arrayName][index] = { ...current[arrayName][index] };
      current = current[arrayName][index];
    } else {
      current[part] = { ...current[part] };
      current = current[part];
    }
  }

  const lastPart = parts[parts.length - 1];
  current[lastPart] = value;

  return result;
}
```
  </action>
  <verify>
    - `ls src/renderer/types/cv.ts` exists
    - `ls src/renderer/stores/queueStore.ts` exists
    - `ls src/renderer/stores/editorStore.ts` exists
    - TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>TypeScript types and Zustand stores created for queue and editor state management</done>
</task>

<task type="auto">
  <name>Task 2: Add IPC handlers for CV field updates and operations</name>
  <files>src/main/index.ts, src/main/database.ts</files>
  <action>
Add database functions to `src/main/database.ts`:

```typescript
/**
 * Update a specific field in a CV record.
 * fieldPath format: "contact.email", "work_history[0].company", etc.
 */
export function updateCVField(id: string, fieldPath: string, value: unknown): boolean {
  const database = getDatabase();
  const now = new Date().toISOString();

  const cv = database.prepare('SELECT * FROM cvs WHERE id = ?').get(id) as CVRecord | undefined;
  if (!cv) return false;

  // Parse field path to determine which JSON column to update
  const [section, ...rest] = fieldPath.split('.');
  const columnMap: Record<string, string> = {
    contact: 'contact_json',
    work_history: 'work_history_json',
    education: 'education_json',
    skills: 'skills_json',
    certifications: 'certifications_json',
    languages: 'languages_json',
    other_sections: 'other_sections_json',
  };

  const column = columnMap[section];
  if (!column) {
    console.error(`Unknown section: ${section}`);
    return false;
  }

  try {
    // Parse existing JSON
    const currentData = JSON.parse(cv[column as keyof CVRecord] as string || '{}');

    // Apply update using nested path
    applyNestedUpdate(currentData, rest, value);

    // Save back to database
    const stmt = database.prepare(`UPDATE cvs SET ${column} = ?, updated_at = ? WHERE id = ?`);
    stmt.run(JSON.stringify(currentData), now, id);

    console.log(`Updated CV ${id} field ${fieldPath}`);
    return true;
  } catch (error) {
    console.error('Failed to update CV field:', error);
    return false;
  }
}

/**
 * Helper to apply updates to nested object paths including array indices.
 * Handles paths like: "email", "name", "[0].company", "[1].position"
 */
function applyNestedUpdate(obj: any, pathParts: string[], value: unknown): void {
  if (pathParts.length === 0) {
    // Direct section replacement (e.g., entire contact object)
    Object.assign(obj, value);
    return;
  }

  let current = obj;
  for (let i = 0; i < pathParts.length - 1; i++) {
    const part = pathParts[i];
    const arrayMatch = part.match(/^\[(\d+)\]$/);

    if (arrayMatch) {
      const index = parseInt(arrayMatch[1], 10);
      current = current[index];
    } else {
      current = current[part];
    }
  }

  const lastPart = pathParts[pathParts.length - 1];
  const lastArrayMatch = lastPart.match(/^\[(\d+)\]$/);

  if (lastArrayMatch) {
    const index = parseInt(lastArrayMatch[1], 10);
    current[index] = value;
  } else {
    current[lastPart] = value;
  }
}

/**
 * Get full CV data by ID for editor.
 */
export function getCVFull(id: string): ParsedCV | null {
  const database = getDatabase();
  const cv = database.prepare('SELECT * FROM cvs WHERE id = ?').get(id) as CVRecord | undefined;

  if (!cv) return null;

  return {
    contact: JSON.parse(cv.contact_json || '{}'),
    work_history: JSON.parse(cv.work_history_json || '[]'),
    education: JSON.parse(cv.education_json || '[]'),
    skills: JSON.parse(cv.skills_json || '[]'),
    certifications: JSON.parse(cv.certifications_json || '[]'),
    languages: JSON.parse(cv.languages_json || '[]'),
    other_sections: JSON.parse(cv.other_sections_json || '{}'),
    raw_text: cv.raw_text || '',
    section_order: JSON.parse(cv.section_order_json || '[]'),
    parse_confidence: cv.parse_confidence,
    warnings: JSON.parse(cv.warnings_json || '[]'),
    extract_time_ms: cv.parse_time_ms || undefined,
  };
}
```

Add IPC handlers to `src/main/index.ts` (in the app.whenReady section, after existing handlers):

```typescript
import { updateCVField, getCVFull, deleteCV, getCV } from './database';

// Add these IPC handlers after existing ones:

ipcMain.handle('update-cv-field', async (_event, cvId: string, fieldPath: string, value: unknown) => {
  try {
    const success = updateCVField(cvId, fieldPath, value);
    return { success };
  } catch (error) {
    console.error('update-cv-field error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
});

ipcMain.handle('get-cv', async (_event, cvId: string) => {
  try {
    const data = getCVFull(cvId);
    if (!data) {
      return { success: false, error: 'CV not found' };
    }
    return { success: true, data };
  } catch (error) {
    console.error('get-cv error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
});

ipcMain.handle('delete-cv', async (_event, cvId: string) => {
  try {
    const success = deleteCV(cvId);
    return { success };
  } catch (error) {
    console.error('delete-cv error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
});

ipcMain.handle('reprocess-cv', async (_event, filePath: string) => {
  // Re-use existing extract-cv logic
  // This is essentially the same as extract-cv but for retry
  try {
    // Call the existing extraction logic
    // (Implementation depends on existing extractCV handler structure)
    const result = await ipcMain.emit('extract-cv', _event, filePath);
    return result;
  } catch (error) {
    console.error('reprocess-cv error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
});
```

Note: The `reprocess-cv` handler should reuse existing extraction logic. If extraction is in a separate function, call that function directly. Otherwise, refactor existing `extract-cv` handler to share logic.
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - IPC handlers registered (check main process logs on startup)
  </verify>
  <done>Database functions and IPC handlers added for CV field updates, get, delete, and reprocess operations</done>
</task>

<task type="auto">
  <name>Task 3: Extend preload API with new methods</name>
  <files>src/main/preload.ts</files>
  <action>
Extend preload.ts to expose new IPC methods to renderer:

```typescript
// See the Electron documentation for details on how to use preload scripts:
// https://www.electronjs.org/docs/latest/tutorial/process-model#preload-scripts

import { contextBridge, ipcRenderer, webUtils } from 'electron';

// Type definitions for better TypeScript support
interface ExtractResult {
  success: boolean;
  data?: any;
  id?: string;
  totalTime?: number;
  error?: string;
}

interface SelectFileResult {
  success: boolean;
  filePath?: string;
  fileName?: string;
  canceled?: boolean;
}

interface CVSummary {
  id: string;
  file_name: string;
  file_path?: string;
  contact_json: string;
  parse_confidence: number;
  created_at: string;
}

interface GetAllCVsResult {
  success: boolean;
  data?: CVSummary[];
  error?: string;
}

interface GetCVResult {
  success: boolean;
  data?: any;  // ParsedCV
  error?: string;
}

interface UpdateFieldResult {
  success: boolean;
  error?: string;
}

interface DeleteResult {
  success: boolean;
  error?: string;
}

/**
 * Expose protected methods to the renderer process.
 * This maintains security by using contextBridge instead of nodeIntegration.
 */
contextBridge.exposeInMainWorld('api', {
  /**
   * Extract CV from a file path.
   * Returns { success: boolean, data?: ParsedCV, id?: string, error?: string }
   */
  extractCV: (filePath: string): Promise<ExtractResult> =>
    ipcRenderer.invoke('extract-cv', filePath),

  /**
   * Get all stored CVs (summary info).
   * Returns { success: boolean, data?: CVSummary[], error?: string }
   */
  getAllCVs: (): Promise<GetAllCVsResult> =>
    ipcRenderer.invoke('get-all-cvs'),

  /**
   * Open native file dialog to select a CV file.
   * Returns { success: boolean, filePath?: string, fileName?: string, canceled?: boolean }
   */
  selectCVFile: (): Promise<SelectFileResult> =>
    ipcRenderer.invoke('select-cv-file'),

  /**
   * Get full CV data by ID.
   * Returns { success: boolean, data?: ParsedCV, error?: string }
   */
  getCV: (cvId: string): Promise<GetCVResult> =>
    ipcRenderer.invoke('get-cv', cvId),

  /**
   * Update a specific field in a CV.
   * fieldPath format: "contact.email", "work_history[0].company"
   * Returns { success: boolean, error?: string }
   */
  updateCVField: (cvId: string, fieldPath: string, value: unknown): Promise<UpdateFieldResult> =>
    ipcRenderer.invoke('update-cv-field', cvId, fieldPath, value),

  /**
   * Delete a CV by ID.
   * Returns { success: boolean, error?: string }
   */
  deleteCV: (cvId: string): Promise<DeleteResult> =>
    ipcRenderer.invoke('delete-cv', cvId),

  /**
   * Reprocess a CV (retry extraction).
   * Returns { success: boolean, data?: ParsedCV, error?: string }
   */
  reprocessCV: (filePath: string): Promise<ExtractResult> =>
    ipcRenderer.invoke('reprocess-cv', filePath),
});

/**
 * Expose webUtils.getPathForFile directly.
 * This must be separate from the api object because File objects cannot be
 * serialized through contextBridge. We expose it on a separate namespace.
 */
contextBridge.exposeInMainWorld('electronFile', {
  /**
   * Get the file system path for a File object from drag-drop.
   * Only works in Electron, not in a browser.
   */
  getPath: (file: File): string | null => {
    try {
      return webUtils.getPathForFile(file);
    } catch {
      return null;
    }
  },
});
```

Also update the global type declarations in `src/renderer/types/cv.ts` or a separate `src/renderer/types/api.d.ts`:

```typescript
// Add to src/renderer/types/cv.ts or create src/renderer/types/api.d.ts

declare global {
  interface Window {
    api: {
      extractCV: (filePath: string) => Promise<{ success: boolean; data?: ParsedCV; id?: string; totalTime?: number; error?: string }>;
      getAllCVs: () => Promise<{ success: boolean; data?: { id: string; file_name: string; file_path?: string; contact_json: string; parse_confidence: number; created_at: string }[]; error?: string }>;
      selectCVFile: () => Promise<{ success: boolean; filePath?: string; fileName?: string; canceled?: boolean }>;
      getCV: (cvId: string) => Promise<{ success: boolean; data?: ParsedCV; error?: string }>;
      updateCVField: (cvId: string, fieldPath: string, value: unknown) => Promise<{ success: boolean; error?: string }>;
      deleteCV: (cvId: string) => Promise<{ success: boolean; error?: string }>;
      reprocessCV: (filePath: string) => Promise<{ success: boolean; data?: ParsedCV; error?: string }>;
    };
    electronFile: {
      getPath: (file: File) => string | null;
    };
  }
}

export {};
```
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - Preload script exports all 7 API methods (extractCV, getAllCVs, selectCVFile, getCV, updateCVField, deleteCV, reprocessCV)
    - `npm run start` launches without preload errors
  </verify>
  <done>Preload API extended with getCV, updateCVField, deleteCV, and reprocessCV methods, with TypeScript declarations</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Zustand stores**: Import `useQueueStore` and `useEditorStore` in a test component, verify they initialize without errors
2. **IPC flow**: In DevTools console, test:
   - `window.api.getAllCVs()` returns existing CVs
   - `window.api.getCV(id)` returns full CV data for a known ID
   - `window.api.updateCVField(id, 'contact.email', 'test@example.com')` returns `{ success: true }`
3. **Selection state**: Queue store tracks selectedIds correctly
4. **TypeScript**: No type errors in `npx tsc --noEmit`
</verification>

<success_criteria>
- useQueueStore provides items, selectedIds, and all actions (addItem, updateStatus, toggleSelect, selectRange, retryFailed, deleteSelected, loadFromDatabase)
- useEditorStore provides activeCVId, activeCV, updateField, saveChanges, loadCV
- IPC handlers for update-cv-field, get-cv, delete-cv, reprocess-cv all work
- Preload exposes all API methods to renderer
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-visual-editor/03-02-SUMMARY.md`
</output>
