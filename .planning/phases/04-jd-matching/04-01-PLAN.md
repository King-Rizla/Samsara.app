---
phase: 04-jd-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/types/jd.ts
  - python-src/extractors/llm/schemas.py
  - python-src/extractors/llm/prompts.py
  - python-src/main.py
  - src/main/database.ts
  - src/main/preload.ts
  - src/main/index.ts
  - src/renderer/components/jd/JDInput.tsx
  - src/renderer/stores/jdStore.ts
autonomous: true

must_haves:
  truths:
    - "User can paste JD text into a textarea and submit it for parsing"
    - "User can upload a .txt file containing a JD and submit it for parsing"
    - "System extracts structured requirements from JD using LLM"
    - "Extracted JD data persists to SQLite and can be retrieved"
    - "JD appears in a list of stored JDs with title and date"
  artifacts:
    - path: "src/renderer/types/jd.ts"
      provides: "TypeScript interfaces for JD and match results"
      contains: "interface JobDescription"
      min_lines: 40
    - path: "python-src/extractors/llm/schemas.py"
      provides: "LLMJDExtraction Pydantic schema"
      contains: "class LLMJDExtraction"
      min_lines: 170
    - path: "python-src/extractors/llm/prompts.py"
      provides: "JD_EXTRACTION_PROMPT constant"
      contains: "JD_EXTRACTION_PROMPT"
    - path: "python-src/main.py"
      provides: "extract_jd action handler"
      contains: "action == 'extract_jd'"
    - path: "src/main/database.ts"
      provides: "job_descriptions and cv_jd_matches tables"
      contains: "job_descriptions"
      min_lines: 400
    - path: "src/main/preload.ts"
      provides: "extractJD, getAllJDs, deleteJD IPC methods"
      contains: "extractJD"
    - path: "src/renderer/components/jd/JDInput.tsx"
      provides: "JD paste/upload/submit UI component"
      contains: "JDInput"
      min_lines: 80
    - path: "src/renderer/stores/jdStore.ts"
      provides: "Zustand store for JD state management"
      contains: "useJDStore"
      min_lines: 40
  key_links:
    - from: "src/renderer/components/jd/JDInput.tsx"
      to: "window.api.extractJD"
      via: "IPC call on submit"
      pattern: "api\\.extractJD"
    - from: "src/main/preload.ts"
      to: "src/main/index.ts"
      via: "ipcRenderer.invoke"
      pattern: "extract-jd"
    - from: "src/main/index.ts"
      to: "python-src/main.py"
      via: "Python sidecar IPC"
      pattern: "extract_jd"
---

<objective>
Create JD input UI and LLM-based parsing infrastructure for job descriptions.

Purpose: Enable users to paste job descriptions OR upload .txt files and have them parsed into structured requirements (required skills, preferred skills, experience level, education). This forms the foundation for CV-JD matching in subsequent plans.

Output:
- TypeScript types for JD data model
- Python JD extraction schema and prompt
- SQLite tables for JD storage
- IPC handlers for JD operations
- JD input UI component with paste AND file upload functionality
- Zustand store for JD state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-jd-matching/04-RESEARCH.md

# Existing LLM infrastructure to follow
@python-src/extractors/llm/client.py
@python-src/extractors/llm/schemas.py
@python-src/extractors/llm/prompts.py
@python-src/main.py

# Existing patterns to follow
@src/main/database.ts
@src/main/preload.ts
@src/renderer/types/cv.ts
@src/renderer/stores/queueStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JD types, Python schema/prompt, and database tables</name>
  <files>
    src/renderer/types/jd.ts
    python-src/extractors/llm/schemas.py
    python-src/extractors/llm/prompts.py
    src/main/database.ts
  </files>
  <action>
**1. Create `src/renderer/types/jd.ts`:**

Define TypeScript interfaces matching the research patterns:

```typescript
// JD requirement types
export interface SkillRequirement {
  skill: string;
  importance: 'required' | 'preferred' | 'nice-to-have';
  category?: string;
}

export interface JobDescription {
  id: string;
  title: string;
  company?: string;
  raw_text: string;
  created_at: string;
  updated_at: string;

  // LLM-extracted requirements
  required_skills: SkillRequirement[];
  preferred_skills: SkillRequirement[];
  experience_min?: number;
  experience_max?: number;
  education_level?: string;
  certifications: string[];
}

export interface JDSummary {
  id: string;
  title: string;
  company?: string;
  created_at: string;
  required_count: number;
  preferred_count: number;
}

export interface MatchResult {
  cv_id: string;
  jd_id: string;
  match_score: number;  // 0-100
  matched_skills: string[];
  missing_required: string[];
  missing_preferred: string[];
  calculated_at: string;
}
```

Add to the Window interface declaration at bottom:
```typescript
declare global {
  interface Window {
    api: Window['api'] & {
      extractJD: (text: string) => Promise<{ success: boolean; data?: JobDescription; error?: string }>;
      getAllJDs: () => Promise<{ success: boolean; data?: JDSummary[]; error?: string }>;
      getJD: (jdId: string) => Promise<{ success: boolean; data?: JobDescription; error?: string }>;
      deleteJD: (jdId: string) => Promise<{ success: boolean; error?: string }>;
      matchCVsToJD: (jdId: string, cvIds: string[]) => Promise<{ success: boolean; results?: MatchResult[]; error?: string }>;
      getMatchResults: (jdId: string) => Promise<{ success: boolean; data?: MatchResult[]; error?: string }>;
    };
  }
}
```

**2. Add to `python-src/extractors/llm/schemas.py`:**

Add LLM JD extraction schema after existing CV schemas:

```python
class LLMSkillRequirement(BaseModel):
    """A skill requirement from a job description."""
    skill: str = Field(description="The skill name (e.g., 'Python', 'React', 'Project Management')")
    importance: str = Field(description="'required', 'preferred', or 'nice-to-have'")
    category: Optional[str] = Field(default=None, description="Category if grouped in JD (e.g., 'Technical Skills')")


class LLMJDExtraction(BaseModel):
    """Complete JD extraction in a single LLM call."""
    title: str = Field(description="Job title (e.g., 'Senior Software Engineer')")
    company: Optional[str] = Field(default=None, description="Company name if mentioned")

    required_skills: List[LLMSkillRequirement] = Field(
        default_factory=list,
        description="Skills explicitly marked as required, mandatory, or must-have"
    )
    preferred_skills: List[LLMSkillRequirement] = Field(
        default_factory=list,
        description="Skills marked as preferred, desired, nice-to-have, or bonus"
    )

    experience_min_years: Optional[int] = Field(
        default=None,
        description="Minimum years of experience required (e.g., '5+ years' -> 5)"
    )
    experience_max_years: Optional[int] = Field(
        default=None,
        description="Maximum years of experience if range given"
    )

    education_level: Optional[str] = Field(
        default=None,
        description="Required education level (Bachelor's, Master's, PhD)"
    )
    certifications: List[str] = Field(
        default_factory=list,
        description="Required or preferred certifications"
    )
```

**3. Add to `python-src/extractors/llm/prompts.py`:**

Add JD extraction prompt:

```python
JD_EXTRACTION_PROMPT = """You are a job description parser. Extract structured requirements from this job description.

## JOB TITLE
Extract the job title exactly as written (e.g., "Senior Software Engineer", "Product Manager").

## COMPANY
Extract the company name if mentioned in the JD.

## REQUIRED SKILLS
Extract skills explicitly marked as REQUIRED, MANDATORY, MUST-HAVE, or ESSENTIAL.
For each skill:
- skill: The skill name (keep concise, e.g., "Python" not "Python programming language")
- importance: "required"
- category: The category if the JD groups skills (e.g., "Technical Skills", "Soft Skills")

## PREFERRED SKILLS
Extract skills marked as PREFERRED, DESIRED, NICE-TO-HAVE, BONUS, or ADVANTAGEOUS.
Use importance: "preferred" or "nice-to-have" as appropriate.

## EXPERIENCE
Extract years of experience if mentioned:
- "5+ years" -> experience_min_years: 5
- "3-5 years" -> experience_min_years: 3, experience_max_years: 5

## EDUCATION
Extract required education level if mentioned (Bachelor's, Master's, PhD, etc.).

## CERTIFICATIONS
Extract any required or preferred certifications.

Guidelines:
- Only extract what is EXPLICITLY stated in the JD
- Do not infer or guess requirements not mentioned
- Keep skill names concise and recognizable
- If something is not mentioned, leave it empty/null

Return as JSON only. Do not include any explanation."""
```

**4. Extend `src/main/database.ts`:**

Add JD and match tables after existing CV table creation. Add these functions:

```typescript
// Add to initDatabase() - after cvs table creation:
db.exec(`
  CREATE TABLE IF NOT EXISTS job_descriptions (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    company TEXT,
    raw_text TEXT NOT NULL,
    required_skills_json TEXT,
    preferred_skills_json TEXT,
    experience_min INTEGER,
    experience_max INTEGER,
    education_level TEXT,
    certifications_json TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );

  CREATE TABLE IF NOT EXISTS cv_jd_matches (
    cv_id TEXT NOT NULL,
    jd_id TEXT NOT NULL,
    match_score INTEGER NOT NULL,
    matched_skills_json TEXT,
    missing_required_json TEXT,
    missing_preferred_json TEXT,
    calculated_at TEXT NOT NULL,
    PRIMARY KEY (cv_id, jd_id),
    FOREIGN KEY (cv_id) REFERENCES cvs(id) ON DELETE CASCADE,
    FOREIGN KEY (jd_id) REFERENCES job_descriptions(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_matches_jd ON cv_jd_matches(jd_id);
  CREATE INDEX IF NOT EXISTS idx_matches_score ON cv_jd_matches(jd_id, match_score DESC);
`);
```

Add interfaces and CRUD functions for JD:

```typescript
export interface JDRecord {
  id: string;
  title: string;
  company: string | null;
  raw_text: string;
  required_skills_json: string | null;
  preferred_skills_json: string | null;
  experience_min: number | null;
  experience_max: number | null;
  education_level: string | null;
  certifications_json: string | null;
  created_at: string;
  updated_at: string;
}

export interface JDSummary {
  id: string;
  title: string;
  company: string | null;
  created_at: string;
  required_count: number;
  preferred_count: number;
}

export function insertJD(jd: ParsedJD): string { /* ... */ }
export function getJD(id: string): JDRecord | null { /* ... */ }
export function getAllJDs(): JDSummary[] { /* ... */ }
export function deleteJD(id: string): boolean { /* ... */ }
```

Implement similar to existing CV functions, with JSON serialization for arrays.
  </action>
  <verify>
```bash
cd "C:\Users\edwar\Documents\dev\Projects\Samsara"
# Verify TypeScript compiles
npx tsc --noEmit src/renderer/types/jd.ts 2>&1 | head -20

# Verify Python schema
cd python-src
python -c "from extractors.llm.schemas import LLMJDExtraction; print(LLMJDExtraction.model_json_schema())"

# Verify prompt exists
python -c "from extractors.llm.prompts import JD_EXTRACTION_PROMPT; print('JD prompt length:', len(JD_EXTRACTION_PROMPT))"
```
  </verify>
  <done>
- TypeScript JD types created with JobDescription, SkillRequirement, MatchResult interfaces
- Python LLMJDExtraction Pydantic schema added to schemas.py
- JD_EXTRACTION_PROMPT added to prompts.py
- SQLite tables job_descriptions and cv_jd_matches added to database.ts
- JD CRUD functions implemented (insertJD, getJD, getAllJDs, deleteJD)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Python extract_jd handler and IPC layer</name>
  <files>
    python-src/main.py
    src/main/index.ts
    src/main/preload.ts
  </files>
  <action>
**1. Add extract_jd action to `python-src/main.py`:**

Add import at top:
```python
from extractors.llm.schemas import LLMJDExtraction
from extractors.llm.prompts import JD_EXTRACTION_PROMPT
```

Add handler in handle_request() after extract_cv:

```python
if action == 'extract_jd':
    jd_text = request.get('text')
    if not jd_text:
        return {
            'id': request_id,
            'success': False,
            'error': 'Missing required parameter: text'
        }

    try:
        start_time = time.perf_counter()

        # Use LLM for JD extraction (required - no regex fallback for JDs)
        if not llm_client or not llm_client.is_available():
            return {
                'id': request_id,
                'success': False,
                'error': 'LLM not available. Please ensure Ollama is running with qwen2.5:7b model.'
            }

        llm_result = llm_client.extract(
            text=jd_text,
            prompt=JD_EXTRACTION_PROMPT,
            schema=LLMJDExtraction,
            temperature=0.0
        )

        if not llm_result:
            return {
                'id': request_id,
                'success': False,
                'error': 'Failed to extract JD requirements. LLM returned no result.'
            }

        elapsed_ms = int((time.perf_counter() - start_time) * 1000)

        # Convert to response format
        return {
            'id': request_id,
            'success': True,
            'data': {
                'title': llm_result.title,
                'company': llm_result.company,
                'required_skills': [
                    {'skill': s.skill, 'importance': s.importance, 'category': s.category}
                    for s in llm_result.required_skills
                ],
                'preferred_skills': [
                    {'skill': s.skill, 'importance': s.importance, 'category': s.category}
                    for s in llm_result.preferred_skills
                ],
                'experience_min': llm_result.experience_min_years,
                'experience_max': llm_result.experience_max_years,
                'education_level': llm_result.education_level,
                'certifications': llm_result.certifications,
                'extract_time_ms': elapsed_ms
            }
        }

    except Exception as e:
        return {
            'id': request_id,
            'success': False,
            'error': f'Error extracting JD: {str(e)}'
        }
```

**2. Add IPC handlers to `src/main/index.ts`:**

Add in the section where other IPC handlers are registered:

```typescript
import { insertJD, getJD, getAllJDs, deleteJD } from './database';

ipcMain.handle('extract-jd', async (_event, text: string) => {
  try {
    // Send to Python sidecar
    const result = await pythonManager.sendRequest({
      action: 'extract_jd',
      text,
    });

    if (!result.success) {
      return { success: false, error: result.error };
    }

    // Store in database
    const id = insertJD({
      ...result.data,
      raw_text: text,
    });

    // Return full JD with ID
    const jd = getJD(id);
    return { success: true, data: jd };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to extract JD'
    };
  }
});

ipcMain.handle('get-all-jds', async () => {
  try {
    const jds = getAllJDs();
    return { success: true, data: jds };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get JDs'
    };
  }
});

ipcMain.handle('get-jd', async (_event, jdId: string) => {
  try {
    const jd = getJD(jdId);
    if (!jd) {
      return { success: false, error: 'JD not found' };
    }
    return { success: true, data: jd };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get JD'
    };
  }
});

ipcMain.handle('delete-jd', async (_event, jdId: string) => {
  try {
    const deleted = deleteJD(jdId);
    return { success: deleted, error: deleted ? undefined : 'JD not found' };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete JD'
    };
  }
});
```

**3. Add to `src/main/preload.ts`:**

Add JD IPC methods to the contextBridge.exposeInMainWorld('api', {...}):

```typescript
// JD operations
extractJD: (text: string): Promise<{ success: boolean; data?: unknown; error?: string }> =>
  ipcRenderer.invoke('extract-jd', text),

getAllJDs: (): Promise<{ success: boolean; data?: unknown[]; error?: string }> =>
  ipcRenderer.invoke('get-all-jds'),

getJD: (jdId: string): Promise<{ success: boolean; data?: unknown; error?: string }> =>
  ipcRenderer.invoke('get-jd', jdId),

deleteJD: (jdId: string): Promise<{ success: boolean; error?: string }> =>
  ipcRenderer.invoke('delete-jd', jdId),
```
  </action>
  <verify>
```bash
cd "C:\Users\edwar\Documents\dev\Projects\Samsara"
# Verify TypeScript compiles
npm run build 2>&1 | tail -10

# Test Python JD extraction (if Ollama available)
cd python-src
python -c "
from extractors.llm import OllamaClient
from extractors.llm.schemas import LLMJDExtraction
from extractors.llm.prompts import JD_EXTRACTION_PROMPT

client = OllamaClient(timeout=120.0)
print('LLM available:', client.is_available())
"
```
  </verify>
  <done>
- Python extract_jd action handler added to main.py
- IPC handlers for extract-jd, get-all-jds, get-jd, delete-jd added to index.ts
- Preload exposures added for all JD operations
- Full pipeline: renderer -> preload -> main -> Python -> database
  </done>
</task>

<task type="auto">
  <name>Task 3: Create JD input UI with paste AND file upload, and Zustand store</name>
  <files>
    src/renderer/stores/jdStore.ts
    src/renderer/components/jd/JDInput.tsx
    src/renderer/components/jd/index.ts
  </files>
  <action>
**1. Create `src/renderer/stores/jdStore.ts`:**

```typescript
import { create } from 'zustand';
import type { JobDescription, JDSummary, MatchResult } from '../types/jd';

interface JDStore {
  // State
  jds: JDSummary[];
  activeJDId: string | null;
  activeJD: JobDescription | null;
  matchResults: MatchResult[];
  isExtracting: boolean;

  // Actions
  loadJDs: () => Promise<void>;
  extractJD: (text: string) => Promise<{ success: boolean; error?: string }>;
  selectJD: (id: string | null) => Promise<void>;
  deleteJD: (id: string) => Promise<void>;
  setMatchResults: (results: MatchResult[]) => void;
  clearActiveJD: () => void;
}

export const useJDStore = create<JDStore>((set, get) => ({
  jds: [],
  activeJDId: null,
  activeJD: null,
  matchResults: [],
  isExtracting: false,

  loadJDs: async () => {
    try {
      const result = await window.api.getAllJDs();
      if (result.success && result.data) {
        set({ jds: result.data as JDSummary[] });
      }
    } catch (err) {
      console.error('Failed to load JDs:', err);
    }
  },

  extractJD: async (text) => {
    set({ isExtracting: true });
    try {
      const result = await window.api.extractJD(text);
      if (result.success && result.data) {
        // Reload JD list to include new JD
        await get().loadJDs();
        return { success: true };
      }
      return { success: false, error: result.error || 'Extraction failed' };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : 'Extraction failed'
      };
    } finally {
      set({ isExtracting: false });
    }
  },

  selectJD: async (id) => {
    if (!id) {
      set({ activeJDId: null, activeJD: null, matchResults: [] });
      return;
    }

    try {
      const result = await window.api.getJD(id);
      if (result.success && result.data) {
        set({
          activeJDId: id,
          activeJD: result.data as JobDescription,
          matchResults: []  // Clear matches when switching JD
        });
      }
    } catch (err) {
      console.error('Failed to load JD:', err);
    }
  },

  deleteJD: async (id) => {
    try {
      await window.api.deleteJD(id);
      const { activeJDId } = get();
      if (activeJDId === id) {
        set({ activeJDId: null, activeJD: null, matchResults: [] });
      }
      await get().loadJDs();
    } catch (err) {
      console.error('Failed to delete JD:', err);
    }
  },

  setMatchResults: (results) => set({ matchResults: results }),

  clearActiveJD: () => set({
    activeJDId: null,
    activeJD: null,
    matchResults: []
  }),
}));

// Expose store for E2E testing
if (typeof window !== 'undefined') {
  (window as unknown as { __jdStore: typeof useJDStore }).__jdStore = useJDStore;
}
```

**2. Create `src/renderer/components/jd/JDInput.tsx`:**

Implement BOTH paste and file upload functionality to satisfy M-01a requirement:

```tsx
import { useState, useRef } from 'react';
import { Button } from '../ui/button';
import { useJDStore } from '../../stores/jdStore';

export function JDInput() {
  const [text, setText] = useState('');
  const [error, setError] = useState<string | null>(null);
  const { extractJD, isExtracting } = useJDStore();
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleSubmit = async () => {
    if (!text.trim()) {
      setError('Please paste a job description or upload a file');
      return;
    }

    setError(null);
    const result = await extractJD(text);

    if (result.success) {
      setText('');  // Clear on success
    } else {
      setError(result.error || 'Failed to extract JD');
    }
  };

  // File upload handler - reads .txt file content into textarea
  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file type
    if (!file.name.endsWith('.txt') && file.type !== 'text/plain') {
      setError('Please upload a .txt file');
      return;
    }

    // Validate file size (max 1MB)
    if (file.size > 1024 * 1024) {
      setError('File too large. Maximum size is 1MB.');
      return;
    }

    try {
      const content = await file.text();
      setText(content);
      setError(null);
    } catch (err) {
      setError('Failed to read file');
    }

    // Reset file input so the same file can be selected again
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleBrowseClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="p-4 space-y-4">
      <div>
        <label htmlFor="jd-input" className="block text-sm font-medium text-foreground mb-2">
          Paste Job Description or Upload File
        </label>
        <textarea
          id="jd-input"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Paste the full job description here, or use the 'Upload File' button below..."
          className="w-full h-64 p-3 bg-muted border border-border rounded-md
                     text-foreground placeholder:text-muted-foreground
                     focus:outline-none focus:ring-2 focus:ring-primary
                     font-mono text-sm resize-none"
          disabled={isExtracting}
        />
      </div>

      {/* File upload section */}
      <div className="flex items-center gap-2">
        <input
          ref={fileInputRef}
          type="file"
          accept=".txt,text/plain"
          onChange={handleFileUpload}
          className="hidden"
          disabled={isExtracting}
        />
        <Button
          variant="outline"
          size="sm"
          onClick={handleBrowseClick}
          disabled={isExtracting}
        >
          Upload .txt File
        </Button>
        <span className="text-xs text-muted-foreground">
          or paste JD text directly above
        </span>
      </div>

      {error && (
        <p className="text-sm text-destructive">{error}</p>
      )}

      <div className="flex justify-end gap-2">
        <Button
          variant="outline"
          onClick={() => setText('')}
          disabled={isExtracting || !text}
        >
          Clear
        </Button>
        <Button
          onClick={handleSubmit}
          disabled={isExtracting || !text.trim()}
        >
          {isExtracting ? 'Extracting...' : 'Extract Requirements'}
        </Button>
      </div>

      {isExtracting && (
        <p className="text-sm text-muted-foreground">
          Analyzing job description with AI... This may take 30-60 seconds.
        </p>
      )}
    </div>
  );
}
```

**3. Create `src/renderer/components/jd/index.ts`:**

```typescript
export { JDInput } from './JDInput';
```
  </action>
  <verify>
```bash
cd "C:\Users\edwar\Documents\dev\Projects\Samsara"
# Verify TypeScript compiles
npx tsc --noEmit 2>&1 | tail -20

# Verify component exists with upload functionality
test -f src/renderer/components/jd/JDInput.tsx && echo "JDInput.tsx exists"
grep -n "handleFileUpload\|type=\"file\"" src/renderer/components/jd/JDInput.tsx | head -5
test -f src/renderer/stores/jdStore.ts && echo "jdStore.ts exists"
```
  </verify>
  <done>
- Zustand jdStore created with JD list, active JD, and match results state
- JDInput component created with BOTH paste textarea AND file upload button (satisfies M-01a)
- File upload validates .txt files and 1MB size limit
- Loading state shown during LLM extraction
- Error handling for failed extractions and file reads
- Store exposed for E2E testing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type safety**: Run `npm run build` - should compile without errors
2. **Database**: New tables created on app start
3. **Python**: `extract_jd` action responds correctly
4. **IPC**: All JD handlers registered and working

Manual test (if Ollama running):
1. Start app: `npm start`
2. JDInput component should be accessible (may need to add to App.tsx in next plan)
3. Paste a sample JD OR upload a .txt file
4. Click "Extract Requirements"
5. Check console for extraction success
6. Verify JD appears in database
</verification>

<success_criteria>
- [ ] `src/renderer/types/jd.ts` with JobDescription, SkillRequirement, MatchResult interfaces
- [ ] Python LLMJDExtraction schema and JD_EXTRACTION_PROMPT added
- [ ] SQLite job_descriptions and cv_jd_matches tables created
- [ ] Python extract_jd action handler working
- [ ] IPC handlers for all JD operations (extract, get, getAll, delete)
- [ ] Preload exposures for JD API
- [ ] jdStore.ts Zustand store for JD state
- [ ] JDInput.tsx component with BOTH paste AND file upload functionality (M-01a)
- [ ] Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-jd-matching/04-01-SUMMARY.md`
</output>
