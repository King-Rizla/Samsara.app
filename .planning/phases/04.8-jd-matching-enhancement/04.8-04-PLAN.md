---
phase: 04.8-jd-matching-enhancement
plan: 04
type: execute
wave: 3
depends_on: ["04.8-01", "04.8-02", "04.8-03"]
files_modified:
  - src/renderer/components/jd/SearchTools.tsx
  - src/renderer/components/jd/JDDetail.tsx
  - src/renderer/lib/matchingEngine.ts
autonomous: true

must_haves:
  truths:
    - "JD detail view shows collapsible Search Tools section"
    - "Boolean strings are copyable with user's configured syntax"
    - "Boolean strings are editable inline"
    - "Matching algorithm uses expanded skill variants for improved recall"
    - "Existing JDs without matching_metadata still display correctly"
  artifacts:
    - path: "src/renderer/components/jd/SearchTools.tsx"
      provides: "Collapsible search tools UI with copy/edit"
      contains: "SearchTools"
    - path: "src/renderer/components/jd/JDDetail.tsx"
      provides: "Integrated SearchTools component"
      contains: "SearchTools"
    - path: "src/renderer/lib/matchingEngine.ts"
      provides: "Enhanced matching with expanded variants"
      contains: "expanded_skills"
  key_links:
    - from: "JDDetail.tsx"
      to: "SearchTools.tsx"
      via: "component import"
      pattern: "import.*SearchTools"
    - from: "matchingEngine.ts"
      to: "ExpandedSkill"
      via: "variant matching"
      pattern: "expanded_skills|variants"
---

<objective>
Add Search Tools UI component to JD detail view and enhance matching algorithm to use expanded skill variants.

Purpose: Provide recruiters with copyable/editable boolean search strings and improve CV-to-JD matching recall by using LLM-generated skill variants instead of static mappings.

Output: SearchTools component with collapsible UI, updated JDDetail with search tools integration, enhanced matchingEngine using expanded variants.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-RESEARCH.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-01-SUMMARY.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-02-SUMMARY.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-03-SUMMARY.md

# Key existing code
@src/renderer/components/jd/JDDetail.tsx
@src/renderer/lib/matchingEngine.ts
@src/renderer/lib/skillVariants.ts
@src/renderer/types/jd.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchTools component</name>
  <files>src/renderer/components/jd/SearchTools.tsx</files>
  <action>
Create a new component for displaying and editing boolean search strings:

```tsx
// src/renderer/components/jd/SearchTools.tsx
import { useState } from 'react';
import { ChevronDown, ChevronRight, Copy, Check, Edit2, X } from 'lucide-react';
import { Button } from '../ui/button';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '../ui/collapsible';
import type { BooleanStrings, SearchHints, BooleanSyntaxConfig } from '../../types/jd';
import { transformBooleanSyntax } from '../../lib/booleanSyntax';
import { useUsageStore } from '../../stores/usageStore';

interface SearchToolsProps {
  booleanStrings: BooleanStrings;
  searchHints: SearchHints;
}

const TIER_LABELS: Record<keyof BooleanStrings, { label: string; description: string }> = {
  wide: { label: 'Wide Search', description: 'Broad coverage, many candidates' },
  midline: { label: 'Midline Search', description: 'Balanced precision and recall' },
  narrow: { label: 'Narrow Search', description: 'Strict match, fewer candidates' },
};

export function SearchTools({ booleanStrings, searchHints }: SearchToolsProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [copiedKey, setCopiedKey] = useState<string | null>(null);
  const [editingKey, setEditingKey] = useState<keyof BooleanStrings | null>(null);
  const [editedStrings, setEditedStrings] = useState<BooleanStrings>(booleanStrings);

  const { booleanSyntax } = useUsageStore();

  const handleCopy = (key: keyof BooleanStrings) => {
    const transformed = transformBooleanSyntax(editedStrings[key], booleanSyntax);
    navigator.clipboard.writeText(transformed);
    setCopiedKey(key);
    setTimeout(() => setCopiedKey(null), 2000);
  };

  const handleEdit = (key: keyof BooleanStrings) => {
    if (editingKey === key) {
      setEditingKey(null);
    } else {
      setEditingKey(key);
    }
  };

  const handleEditChange = (key: keyof BooleanStrings, value: string) => {
    setEditedStrings({ ...editedStrings, [key]: value });
  };

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen}>
      <CollapsibleTrigger asChild>
        <Button
          variant="ghost"
          className="w-full justify-between px-0 hover:bg-transparent"
        >
          <span className="text-sm font-medium text-foreground flex items-center gap-2">
            {isOpen ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
            Search Tools
          </span>
        </Button>
      </CollapsibleTrigger>
      <CollapsibleContent className="space-y-4 pt-2">
        {/* Boolean Strings */}
        {(['wide', 'midline', 'narrow'] as const).map((tier) => (
          <div key={tier} className="space-y-1.5">
            <div className="flex items-center justify-between">
              <div>
                <span className="text-sm font-medium text-foreground">
                  {TIER_LABELS[tier].label}
                </span>
                <span className="ml-2 text-xs text-muted-foreground">
                  {TIER_LABELS[tier].description}
                </span>
              </div>
              <div className="flex gap-1">
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-6 w-6 p-0"
                  onClick={() => handleEdit(tier)}
                  title={editingKey === tier ? 'Done editing' : 'Edit'}
                >
                  {editingKey === tier ? (
                    <X className="h-3 w-3" />
                  ) : (
                    <Edit2 className="h-3 w-3" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-6 w-6 p-0"
                  onClick={() => handleCopy(tier)}
                  title="Copy to clipboard"
                >
                  {copiedKey === tier ? (
                    <Check className="h-3 w-3 text-green-500" />
                  ) : (
                    <Copy className="h-3 w-3" />
                  )}
                </Button>
              </div>
            </div>
            {editingKey === tier ? (
              <textarea
                className="w-full p-2 text-xs bg-muted rounded border border-border font-mono
                           text-foreground resize-none focus:outline-none focus:ring-1 focus:ring-primary"
                value={editedStrings[tier]}
                onChange={(e) => handleEditChange(tier, e.target.value)}
                rows={3}
              />
            ) : (
              <div className="p-2 text-xs bg-muted rounded font-mono text-muted-foreground break-all">
                {transformBooleanSyntax(editedStrings[tier], booleanSyntax)}
              </div>
            )}
          </div>
        ))}

        {/* Search Hints */}
        {searchHints.suggested_titles.length > 0 && (
          <div className="pt-2 border-t border-border">
            <span className="text-sm font-medium text-foreground">Suggested Titles</span>
            <div className="flex flex-wrap gap-1.5 mt-1.5">
              {searchHints.suggested_titles.map((title) => (
                <span
                  key={title}
                  className="px-2 py-0.5 text-xs bg-muted text-muted-foreground rounded"
                >
                  {title}
                </span>
              ))}
            </div>
          </div>
        )}

        {searchHints.negative_keywords.length > 0 && (
          <div>
            <span className="text-sm font-medium text-foreground">Exclude Terms</span>
            <div className="flex flex-wrap gap-1.5 mt-1.5">
              {searchHints.negative_keywords.map((keyword) => (
                <span
                  key={keyword}
                  className="px-2 py-0.5 text-xs bg-red-500/10 text-red-400 rounded"
                >
                  {keyword}
                </span>
              ))}
            </div>
          </div>
        )}

        {searchHints.industries && searchHints.industries.length > 0 && (
          <div>
            <span className="text-sm font-medium text-foreground">Industries</span>
            <div className="flex flex-wrap gap-1.5 mt-1.5">
              {searchHints.industries.map((industry) => (
                <span
                  key={industry}
                  className="px-2 py-0.5 text-xs bg-blue-500/10 text-blue-400 rounded"
                >
                  {industry}
                </span>
              ))}
            </div>
          </div>
        )}
      </CollapsibleContent>
    </Collapsible>
  );
}
```
  </action>
  <verify>
1. File exists: `ls src/renderer/components/jd/SearchTools.tsx`
2. `npm run lint` passes
  </verify>
  <done>SearchTools component created with collapsible UI, copy, and edit functionality</done>
</task>

<task type="auto">
  <name>Task 2: Integrate SearchTools into JDDetail</name>
  <files>src/renderer/components/jd/JDDetail.tsx</files>
  <action>
Update JDDetail to show SearchTools when matching_metadata is available:

1. Add import at the top:
```tsx
import { SearchTools } from './SearchTools';
```

2. Add SearchTools section after the Certifications section and before the Raw Text section:

```tsx
{/* Search Tools (only if matching_metadata exists) */}
{activeJD.matching_metadata && (
  <div className="border-t border-border pt-4">
    <SearchTools
      booleanStrings={activeJD.matching_metadata.boolean_strings}
      searchHints={activeJD.matching_metadata.search_hints}
    />
  </div>
)}
```

The full updated section order should be:
1. Header (title, company)
2. Experience & Education badges
3. Required Skills
4. Preferred Skills
5. Certifications
6. **Search Tools (NEW - only if matching_metadata exists)**
7. Raw Text

This ensures the SearchTools section appears after the skill lists (which it references) and before the raw text (which is less actionable).
  </action>
  <verify>
1. `npm run lint` passes
2. Open app, create a new JD - Search Tools section should appear (if extraction includes matching_metadata)
3. Open an existing JD without matching_metadata - should display without Search Tools (no errors)
4. Search Tools collapses/expands correctly
5. Copy button copies the boolean string with user's configured syntax
  </verify>
  <done>JDDetail shows SearchTools component when matching_metadata is present</done>
</task>

<task type="auto">
  <name>Task 3: Enhance matching algorithm to use expanded variants</name>
  <files>src/renderer/lib/matchingEngine.ts</files>
  <action>
Update matchingEngine to use LLM-generated expanded skill variants as the PRIMARY source for matching, with the existing skillVariants.ts as fallback.

1. Update imports and types:
```tsx
import type { JobDescription, MatchResult, SkillRequirement, ExpandedSkill } from '../types/jd';
import type { ParsedCV, SkillGroup } from '../types/cv';
import { normalizeSkill, skillsMatch } from './skillVariants';
```

2. Update findMatchingSkill to accept expanded_skills:
```tsx
/**
 * Check if a JD skill requirement is matched by any CV skill.
 * Uses expanded skill variants from matching_metadata if available (PRIMARY SOURCE),
 * falls back to static skillVariants mapping otherwise.
 */
function findMatchingSkill(
  requirement: SkillRequirement,
  cvSkills: string[],
  expandedSkills?: ExpandedSkill[]
): string | null {
  const normalizedReq = normalizeSkill(requirement.skill);

  // PRIMARY: Use LLM-generated expanded variants if available
  if (expandedSkills) {
    const expanded = expandedSkills.find(
      (e) => normalizeSkill(e.skill) === normalizedReq
    );

    if (expanded) {
      // Build list of all terms that match this skill:
      // original skill + variants + related_tools
      const allVariants = [
        expanded.skill,
        ...expanded.variants,
        ...expanded.related_tools,
      ].map(normalizeSkill);

      for (const cvSkill of cvSkills) {
        const normalizedCV = normalizeSkill(cvSkill);
        // Check if CV skill matches any variant
        if (allVariants.some((v) => v === normalizedCV || skillsMatch(v, normalizedCV))) {
          return cvSkill;
        }
      }
    }
  }

  // FALLBACK: Use static skillVariants mapping
  for (const cvSkill of cvSkills) {
    if (skillsMatch(normalizedReq, cvSkill)) {
      return cvSkill;
    }
  }

  return null;
}
```

3. Update calculateMatchScore to pass expanded_skills:
```tsx
export function calculateMatchScore(
  cv: ParsedCV,
  jd: JobDescription
): MatchResult {
  const cvSkills = flattenCVSkills(cv.skills);

  // Extract expanded_skills from matching_metadata if available
  const expandedSkills = jd.matching_metadata?.expanded_skills;

  const matchedRequired: string[] = [];
  const missingRequired: string[] = [];
  const matchedPreferred: string[] = [];
  const missingPreferred: string[] = [];

  // Check required skills (passing expandedSkills)
  for (const req of jd.required_skills) {
    const match = findMatchingSkill(req, cvSkills, expandedSkills);
    if (match) {
      matchedRequired.push(req.skill);
    } else {
      missingRequired.push(req.skill);
    }
  }

  // Check preferred skills (passing expandedSkills)
  for (const pref of jd.preferred_skills) {
    const match = findMatchingSkill(pref, cvSkills, expandedSkills);
    if (match) {
      matchedPreferred.push(pref.skill);
    } else {
      missingPreferred.push(pref.skill);
    }
  }

  // ... rest of the function unchanged (scoring logic) ...
```

The key change: `findMatchingSkill` now checks LLM-generated variants first, giving better recall when matching "Python" to a CV that lists "Django" (because LLM included "Django" in Python's related_tools).
  </action>
  <verify>
1. `npm run lint` passes
2. Create a JD requiring "Python"
3. Create a CV with only "Django" listed (not "Python")
4. Match them - the CV should now match on Python (via Django related_tool)
5. Match results still display correctly in MatchResults component
  </verify>
  <done>Matching algorithm uses expanded skill variants as primary source, static mapping as fallback</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes
2. New JDs show Search Tools section when viewed
3. Existing JDs without matching_metadata display correctly (no Search Tools, no errors)
4. Boolean strings copy correctly with configured syntax
5. Boolean strings are editable inline
6. Matching algorithm finds matches via expanded variants
7. Match scores improve for related skills (e.g., Django matches Python requirement)
</verification>

<success_criteria>
- SearchTools component renders collapsible section with three boolean tiers
- Copy button applies user's configured boolean syntax before copying
- Edit button enables inline editing of boolean strings
- JDDetail integrates SearchTools when matching_metadata present
- Existing JDs without matching_metadata render without errors
- matchingEngine uses expanded_skills as primary matching source
- CV with related tool (e.g., Django) matches JD requiring skill (e.g., Python)
</success_criteria>

<output>
After completion, create `.planning/phases/04.8-jd-matching-enhancement/04.8-04-SUMMARY.md`
</output>
