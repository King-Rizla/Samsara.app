---
phase: 04.6-queue-infrastructure-persistence
plan: 02
type: execute
wave: 2
depends_on: ["04.6-01"]
files_modified:
  - src/main/queueManager.ts
  - src/main/index.ts
autonomous: true

must_haves:
  truths:
    - "Queue manager processes one CV at a time"
    - "Timeout starts when Python begins processing, not when submitted"
    - "Main process pushes status updates to renderer via webContents.send"
  artifacts:
    - path: "src/main/queueManager.ts"
      provides: "QueueManager class with enqueue, processNext, status notifications"
      exports: ["QueueManager", "createQueueManager"]
  key_links:
    - from: "src/main/queueManager.ts"
      to: "src/main/pythonManager.ts"
      via: "extractCV call"
      pattern: "extractCV\\(.*\\)"
    - from: "src/main/queueManager.ts"
      to: "src/main/database.ts"
      via: "queue database functions"
      pattern: "(insertQueuedCV|updateCVStatus|completeCVProcessing)"
---

<objective>
Create QueueManager in main process to serialize CV processing requests.

Purpose: The core of the queue infrastructure - serializes requests to Python sidecar (one at a time), manages per-item timeouts (starting when processing begins, not on submission), and pushes status updates to renderer.

Output: QueueManager class that coordinates database persistence, Python IPC, and renderer notifications.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.6-queue-infrastructure-persistence/04.6-RESEARCH.md
@.planning/phases/04.6-queue-infrastructure-persistence/04.6-01-SUMMARY.md
@src/main/pythonManager.ts
@src/main/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueueManager class</name>
  <files>src/main/queueManager.ts</files>
  <action>
Create a new file `src/main/queueManager.ts` with the QueueManager class:

```typescript
/**
 * Queue Manager
 *
 * Manages CV processing queue in the main process.
 * - Persists CVs to database immediately on enqueue (status: 'queued')
 * - Processes one CV at a time (Python sidecar constraint)
 * - Starts timeout when processing begins, not on submission
 * - Pushes status updates to renderer via webContents.send
 */
import { BrowserWindow } from 'electron';
import {
  insertQueuedCV, updateCVStatus, completeCVProcessing,
  getNextQueuedCV, resetProcessingCVs, ParsedCV,
} from './database';
import { extractCV } from './pythonManager';

export interface QueueStatusUpdate {
  id: string;
  status: 'queued' | 'processing' | 'completed' | 'failed';
  data?: ParsedCV;
  error?: string;
  parseConfidence?: number;
}

export interface EnqueueInput {
  fileName: string;
  filePath: string;
  projectId?: string;
}

export class QueueManager {
  private processing = false;
  private mainWindow: BrowserWindow | null = null;
  private readonly timeoutMs = 120000; // 120 seconds per CV

  constructor() {
    // Reset any 'processing' CVs from previous session
    const resetCount = resetProcessingCVs();
    if (resetCount > 0) {
      console.log(`QueueManager: Reset ${resetCount} stuck CVs to queued`);
    }
  }

  /**
   * Set the main window for push notifications.
   * Must be called after window is created.
   */
  setMainWindow(window: BrowserWindow): void {
    this.mainWindow = window;

    // Handle window close - clear reference
    window.on('closed', () => {
      this.mainWindow = null;
    });
  }

  /**
   * Enqueue a CV for processing.
   * Immediately persists to database with status='queued'.
   * Returns the generated CV ID.
   */
  enqueue(input: EnqueueInput): string {
    // 1. Persist to database immediately
    const id = insertQueuedCV({
      filePath: input.filePath,
      fileName: input.fileName,
      projectId: input.projectId,
    });

    console.log(`QueueManager: Enqueued CV ${id} (${input.fileName})`);

    // 2. Notify UI
    this.notifyStatus({ id, status: 'queued' });

    // 3. Trigger processing (async, don't await)
    this.processNext();

    return id;
  }

  /**
   * Process the next queued CV.
   * Called automatically after enqueue and after each completion.
   */
  private async processNext(): Promise<void> {
    // Only one at a time
    if (this.processing) {
      return;
    }

    // Get next pending CV
    const next = getNextQueuedCV();
    if (!next) {
      return;
    }

    this.processing = true;
    const { id, file_path } = next;

    console.log(`QueueManager: Processing CV ${id} (${file_path})`);

    // Mark as processing in DB and notify UI
    // Timeout starts NOW (when processing actually begins)
    const startedAt = new Date().toISOString();
    updateCVStatus(id, 'processing', { startedAt });
    this.notifyStatus({ id, status: 'processing' });

    // Set up timeout
    const timeoutId = setTimeout(() => {
      this.handleTimeout(id);
    }, this.timeoutMs);

    try {
      // Extract CV using Python sidecar
      const result = await extractCV(file_path) as ParsedCV;

      // Clear timeout - processing succeeded
      clearTimeout(timeoutId);

      // Save extracted data and mark completed
      completeCVProcessing(id, result);

      console.log(`QueueManager: Completed CV ${id}`);

      // Notify UI with result
      this.notifyStatus({
        id,
        status: 'completed',
        data: result,
        parseConfidence: result.parse_confidence,
      });
    } catch (error) {
      // Clear timeout
      clearTimeout(timeoutId);

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`QueueManager: Failed CV ${id}:`, errorMessage);

      // Mark as failed in DB
      updateCVStatus(id, 'failed', { error: errorMessage });

      // Notify UI
      this.notifyStatus({
        id,
        status: 'failed',
        error: errorMessage,
      });
    }

    this.processing = false;

    // Process next in queue
    this.processNext();
  }

  /**
   * Handle timeout for a CV.
   * Called when processing takes longer than timeoutMs.
   */
  private handleTimeout(id: string): void {
    console.warn(`QueueManager: Timeout for CV ${id}`);

    const errorMessage = 'Extraction timed out. The LLM may be overloaded - try again.';

    // Mark as failed in DB
    updateCVStatus(id, 'failed', { error: errorMessage });

    // Notify UI
    this.notifyStatus({
      id,
      status: 'failed',
      error: errorMessage,
    });

    // Note: processing flag will be cleared by the extractCV promise
    // eventually rejecting or the Python process crashing
  }

  /**
   * Push status update to renderer.
   */
  private notifyStatus(update: QueueStatusUpdate): void {
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      this.mainWindow.webContents.send('queue-status-update', update);
    }
  }

  /**
   * Get current processing state (for debugging).
   */
  isProcessing(): boolean {
    return this.processing;
  }
}

// Singleton instance
let queueManager: QueueManager | null = null;

/**
 * Create and return the queue manager singleton.
 * Call once at app startup.
 */
export function createQueueManager(): QueueManager {
  if (!queueManager) {
    queueManager = new QueueManager();
  }
  return queueManager;
}

/**
 * Get the queue manager instance.
 * Throws if not initialized.
 */
export function getQueueManager(): QueueManager {
  if (!queueManager) {
    throw new Error('QueueManager not initialized. Call createQueueManager() first.');
  }
  return queueManager;
}
```
  </action>
  <verify>TypeScript compiles: `npm run typecheck` passes.</verify>
  <done>QueueManager class exists with enqueue, processNext, timeout handling, and push notifications.</done>
</task>

<task type="auto">
  <name>Task 2: Wire QueueManager into main process</name>
  <files>src/main/index.ts</files>
  <action>
Update `src/main/index.ts` to:

1. Import QueueManager:
```typescript
import { createQueueManager, getQueueManager } from './queueManager';
```

2. Create QueueManager after database init (in `app.whenReady()` callback), BEFORE createWindow():
```typescript
// Initialize queue manager after database
const queueManager = createQueueManager();
```

3. After createWindow(), set the main window on the queue manager:
```typescript
const mainWindow = createWindow();
queueManager.setMainWindow(mainWindow);
```

Note: Update createWindow() to RETURN the mainWindow instance instead of just creating it:
```typescript
const createWindow = (): BrowserWindow => {
  const mainWindow = new BrowserWindow({
    // ... existing config
  });
  // ... existing code
  return mainWindow;  // Add this return
};
```

4. Add new IPC handler for enqueueing CVs:
```typescript
/**
 * Enqueue a CV for processing.
 * Immediately persists to database with status='queued'.
 * Returns { success: true, id: string } on success
 * Returns { success: false, error: string } on failure
 */
ipcMain.handle('enqueue-cv', async (_event, fileName: string, filePath: string, projectId?: string) => {
  try {
    // Validate file path
    if (!filePath || typeof filePath !== 'string') {
      return { success: false, error: 'Invalid file path' };
    }

    // Check file exists
    if (!fs.existsSync(filePath)) {
      return { success: false, error: `File not found: ${filePath}` };
    }

    // Check file extension
    const ext = path.extname(filePath).toLowerCase();
    const validExtensions = ['.pdf', '.docx', '.doc'];
    if (!validExtensions.includes(ext)) {
      return {
        success: false,
        error: `Unsupported file type: ${ext}. Supported formats: PDF, DOCX, DOC`
      };
    }

    // Enqueue via queue manager
    const id = getQueueManager().enqueue({ fileName, filePath, projectId });

    return { success: true, id };
  } catch (error) {
    console.error('Failed to enqueue CV:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to enqueue CV'
    };
  }
});
```

5. Add IPC handler for getting queued CVs:
```typescript
import { getQueuedCVsByProject } from './database';

/**
 * Get all queued/processing CVs for a project.
 * Returns { success: true, data: QueuedCV[] } on success
 */
ipcMain.handle('get-queued-cvs', async (_event, projectId?: string) => {
  try {
    const cvs = getQueuedCVsByProject(projectId);
    return { success: true, data: cvs };
  } catch (error) {
    console.error('Failed to get queued CVs:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get queued CVs'
    };
  }
});
```
  </action>
  <verify>App starts without errors. QueueManager initialization logged. IPC handlers registered.</verify>
  <done>QueueManager is created at startup, connected to main window, and IPC handlers are registered.</done>
</task>

</tasks>

<verification>
1. App starts without errors
2. Console shows "QueueManager: Reset X stuck CVs" if any were processing
3. TypeScript compiles: `npm run typecheck` passes
4. IPC handlers 'enqueue-cv' and 'get-queued-cvs' are registered (check via devtools ipcMain inspection)
</verification>

<success_criteria>
- QueueManager singleton created at app startup
- QueueManager connected to main window for push notifications
- Processing flag prevents concurrent extraction
- Timeout starts when processNext() calls extractCV, not on enqueue
- Status updates pushed via webContents.send
</success_criteria>

<output>
After completion, create `.planning/phases/04.6-queue-infrastructure-persistence/04.6-02-SUMMARY.md`
</output>
