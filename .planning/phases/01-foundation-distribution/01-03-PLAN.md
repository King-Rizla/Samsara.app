---
phase: 01-foundation-distribution
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/main/pythonManager.ts
  - src/main/index.ts
  - forge.config.ts
  - windowsSign.ts
  - entitlements.plist
  - metadata.json
  - .env.signing.example
autonomous: false
user_setup:
  - service: azure-trusted-signing
    why: "Windows code signing for SmartScreen reputation"
    env_vars:
      - name: AZURE_CODE_SIGNING_DLIB
        source: "Azure Portal -> Artifact Signing -> Tools download"
      - name: AZURE_METADATA_JSON
        source: "Create metadata.json file with account/certificate info"
    dashboard_config:
      - task: "Create Trusted Signing account ($9.99/month)"
        location: "Azure Portal -> Create resource -> Trusted Signing"
      - task: "Create certificate profile"
        location: "Azure Portal -> Trusted Signing -> Certificate profiles"
  - service: apple-developer
    why: "macOS code signing and notarization"
    env_vars:
      - name: APPLE_ID
        source: "Your Apple Developer account email"
      - name: APPLE_ID_PASSWORD
        source: "App-specific password from appleid.apple.com"
      - name: APPLE_TEAM_ID
        source: "Apple Developer portal -> Membership -> Team ID"

must_haves:
  truths:
    - "Electron spawns Python sidecar at startup and receives health_check response within 10 seconds"
    - "Python sidecar terminates cleanly when Electron quits"
    - "IPC uses spawn + JSON lines, NOT python-shell library"
    - "Packaged app includes Python sidecar as extraResource"
    - "Code signing configuration is in place for Windows and macOS"
  artifacts:
    - path: "src/main/pythonManager.ts"
      provides: "Python sidecar lifecycle management"
      contains: "child_process"
    - path: "forge.config.ts"
      provides: "Updated Forge config with extraResource and signing"
      contains: "extraResource"
    - path: "windowsSign.ts"
      provides: "Azure Trusted Signing configuration"
      contains: "AZURE_CODE_SIGNING_DLIB"
    - path: "entitlements.plist"
      provides: "macOS entitlements for Python binaries"
      contains: "com.apple.security.cs.allow-unsigned-executable-memory"
  key_links:
    - from: "src/main/index.ts"
      to: "src/main/pythonManager.ts"
      via: "import and startPython call"
      pattern: "import.*pythonManager"
    - from: "src/main/pythonManager.ts"
      to: "python-dist/samsara-backend"
      via: "spawn executable path"
      pattern: "process\\.resourcesPath.*python"
    - from: "forge.config.ts"
      to: "windowsSign.ts"
      via: "import windowsSign"
      pattern: "import.*windowsSign"
---

<objective>
Integrate Python sidecar with Electron, configure code signing, and validate the distribution pipeline.

Purpose: Connects the Electron shell (Plan 01) with the Python sidecar (Plan 02), adds code signing configuration, and validates that the packaged app works end-to-end. This is the critical integration that proves Phase 1 success criteria.

Output: A packaged Electron app that spawns the Python sidecar, communicates via JSON-over-stdio, and has code signing configured for both platforms.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-distribution/01-RESEARCH.md
@.planning/phases/01-foundation-distribution/01-01-SUMMARY.md
@.planning/phases/01-foundation-distribution/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python manager with spawn-based IPC</name>
  <files>
    src/main/pythonManager.ts
    src/main/index.ts
  </files>
  <action>
    1. Create `src/main/pythonManager.ts` using `child_process.spawn` (NOT python-shell library):

       ```typescript
       /**
        * Python Sidecar Manager
        *
        * Spawns and manages the Python backend process.
        * Uses JSON lines over stdin/stdout for IPC - simple and reliable.
        *
        * IMPORTANT: Do NOT use python-shell library. Direct spawn gives more
        * control and is the current recommended pattern.
        */
       import { spawn, ChildProcess } from 'child_process';
       import * as readline from 'readline';
       import { app } from 'electron';
       import * as path from 'path';

       let pythonProcess: ChildProcess | null = null;
       let pythonReady = false;
       let readlineInterface: readline.Interface | null = null;
       const pendingRequests = new Map<string, {
         resolve: (value: unknown) => void;
         reject: (reason: Error) => void;
         timeout: NodeJS.Timeout;
       }>();

       let requestCounter = 0;

       function generateRequestId(): string {
         return `req-${++requestCounter}-${Date.now()}`;
       }

       function findPythonPath(): string {
         const isPackaged = app.isPackaged;
         const exeName = process.platform === 'win32' ? 'samsara-backend.exe' : 'samsara-backend';

         if (isPackaged) {
           // In packaged app, Python is in resources/python/
           return path.join(process.resourcesPath, 'python', exeName);
         }
         // In development, Python is in python-dist/samsara-backend/
         return path.join(__dirname, '..', '..', 'python-dist', 'samsara-backend', exeName);
       }

       export async function startPython(): Promise<void> {
         if (pythonProcess) {
           console.log('Python process already running');
           return;
         }

         const pythonPath = findPythonPath();
         console.log(`Starting Python sidecar: ${pythonPath}`);

         pythonProcess = spawn(pythonPath, [], {
           stdio: ['pipe', 'pipe', 'pipe'],
           windowsHide: true,
         });

         // Handle stderr for debugging
         pythonProcess.stderr?.on('data', (data: Buffer) => {
           console.error('Python stderr:', data.toString());
         });

         // Handle process exit
         pythonProcess.on('exit', (code, signal) => {
           console.log(`Python process exited: code=${code}, signal=${signal}`);
           pythonProcess = null;
           pythonReady = false;
           readlineInterface = null;

           // Reject all pending requests
           for (const [id, pending] of pendingRequests) {
             clearTimeout(pending.timeout);
             pending.reject(new Error('Python process exited'));
           }
           pendingRequests.clear();
         });

         // Set up readline for JSON line parsing
         readlineInterface = readline.createInterface({
           input: pythonProcess.stdout!,
           crlfDelay: Infinity
         });

         readlineInterface.on('line', (line: string) => {
           try {
             const response = JSON.parse(line);

             // Handle status messages (no request id)
             if (response.status) {
               console.log('Python status:', response.status);
               return;
             }

             // Handle request responses
             const pending = pendingRequests.get(response.id);
             if (pending) {
               clearTimeout(pending.timeout);
               pendingRequests.delete(response.id);
               if (response.success) {
                 pending.resolve(response.data);
               } else {
                 pending.reject(new Error(response.error || 'Unknown error'));
               }
             }
           } catch (e) {
             console.error('Invalid JSON from Python:', line);
           }
         });

         // Wait for Python to be ready (health check within 10 seconds per success criteria)
         const startTime = Date.now();
         const maxWaitMs = 10000;
         const retryIntervalMs = 500;

         while (Date.now() - startTime < maxWaitMs) {
           try {
             await sendToPython({ action: 'health_check' }, 1000);
             pythonReady = true;
             console.log('Python sidecar ready');
             return;
           } catch (e) {
             // Keep retrying
             await new Promise(r => setTimeout(r, retryIntervalMs));
           }
         }

         throw new Error('Python sidecar failed to start within 10 seconds');
       }

       export function sendToPython(request: object, timeoutMs = 30000): Promise<unknown> {
         return new Promise((resolve, reject) => {
           if (!pythonProcess || !pythonProcess.stdin) {
             reject(new Error('Python process not running'));
             return;
           }

           const id = generateRequestId();
           const requestWithId = { ...request, id };

           const timeout = setTimeout(() => {
             pendingRequests.delete(id);
             reject(new Error(`Request ${id} timed out after ${timeoutMs}ms`));
           }, timeoutMs);

           pendingRequests.set(id, { resolve, reject, timeout });

           pythonProcess.stdin.write(JSON.stringify(requestWithId) + '\n');
         });
       }

       export function stopPython(): void {
         if (!pythonProcess) return;

         console.log('Stopping Python sidecar...');

         // Send shutdown command
         try {
           pythonProcess.stdin?.write(JSON.stringify({ action: 'shutdown' }) + '\n');
         } catch (e) {
           // Ignore write errors during shutdown
         }

         // Force kill after 2 seconds if still running
         const killTimeout = setTimeout(() => {
           if (pythonProcess) {
             console.log('Force killing Python process');

             // Windows: kill process tree
             if (process.platform === 'win32' && pythonProcess.pid) {
               spawn('taskkill', ['/pid', pythonProcess.pid.toString(), '/f', '/t']);
             } else {
               pythonProcess.kill('SIGKILL');
             }
           }
         }, 2000);

         pythonProcess.on('exit', () => {
           clearTimeout(killTimeout);
         });
       }

       export function isPythonReady(): boolean {
         return pythonReady;
       }
       ```

    2. Update `src/main/index.ts` to integrate Python manager:

       - Add imports at top:
         ```typescript
         import { startPython, stopPython } from './pythonManager';
         ```

       - In `app.whenReady()`, after `initDatabase()`:
         ```typescript
         try {
           await startPython();
         } catch (error) {
           console.error('Failed to start Python sidecar:', error);
           // Continue app startup even if Python fails (for debugging)
         }
         ```

       - Add cleanup handlers:
         ```typescript
         app.on('before-quit', () => {
           stopPython();
         });

         app.on('window-all-closed', () => {
           stopPython();
           if (process.platform !== 'darwin') {
             app.quit();
           }
         });
         ```

    CRITICAL: Do NOT install or use python-shell library. The implementation MUST use direct `child_process.spawn` with `readline` for JSON line parsing.
  </action>
  <verify>
    1. Run `npm run start` - app should launch and show "Python sidecar ready" in console
    2. No errors about python-shell module
    3. Closing the Electron app should cleanly terminate the Python process (check Task Manager/Activity Monitor)
    4. `grep -r "python-shell" .` should return no results in source files
  </verify>
  <done>
    Python manager implemented with spawn-based IPC (not python-shell), starts sidecar on app launch, and handles cleanup on quit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Forge for packaging with code signing</name>
  <files>
    forge.config.ts
    windowsSign.ts
    entitlements.plist
    metadata.json
    .env.signing.example
  </files>
  <action>
    1. Create `entitlements.plist` for macOS code signing:
       ```xml
       <?xml version="1.0" encoding="UTF-8"?>
       <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
       <plist version="1.0">
       <dict>
         <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
         <true/>
         <key>com.apple.security.cs.disable-library-validation</key>
         <true/>
       </dict>
       </plist>
       ```
       Note: These entitlements are required for PyInstaller Python binaries to run under hardened runtime.

    2. Create `windowsSign.ts` for Azure Trusted Signing:
       ```typescript
       /**
        * Windows Code Signing Configuration
        *
        * Uses Azure Trusted Signing (formerly Azure Artifact Signing).
        * Requires setup in Azure Portal and environment variables.
        *
        * Env vars needed:
        * - AZURE_CODE_SIGNING_DLIB: Path to Azure signing DLL
        * - AZURE_METADATA_JSON: Path to metadata.json with signing config
        * - SIGNTOOL_PATH: (Optional) Custom path to signtool.exe
        */
       import type { SignOptions } from '@electron/windows-sign';

       export const windowsSign: SignOptions | undefined =
         process.env.AZURE_CODE_SIGNING_DLIB ? {
           // Custom signtool path (optional)
           ...(process.env.SIGNTOOL_PATH
             ? { signToolPath: process.env.SIGNTOOL_PATH }
             : {}),
           // Azure Trusted Signing parameters
           signWithParams: `/v /debug /fd SHA256 /dlib "${process.env.AZURE_CODE_SIGNING_DLIB}" /dmdf "${process.env.AZURE_METADATA_JSON}"`,
           // RFC 3161 timestamp server
           timestampServer: 'http://timestamp.acs.microsoft.com',
         } : undefined;
       ```

    3. Create `metadata.json` template for Azure signing:
       ```json
       {
         "Endpoint": "https://eus.codesigning.azure.net",
         "CodeSigningAccountName": "YOUR_ACCOUNT_NAME",
         "CertificateProfileName": "YOUR_PROFILE_NAME"
       }
       ```

    4. Create `.env.signing.example` with required environment variables:
       ```bash
       # Windows (Azure Trusted Signing)
       AZURE_CODE_SIGNING_DLIB=C:/path/to/Azure.CodeSigning.Dlib.dll
       AZURE_METADATA_JSON=./metadata.json
       # SIGNTOOL_PATH=C:/path/to/signtool.exe  # Optional

       # macOS (Apple Developer)
       APPLE_ID=your@email.com
       APPLE_ID_PASSWORD=app-specific-password
       APPLE_TEAM_ID=TEAM_ID_HERE
       ```

    5. Update `forge.config.ts` with extraResource and signing:
       ```typescript
       import type { ForgeConfig } from '@electron-forge/shared-types';
       import { VitePlugin } from '@electron-forge/plugin-vite';
       import { windowsSign } from './windowsSign';

       const config: ForgeConfig = {
         packagerConfig: {
           asar: true,
           extraResource: [
             './python-dist/samsara-backend',  // Python sidecar directory
           ],
           // macOS signing (only applied when building for macOS with certs)
           ...(process.env.APPLE_ID ? {
             osxSign: {
               identity: process.env.APPLE_IDENTITY || 'Developer ID Application',
               hardenedRuntime: true,
               entitlements: './entitlements.plist',
               entitlementsInherit: './entitlements.plist',
             },
             osxNotarize: {
               appleId: process.env.APPLE_ID,
               appleIdPassword: process.env.APPLE_ID_PASSWORD!,
               teamId: process.env.APPLE_TEAM_ID!,
             },
           } : {}),
           // Windows signing
           ...(windowsSign ? { windowsSign } : {}),
         },
         rebuildConfig: {},
         makers: [
           // Add makers later when running actual builds
           // For now, just package command works
         ],
         plugins: [
           new VitePlugin({
             concurrent: false,  // Prevent OOM issues
             build: [
               {
                 entry: 'src/main/index.ts',
                 config: 'vite.main.config.ts',
               },
               {
                 entry: 'src/main/preload.ts',
                 config: 'vite.preload.config.ts',
               },
             ],
             renderer: [
               {
                 name: 'main_window',
                 config: 'vite.renderer.config.ts',
               },
             ],
           }),
         ],
       };

       export default config;
       ```

    6. Install @electron/windows-sign:
       ```bash
       npm install -D @electron/windows-sign
       ```
  </action>
  <verify>
    1. `entitlements.plist` exists with required Python entitlements
    2. `windowsSign.ts` exists and imports correctly in forge.config.ts
    3. `forge.config.ts` includes extraResource for python-dist/samsara-backend
    4. `npm run package` completes without errors (signing skipped without env vars)
    5. Packaged app in `out/` directory includes Python sidecar in resources
  </verify>
  <done>
    Forge configured with extraResource for Python sidecar and code signing configuration for both Windows and macOS.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 foundation:
    - Electron shell with Vite + SQLite
    - Python sidecar with PyInstaller + spaCy
    - Sidecar integration via spawn + JSON lines IPC
    - Code signing configuration for both platforms
  </what-built>
  <how-to-verify>
    1. **Development mode test:**
       - Run `npm run start`
       - Verify Electron window appears
       - Verify console shows "Python sidecar ready"
       - Close window and verify Python process terminates

    2. **Package test:**
       - Run `npm run package`
       - Navigate to `out/` directory
       - Run the packaged executable
       - Verify window appears and Python initializes
       - Check `userData` directory for `samsara.db` file

    3. **IPC health check:**
       - In dev mode, Python health check should complete within 10 seconds
       - Console should show model loading status messages

    4. **Code signing check (if certs available):**
       - Windows: Right-click .exe -> Properties -> Digital Signatures tab
       - macOS: `codesign -dv --verbose=4 /path/to/app.app`

    If any verification fails, describe what went wrong.
  </how-to-verify>
  <resume-signal>Type "approved" to confirm Phase 1 is complete, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npm run start` launches app with Python sidecar (console shows "Python sidecar ready")
2. No python-shell library in node_modules or source files
3. `npm run package` creates packaged app with Python in resources/
4. Packaged app launches and Python initializes
5. SQLite database created in userData with WAL mode
6. Python process terminates cleanly when app closes
7. Code signing config files exist (windowsSign.ts, entitlements.plist)
</verification>

<success_criteria>
Phase 1 Success Criteria validation:
1. [x] Packaged app loads spaCy model and responds to IPC health check within 10 seconds
2. [x] PyInstaller `--onedir` build completes with all spaCy hidden imports
3. [x] Code signing configuration passes for both Windows and macOS (actual signing requires user credentials)
4. [x] Electron shell displays basic window and communicates with Python sidecar via stdio JSON
5. [x] SQLite database initializes in app.getPath('userData') with WAL mode enabled
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-distribution/01-03-SUMMARY.md`
</output>
