# Phase 4.8: JD Matching Enhancement - Research

**Researched:** 2026-01-28
**Domain:** LLM-based JD parsing enhancement, boolean search generation, skill taxonomy expansion
**Confidence:** HIGH

## Summary

Phase 4.8 enhances the existing JD parsing to maximize the value of each LLM call by extracting additional matching_metadata: expanded skill variants, boolean search strings, and search hints. This prepares for M4 Intelligent Sourcing while immediately improving algorithmic matching recall.

The research confirms that **extending the existing single LLM call** (established in Phase 4 as `LLMJDExtraction`) is the correct approach. The LLM is already processing the JD text and understanding skill semantics - having it also generate variants, booleans, and search hints is marginal additional cost vs. massive value gain. The boolean search syntax is well-documented across recruiting platforms with consistent operator semantics (AND/OR/NOT), though delimiter/quote syntax varies by platform, justifying the user-configurable syntax settings.

Key insight: The LLM should generate **expanded skill variants at extraction time** (e.g., "Python" -> ["Python", "Py", "Python3", "Django", "Flask"]), not at matching time. This offloads the semantic expansion work to the LLM once per JD, rather than doing runtime lookups against a static variant map. The existing `skillVariants.ts` becomes a fallback/supplement, not the primary source.

**Primary recommendation:** Extend `LLMJDExtraction` schema to include `matching_metadata` field containing skill_variants, boolean_strings, and search_hints. Store raw_text and matching_metadata separately. Add Boolean Syntax settings to the existing unified Settings page.

## Standard Stack

### Core (Already in Project - No Changes)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Ollama/Qwen 2.5 7B or GPT-4o-mini | Current | Enhanced JD parsing | Single LLM call preferred (per Phase 02.1-02 decision) |
| Pydantic | 2.x | Extended schema validation | Already used for JD schemas |
| better-sqlite3 | Current | Store matching_metadata | Existing database layer |
| Zustand | 4.x | UI state | Already in frontend |
| shadcn/ui | Current | UI components | Already configured with terminal theme |

### New Dependencies
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| None | - | - | No new dependencies required |

**Key principle:** This phase extends existing infrastructure, it does not add new libraries.

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| LLM skill expansion | ESCO taxonomy API | ESCO adds external dependency, latency; LLM already understands context |
| Single expanded prompt | Multiple LLM calls | Violates cost efficiency decision (1 API call always preferred) |
| Hardcoded boolean syntax | User configurable | Different platforms have different syntax; configurability is essential |

**Installation:**
```bash
# No new dependencies
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── renderer/
│   ├── components/
│   │   ├── jd/
│   │   │   ├── SearchTools.tsx        # NEW: Collapsible section with booleans
│   │   │   └── JDRequirements.tsx     # Existing (no changes)
│   │   └── settings/
│   │       └── BooleanSyntaxSettings.tsx  # NEW: Boolean syntax config
│   ├── stores/
│   │   └── usageStore.ts              # Extend with boolean syntax settings
│   └── types/
│       └── jd.ts                      # Extend with matching_metadata
└── main/
    └── database.ts                    # Add matching_metadata column

python-src/
├── extractors/
│   └── llm/
│       ├── schemas.py                 # Extend LLMJDExtraction
│       └── prompts.py                 # Enhance JD_EXTRACTION_PROMPT
└── main.py                            # No changes to extract_jd action flow
```

### Pattern 1: Extended JD Data Model
**What:** Add matching_metadata to JD structure
**When to use:** All JD extraction and storage operations
**Example:**
```typescript
// src/renderer/types/jd.ts - EXTENDED
interface ExpandedSkill {
  skill: string;                    // Original skill from JD
  variants: string[];               // Semantic variants for matching
  related_tools?: string[];         // Related frameworks/tools (e.g., Python -> Django, Flask)
}

interface BooleanStrings {
  wide: string;                     // Broad search: many OR terms, few AND
  midline: string;                  // Balanced: core skills AND, variants OR
  narrow: string;                   // Strict: required skills AND only
}

interface SearchHints {
  suggested_titles: string[];       // Related job titles to search
  industries?: string[];            // Relevant industries
  negative_keywords: string[];      // Terms to exclude (NOT)
}

interface MatchingMetadata {
  expanded_skills: ExpandedSkill[]; // All skills with variants
  boolean_strings: BooleanStrings;  // Pre-generated search strings
  search_hints: SearchHints;        // For future auto-sourcing
}

// Extended JobDescription
interface JobDescription {
  id: string;
  title: string;
  company?: string;
  raw_text: string;                 // Original JD - preserved, displayed as-is
  created_at: string;
  updated_at: string;

  // LLM-extracted requirements (existing)
  required_skills: SkillRequirement[];
  preferred_skills: SkillRequirement[];
  experience_min?: number;
  experience_max?: number;
  education_level?: string;
  certifications: string[];

  // NEW: Matching enhancement metadata
  matching_metadata?: MatchingMetadata;
}
```

### Pattern 2: Extended LLM Schema
**What:** Pydantic schema for enhanced JD extraction
**When to use:** Single LLM call extracts both requirements AND matching metadata
**Example:**
```python
# python-src/extractors/llm/schemas.py - EXTENDED

class LLMExpandedSkill(BaseModel):
    """A skill with semantic variants for improved matching."""
    skill: str = Field(description="Original skill name from JD")
    variants: List[str] = Field(
        default_factory=list,
        description="Alternative names, abbreviations, and synonyms (e.g., 'JavaScript' -> ['JS', 'ECMAScript'])"
    )
    related_tools: List[str] = Field(
        default_factory=list,
        description="Related frameworks, libraries, or tools (e.g., 'Python' -> ['Django', 'Flask', 'FastAPI'])"
    )

class LLMBooleanStrings(BaseModel):
    """Pre-generated boolean search strings for recruiting platforms."""
    wide: str = Field(description="Broad search with many OR terms: (\"Python\" OR \"Django\" OR \"Flask\") AND \"Developer\"")
    midline: str = Field(description="Balanced search: (\"Python\" OR \"Py\") AND (\"Django\" OR \"Flask\") AND \"Backend\"")
    narrow: str = Field(description="Strict search with required terms only: \"Python\" AND \"Django\" AND \"Senior\"")

class LLMSearchHints(BaseModel):
    """Search hints for future auto-sourcing feature."""
    suggested_titles: List[str] = Field(
        default_factory=list,
        description="Related job titles to search (e.g., 'Backend Developer', 'Python Engineer')"
    )
    industries: List[str] = Field(
        default_factory=list,
        description="Relevant industries (e.g., 'FinTech', 'SaaS', 'Healthcare')"
    )
    negative_keywords: List[str] = Field(
        default_factory=list,
        description="Terms to exclude from searches (e.g., 'Junior', 'Intern', 'Entry-level')"
    )

class LLMMatchingMetadata(BaseModel):
    """Enhanced matching data generated from JD analysis."""
    expanded_skills: List[LLMExpandedSkill] = Field(
        default_factory=list,
        description="All skills from required_skills and preferred_skills with variants and related tools"
    )
    boolean_strings: LLMBooleanStrings = Field(
        description="Pre-generated boolean search strings in three tiers"
    )
    search_hints: LLMSearchHints = Field(
        default_factory=LLMSearchHints,
        description="Search hints for candidate sourcing"
    )

class LLMJDExtraction(BaseModel):
    """Complete JD extraction in a single LLM call - ENHANCED."""
    # Existing fields (unchanged)
    title: str = Field(description="Job title")
    company: Optional[str] = Field(default=None, description="Company name if mentioned")
    required_skills: List[LLMSkillRequirement] = Field(default_factory=list)
    preferred_skills: List[LLMSkillRequirement] = Field(default_factory=list)
    experience_min_years: Optional[int] = Field(default=None)
    experience_max_years: Optional[int] = Field(default=None)
    education_level: Optional[str] = Field(default=None)
    certifications: List[str] = Field(default_factory=list)

    # NEW: Matching metadata
    matching_metadata: LLMMatchingMetadata = Field(
        description="Enhanced matching data including skill variants, boolean strings, and search hints"
    )
```

### Pattern 3: Enhanced JD Extraction Prompt
**What:** Extended prompt that instructs LLM to generate matching metadata
**When to use:** JD extraction via extract_jd action
**Example:**
```python
# python-src/extractors/llm/prompts.py - ENHANCED

JD_EXTRACTION_PROMPT = """You are a job description parser AND recruiting assistant. Extract structured requirements AND generate matching metadata.

## PART 1: REQUIREMENTS EXTRACTION
Extract the following from the JD text:
- title, company, required_skills, preferred_skills
- experience_min_years, experience_max_years, education_level, certifications

## PART 2: MATCHING METADATA
Generate enhanced matching data:

### EXPANDED SKILLS
For EACH skill in required_skills and preferred_skills:
- variants: Alternative names, abbreviations, acronyms (e.g., "JavaScript" -> ["JS", "ECMAScript", "ES6"])
- related_tools: Frameworks, libraries, or tools that demonstrate this skill (e.g., "Python" -> ["Django", "Flask", "FastAPI", "Pandas"])

### BOOLEAN STRINGS
Generate three boolean search strings using standard syntax:
- Use "quotes" for exact phrases
- Use AND to require terms
- Use OR for alternatives
- Use parentheses for grouping
- Use NOT for exclusions

Create:
1. wide: Broad search - job title OR variations, many skill alternatives
2. midline: Balanced - core requirements AND, skill variations OR
3. narrow: Strict - only required skills as AND terms

### SEARCH HINTS
- suggested_titles: Related job titles someone with these skills might have
- industries: Industries where these skills are common
- negative_keywords: Terms to exclude (e.g., if looking for Senior, exclude "Junior", "Intern")

## OUTPUT FORMAT
Return a single JSON object with both requirements and matching_metadata.

## GUIDELINES
- Only extract what is EXPLICITLY stated for requirements
- Generate helpful variants and related tools based on your knowledge
- Boolean strings should be immediately usable on LinkedIn or job boards
- Think like a recruiter building a sourcing strategy
"""
```

### Pattern 4: Boolean Syntax Configuration
**What:** User-configurable boolean syntax settings
**When to use:** Settings page, boolean display/copy
**Example:**
```typescript
// src/renderer/types/settings.ts - NEW

interface BooleanSyntaxConfig {
  andOperator: 'AND' | '&&' | '+';      // Default: 'AND'
  orOperator: 'OR' | '||' | ',';        // Default: 'OR'
  notOperator: 'NOT' | '-' | '!';       // Default: 'NOT'
  phraseDelimiter: '"' | "'";           // Default: '"'
  groupingStyle: 'parentheses' | 'none'; // Default: 'parentheses'
}

// Default configuration (LinkedIn/standard)
const DEFAULT_BOOLEAN_SYNTAX: BooleanSyntaxConfig = {
  andOperator: 'AND',
  orOperator: 'OR',
  notOperator: 'NOT',
  phraseDelimiter: '"',
  groupingStyle: 'parentheses',
};

// Function to transform boolean string based on user config
function transformBooleanSyntax(
  booleanString: string,
  config: BooleanSyntaxConfig
): string {
  let result = booleanString;

  // Replace operators (careful with order to avoid double-replacement)
  if (config.andOperator !== 'AND') {
    result = result.replace(/\bAND\b/g, config.andOperator);
  }
  if (config.orOperator !== 'OR') {
    result = result.replace(/\bOR\b/g, config.orOperator);
  }
  if (config.notOperator !== 'NOT') {
    result = result.replace(/\bNOT\b/g, config.notOperator);
  }
  if (config.phraseDelimiter !== '"') {
    result = result.replace(/"/g, config.phraseDelimiter);
  }
  if (config.groupingStyle === 'none') {
    result = result.replace(/[()]/g, '');
  }

  return result;
}
```

### Pattern 5: Search Tools UI Component
**What:** Collapsible UI section displaying boolean strings
**When to use:** JD detail view
**Example:**
```tsx
// src/renderer/components/jd/SearchTools.tsx
import { useState } from 'react';
import { ChevronDown, ChevronRight, Copy, Check, Edit2 } from 'lucide-react';
import { Button } from '../ui/button';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '../ui/collapsible';

interface SearchToolsProps {
  booleanStrings: {
    wide: string;
    midline: string;
    narrow: string;
  };
  searchHints: {
    suggested_titles: string[];
    negative_keywords: string[];
  };
  syntaxConfig: BooleanSyntaxConfig;
}

export function SearchTools({ booleanStrings, searchHints, syntaxConfig }: SearchToolsProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [copiedKey, setCopiedKey] = useState<string | null>(null);
  const [editingKey, setEditingKey] = useState<string | null>(null);
  const [editedStrings, setEditedStrings] = useState(booleanStrings);

  const handleCopy = (key: string, value: string) => {
    const transformed = transformBooleanSyntax(value, syntaxConfig);
    navigator.clipboard.writeText(transformed);
    setCopiedKey(key);
    setTimeout(() => setCopiedKey(null), 2000);
  };

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen}>
      <CollapsibleTrigger asChild>
        <Button variant="ghost" className="w-full justify-between">
          <span>Search Tools</span>
          {isOpen ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
        </Button>
      </CollapsibleTrigger>
      <CollapsibleContent className="space-y-4 pt-4">
        {/* Boolean Strings */}
        {(['wide', 'midline', 'narrow'] as const).map((tier) => (
          <div key={tier} className="space-y-2">
            <div className="flex items-center justify-between">
              <label className="text-sm font-medium capitalize">{tier} Search</label>
              <div className="flex gap-1">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setEditingKey(editingKey === tier ? null : tier)}
                >
                  <Edit2 className="h-3 w-3" />
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => handleCopy(tier, editedStrings[tier])}
                >
                  {copiedKey === tier ? <Check className="h-3 w-3" /> : <Copy className="h-3 w-3" />}
                </Button>
              </div>
            </div>
            {editingKey === tier ? (
              <textarea
                className="w-full p-2 text-xs bg-muted rounded border"
                value={editedStrings[tier]}
                onChange={(e) => setEditedStrings({ ...editedStrings, [tier]: e.target.value })}
                rows={3}
              />
            ) : (
              <div className="p-2 text-xs bg-muted rounded font-mono break-all">
                {transformBooleanSyntax(editedStrings[tier], syntaxConfig)}
              </div>
            )}
          </div>
        ))}

        {/* Search Hints */}
        {searchHints.suggested_titles.length > 0 && (
          <div className="pt-2 border-t">
            <label className="text-sm font-medium">Suggested Titles</label>
            <div className="flex flex-wrap gap-1 mt-1">
              {searchHints.suggested_titles.map((title) => (
                <span key={title} className="px-2 py-0.5 text-xs bg-muted rounded">{title}</span>
              ))}
            </div>
          </div>
        )}
      </CollapsibleContent>
    </Collapsible>
  );
}
```

### Anti-Patterns to Avoid
- **Multiple LLM calls for enhancement:** Don't separate skill extraction from variant generation - do it all in one call
- **Storing booleans with user's syntax:** Store in canonical format (AND/OR/NOT), transform at display time
- **Modifying raw_text:** Never alter the original JD text - it's for user reference
- **Hardcoding boolean operators:** Different platforms have different syntax; must be configurable
- **Runtime variant expansion:** Generate variants at extraction time, not at matching time

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Skill semantic expansion | Custom synonym dictionary | LLM at extraction time | LLM understands context, relationships, domain-specific terms |
| Boolean string parsing | Regex-based transformer | Store canonical, transform at display | Simpler, no parsing errors |
| Collapsible UI | Custom show/hide logic | shadcn Collapsible | Consistent with existing UI, accessible |
| Clipboard operations | Custom clipboard handler | navigator.clipboard API | Standard, well-supported |

**Key insight:** The LLM is already doing semantic understanding - leverage that for variant expansion rather than building a static mapping table. The existing `skillVariants.ts` becomes a supplementary fallback, not the primary source.

## Common Pitfalls

### Pitfall 1: Boolean String Too Long
**What goes wrong:** Generated boolean string exceeds LinkedIn's 300 character limit
**Why it happens:** LLM generates comprehensive strings with all variants
**How to avoid:** Prompt should specify character limits; truncate intelligently
**Warning signs:** Copy-paste fails silently on LinkedIn

### Pitfall 2: Inconsistent Operator Case
**What goes wrong:** "and", "AND", "And" mixed in generated strings
**Why it happens:** LLM output inconsistency
**How to avoid:** Normalize operators after extraction; validate schema
**Warning signs:** Searches return unexpected results

### Pitfall 3: Overloaded Related Tools
**What goes wrong:** "Python" related_tools includes everything (NumPy, SciPy, TensorFlow, etc.)
**Why it happens:** LLM tries to be comprehensive
**How to avoid:** Prompt should limit to 3-5 most relevant; context from JD should guide selection
**Warning signs:** Boolean strings become noise

### Pitfall 4: Storing Transformed Booleans
**What goes wrong:** User changes syntax preference, old JDs have wrong format
**Why it happens:** Storing with user's current syntax instead of canonical
**How to avoid:** Always store AND/OR/NOT format; transform at display/copy time
**Warning signs:** Inconsistent format across JDs

### Pitfall 5: Blocking on Metadata Generation
**What goes wrong:** JD extraction fails if metadata generation fails
**Why it happens:** Single schema requires all fields
**How to avoid:** matching_metadata should have sensible defaults; partial extraction is better than no extraction
**Warning signs:** JD extraction errors increase after enhancement

### Pitfall 6: Duplicate Variants
**What goes wrong:** Same variant appears in multiple skills' expansion
**Why it happens:** "React" and "Frontend" both expand to include "JavaScript"
**How to avoid:** Acceptable - dedupe at matching time if needed
**Warning signs:** Boolean strings have redundant terms (minor issue)

## Code Examples

### Database Schema Extension
```sql
-- Extend job_descriptions table (Migration v4)
ALTER TABLE job_descriptions ADD COLUMN matching_metadata_json TEXT;

-- Example stored value:
-- {
--   "expanded_skills": [
--     {"skill": "Python", "variants": ["Py", "Python3"], "related_tools": ["Django", "Flask"]},
--     {"skill": "AWS", "variants": ["Amazon Web Services"], "related_tools": ["EC2", "S3", "Lambda"]}
--   ],
--   "boolean_strings": {
--     "wide": "(\"Python\" OR \"Django\" OR \"Flask\") OR (\"AWS\" OR \"Cloud\")",
--     "midline": "(\"Python\" OR \"Py\") AND (\"AWS\" OR \"Amazon Web Services\")",
--     "narrow": "\"Python\" AND \"AWS\" AND \"Senior\""
--   },
--   "search_hints": {
--     "suggested_titles": ["Backend Developer", "Python Engineer", "Cloud Engineer"],
--     "industries": ["FinTech", "SaaS"],
--     "negative_keywords": ["Junior", "Intern"]
--   }
-- }
```

### Settings Store Extension
```typescript
// src/renderer/stores/usageStore.ts - EXTEND

interface UsageStoreState {
  // ... existing fields ...

  // NEW: Boolean syntax configuration
  booleanSyntax: BooleanSyntaxConfig;

  // Actions
  loadBooleanSyntax: () => Promise<void>;
  updateBooleanSyntax: (config: Partial<BooleanSyntaxConfig>) => Promise<void>;
}
```

### Enhanced Matching Algorithm
```typescript
// src/renderer/lib/matchingEngine.ts - ENHANCED

/**
 * Check if a JD skill requirement is matched by any CV skill.
 * Now uses expanded skill variants from matching_metadata if available.
 */
function findMatchingSkill(
  requirement: SkillRequirement,
  cvSkills: string[],
  expandedSkills?: ExpandedSkill[]
): string | null {
  const normalizedReq = normalizeSkill(requirement.skill);

  // First: try expanded variants from LLM (PRIMARY SOURCE)
  if (expandedSkills) {
    const expanded = expandedSkills.find(
      e => normalizeSkill(e.skill) === normalizedReq
    );
    if (expanded) {
      const allVariants = [
        expanded.skill,
        ...expanded.variants,
        ...expanded.related_tools,
      ].map(normalizeSkill);

      for (const cvSkill of cvSkills) {
        if (allVariants.some(v => skillsMatch(v, cvSkill))) {
          return cvSkill;
        }
      }
    }
  }

  // Fallback: use static skillVariants.ts mapping
  for (const cvSkill of cvSkills) {
    if (skillsMatch(normalizedReq, cvSkill)) {
      return cvSkill;
    }
  }

  return null;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Static skill variant maps | LLM-generated contextual variants | 2025-2026 | Better recall, domain-specific |
| Manual boolean string writing | LLM-generated tiered booleans | 2025-2026 | Faster sourcing workflow |
| Single skill extraction | Skill + variants + related tools | 2025-2026 | Richer matching data |
| Fixed operator syntax | Configurable per-platform syntax | 2025-2026 | Cross-platform usability |

**Current best practice:** Use LLM once to generate comprehensive matching metadata. Store in canonical format, transform at display time. Validate and constrain LLM output with Pydantic schemas.

## Open Questions

1. **Boolean String Character Limits**
   - What we know: LinkedIn has 300 char limit; other platforms vary
   - What's unclear: Exact limits for Indeed, Monster, etc.
   - Recommendation: Generate within 300 chars (lowest common denominator); allow manual editing

2. **Skill Expansion Depth**
   - What we know: LLM can generate many related tools
   - What's unclear: Optimal number of variants/related_tools
   - Recommendation: Limit to 5 variants and 5 related_tools per skill in prompt

3. **Migration of Existing JDs**
   - What we know: Existing JDs have no matching_metadata
   - What's unclear: Re-process existing JDs or leave as-is?
   - Recommendation: Leave existing JDs as-is; matching_metadata is optional enhancement

## Sources

### Primary (HIGH confidence)
- Existing codebase: `python-src/extractors/llm/schemas.py`, `prompts.py` - current JD extraction implementation
- Existing codebase: `src/renderer/lib/skillVariants.ts`, `matchingEngine.ts` - current matching implementation
- Existing codebase: `src/renderer/routes/Settings.tsx` - unified settings page pattern

### Secondary (MEDIUM confidence)
- [Boolean Search Cheat Sheet for Recruiters](https://juicebox.ai/blog/boolean-search-cheat-sheet) - Boolean operator syntax
- [Boolean Search in Recruitment: A Practical Guide](https://www.aihr.com/blog/boolean-search-in-recruitment/) - Tiered search strategies
- [LinkedIn Recruiter Boolean Search Guide](https://www.leonar.app/blog/linkedin-recruiter-boolean-search) - Platform-specific syntax
- [Skill-LLM Paper](https://arxiv.org/html/2410.12052v1) - LLM skill extraction patterns

### Tertiary (LOW confidence)
- ESCO classification system - Referenced for skill taxonomy concepts (not directly used)
- Platform-specific character limits - Needs validation per platform

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Extends existing infrastructure, no new dependencies
- Architecture patterns: HIGH - Consistent with existing codebase, builds on Phase 4 work
- Enhanced prompt design: MEDIUM - Based on research and LLM best practices, needs tuning
- Boolean syntax config: HIGH - Well-documented cross-platform differences
- UI patterns: HIGH - Uses existing shadcn components

**Research date:** 2026-01-28
**Valid until:** 2026-02-28 (30 days - stable domain, enhancement to existing feature)
