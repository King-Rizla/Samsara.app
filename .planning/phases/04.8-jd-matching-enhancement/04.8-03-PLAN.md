---
phase: 04.8-jd-matching-enhancement
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/types/jd.ts
  - src/renderer/stores/usageStore.ts
  - src/renderer/routes/Settings.tsx
  - src/main/ipc.ts
  - src/main/settingsManager.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript types exist for matching metadata structures"
    - "Boolean syntax is configurable in Settings page"
    - "Settings persist across app restarts"
    - "Default boolean syntax is LinkedIn-compatible (AND/OR/NOT)"
  artifacts:
    - path: "src/renderer/types/jd.ts"
      provides: "MatchingMetadata, BooleanSyntaxConfig types"
      contains: "MatchingMetadata"
    - path: "src/renderer/routes/Settings.tsx"
      provides: "Boolean Syntax Configuration UI"
      contains: "Boolean Syntax"
  key_links:
    - from: "Settings.tsx"
      to: "window.api"
      via: "updateAppSettings call"
      pattern: "updateAppSettings.*booleanSyntax"
---

<objective>
Add TypeScript types for matching metadata and boolean syntax configuration UI in Settings.

Purpose: Enable the frontend to work with matching metadata structures and allow users to configure boolean search string syntax for different recruiting platforms (LinkedIn, Indeed, etc.).

Output: TypeScript interfaces for matching metadata, boolean syntax config in Settings page, IPC handlers for settings persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.8-jd-matching-enhancement/04.8-RESEARCH.md

# Key existing code
@src/renderer/types/jd.ts
@src/renderer/stores/usageStore.ts
@src/renderer/routes/Settings.tsx
@src/main/ipc.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matching metadata TypeScript types</name>
  <files>src/renderer/types/jd.ts</files>
  <action>
Add new interfaces for matching metadata structures at the top of the file, after the existing SkillRequirement interface:

```typescript
// ============================================================================
// Matching Metadata Types (Phase 4.8)
// ============================================================================

/**
 * A skill with semantic variants for improved matching.
 */
export interface ExpandedSkill {
  skill: string;               // Original skill name from JD
  variants: string[];          // Alternative names, abbreviations, synonyms
  related_tools: string[];     // Related frameworks/libraries/tools
}

/**
 * Pre-generated boolean search strings in three tiers.
 */
export interface BooleanStrings {
  wide: string;      // Broad search - OR-heavy, many alternatives
  midline: string;   // Balanced - core skills AND, variations OR
  narrow: string;    // Strict - required skills only as AND terms
}

/**
 * Search hints for future auto-sourcing feature.
 */
export interface SearchHints {
  suggested_titles: string[];  // Related job titles to search
  industries: string[];        // Relevant industries
  negative_keywords: string[]; // Terms to exclude from searches
}

/**
 * Enhanced matching data generated from JD analysis.
 */
export interface MatchingMetadata {
  expanded_skills: ExpandedSkill[];
  boolean_strings: BooleanStrings;
  search_hints: SearchHints;
}

/**
 * Boolean syntax configuration for different recruiting platforms.
 */
export interface BooleanSyntaxConfig {
  andOperator: 'AND' | '&&' | '+';
  orOperator: 'OR' | '||' | ',';
  notOperator: 'NOT' | '-' | '!';
  phraseDelimiter: '"' | "'";
  groupingStyle: 'parentheses' | 'none';
}
```

Then update the JobDescription interface to include optional matching_metadata:

```typescript
/**
 * Full job description with LLM-extracted requirements.
 */
export interface JobDescription {
  id: string;
  title: string;
  company?: string;
  raw_text: string;
  created_at: string;
  updated_at: string;

  // LLM-extracted requirements
  required_skills: SkillRequirement[];
  preferred_skills: SkillRequirement[];
  experience_min?: number;
  experience_max?: number;
  education_level?: string;
  certifications: string[];

  // NEW: Matching enhancement metadata (optional)
  matching_metadata?: MatchingMetadata;
}
```
  </action>
  <verify>
1. `npm run lint` passes
2. No TypeScript errors in renderer code
  </verify>
  <done>MatchingMetadata, BooleanSyntaxConfig, and related interfaces exist in jd.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add boolean syntax transform utility</name>
  <files>src/renderer/lib/booleanSyntax.ts</files>
  <action>
Create a new utility file for boolean syntax transformation:

```typescript
// src/renderer/lib/booleanSyntax.ts
import type { BooleanSyntaxConfig } from '../types/jd';

/**
 * Default boolean syntax configuration (LinkedIn-compatible).
 */
export const DEFAULT_BOOLEAN_SYNTAX: BooleanSyntaxConfig = {
  andOperator: 'AND',
  orOperator: 'OR',
  notOperator: 'NOT',
  phraseDelimiter: '"',
  groupingStyle: 'parentheses',
};

/**
 * Transform a boolean string from canonical format (AND/OR/NOT) to user's configured syntax.
 *
 * @param booleanString - Boolean string in canonical format
 * @param config - User's boolean syntax configuration
 * @returns Transformed string with user's preferred operators
 */
export function transformBooleanSyntax(
  booleanString: string,
  config: BooleanSyntaxConfig
): string {
  let result = booleanString;

  // Replace operators (careful with order to avoid double-replacement)
  // Use word boundaries to avoid replacing partial matches
  if (config.andOperator !== 'AND') {
    result = result.replace(/\bAND\b/g, config.andOperator);
  }
  if (config.orOperator !== 'OR') {
    result = result.replace(/\bOR\b/g, config.orOperator);
  }
  if (config.notOperator !== 'NOT') {
    result = result.replace(/\bNOT\b/g, config.notOperator);
  }

  // Replace phrase delimiter
  if (config.phraseDelimiter !== '"') {
    result = result.replace(/"/g, config.phraseDelimiter);
  }

  // Handle grouping
  if (config.groupingStyle === 'none') {
    result = result.replace(/[()]/g, '');
  }

  return result;
}
```
  </action>
  <verify>
1. File exists: `ls src/renderer/lib/booleanSyntax.ts`
2. `npm run lint` passes
  </verify>
  <done>transformBooleanSyntax utility and DEFAULT_BOOLEAN_SYNTAX constant exist</done>
</task>

<task type="auto">
  <name>Task 3: Add boolean syntax to Settings and persistence</name>
  <files>src/renderer/routes/Settings.tsx, src/main/settingsManager.ts, src/main/ipc.ts, src/renderer/stores/usageStore.ts</files>
  <action>
**Step 1: Extend settings manager to include boolean syntax**

In `src/main/settingsManager.ts`, add booleanSyntax to the settings type and defaults:

```typescript
// Add to Settings interface (or equivalent type)
booleanSyntax?: {
  andOperator: 'AND' | '&&' | '+';
  orOperator: 'OR' | '||' | ',';
  notOperator: 'NOT' | '-' | '!';
  phraseDelimiter: '"' | "'";
  groupingStyle: 'parentheses' | 'none';
};

// Add to default settings
const defaultSettings = {
  // ... existing defaults
  booleanSyntax: {
    andOperator: 'AND',
    orOperator: 'OR',
    notOperator: 'NOT',
    phraseDelimiter: '"',
    groupingStyle: 'parentheses',
  },
};
```

**Step 2: Add booleanSyntax to usageStore**

In `src/renderer/stores/usageStore.ts`, add booleanSyntax to state:

```typescript
import type { BooleanSyntaxConfig } from '../types/jd';
import { DEFAULT_BOOLEAN_SYNTAX } from '../lib/booleanSyntax';

interface UsageState {
  // ... existing fields ...

  // Boolean syntax configuration
  booleanSyntax: BooleanSyntaxConfig;

  // Actions
  loadBooleanSyntax: () => Promise<void>;
  updateBooleanSyntax: (config: Partial<BooleanSyntaxConfig>) => Promise<void>;
}

// In create():
booleanSyntax: DEFAULT_BOOLEAN_SYNTAX,

loadBooleanSyntax: async () => {
  try {
    const result = await window.api.getAppSettings();
    if (result.success && result.data?.booleanSyntax) {
      set({ booleanSyntax: result.data.booleanSyntax });
    }
  } catch (error) {
    console.error('Failed to load boolean syntax:', error);
  }
},

updateBooleanSyntax: async (config: Partial<BooleanSyntaxConfig>) => {
  const current = get().booleanSyntax;
  const updated = { ...current, ...config };
  try {
    await window.api.updateAppSettings({ booleanSyntax: updated });
    set({ booleanSyntax: updated });
  } catch (error) {
    console.error('Failed to update boolean syntax:', error);
  }
},
```

Also update loadSettings to load booleanSyntax:
```typescript
loadSettings: async () => {
  try {
    const result = await window.api.getAppSettings();
    if (result.success && result.data) {
      set({
        globalTokenLimit: result.data.globalTokenLimit ?? null,
        warningThreshold: result.data.warningThreshold,
        llmMode: result.data.llmMode,
        booleanSyntax: result.data.booleanSyntax ?? DEFAULT_BOOLEAN_SYNTAX,
      });
    }
  } catch (error) {
    console.error('Failed to load settings:', error);
  }
},
```

**Step 3: Add Boolean Syntax card to Settings page**

In `src/renderer/routes/Settings.tsx`, add a new card after the Usage Limits card:

```tsx
import { Search } from 'lucide-react';  // Add to imports

// Add to component state
const { booleanSyntax, loadBooleanSyntax, updateBooleanSyntax } = useUsageStore();

// Add to useEffect
useEffect(() => {
  loadSettings();
  loadUsage();
  loadRecruiterSettings();
  loadBooleanSyntax();  // ADD THIS
}, [loadSettings, loadUsage, loadRecruiterSettings, loadBooleanSyntax]);

// Add after Recruiter Details Card (before closing </div>):
{/* Boolean Syntax Card */}
<Card className="bg-card border-border">
  <CardHeader>
    <CardTitle className="flex items-center gap-2">
      <Search className="h-5 w-5" />
      Boolean Search Syntax
    </CardTitle>
    <CardDescription>
      Configure operators and delimiters for boolean search strings. Different platforms use different syntax.
    </CardDescription>
  </CardHeader>
  <CardContent className="space-y-4">
    {/* AND Operator */}
    <div className="space-y-2">
      <label className="text-sm font-medium text-foreground">AND Operator</label>
      <div className="flex gap-2">
        {(['AND', '&&', '+'] as const).map((op) => (
          <Button
            key={op}
            variant={booleanSyntax.andOperator === op ? 'default' : 'outline'}
            size="sm"
            onClick={() => updateBooleanSyntax({ andOperator: op })}
          >
            {op}
          </Button>
        ))}
      </div>
    </div>

    {/* OR Operator */}
    <div className="space-y-2">
      <label className="text-sm font-medium text-foreground">OR Operator</label>
      <div className="flex gap-2">
        {(['OR', '||', ','] as const).map((op) => (
          <Button
            key={op}
            variant={booleanSyntax.orOperator === op ? 'default' : 'outline'}
            size="sm"
            onClick={() => updateBooleanSyntax({ orOperator: op })}
          >
            {op === ',' ? 'comma' : op}
          </Button>
        ))}
      </div>
    </div>

    {/* NOT Operator */}
    <div className="space-y-2">
      <label className="text-sm font-medium text-foreground">NOT Operator</label>
      <div className="flex gap-2">
        {(['NOT', '-', '!'] as const).map((op) => (
          <Button
            key={op}
            variant={booleanSyntax.notOperator === op ? 'default' : 'outline'}
            size="sm"
            onClick={() => updateBooleanSyntax({ notOperator: op })}
          >
            {op}
          </Button>
        ))}
      </div>
    </div>

    {/* Phrase Delimiter */}
    <div className="space-y-2">
      <label className="text-sm font-medium text-foreground">Phrase Delimiter</label>
      <div className="flex gap-2">
        {(['"', "'"] as const).map((delim) => (
          <Button
            key={delim}
            variant={booleanSyntax.phraseDelimiter === delim ? 'default' : 'outline'}
            size="sm"
            onClick={() => updateBooleanSyntax({ phraseDelimiter: delim })}
          >
            {delim === '"' ? 'Double quotes "' : "Single quotes '"}
          </Button>
        ))}
      </div>
    </div>

    {/* Grouping */}
    <div className="space-y-2">
      <label className="text-sm font-medium text-foreground">Grouping</label>
      <div className="flex gap-2">
        {(['parentheses', 'none'] as const).map((style) => (
          <Button
            key={style}
            variant={booleanSyntax.groupingStyle === style ? 'default' : 'outline'}
            size="sm"
            onClick={() => updateBooleanSyntax({ groupingStyle: style })}
          >
            {style === 'parentheses' ? 'Use (parentheses)' : 'No grouping'}
          </Button>
        ))}
      </div>
    </div>

    <p className="text-xs text-muted-foreground">
      Default syntax is LinkedIn-compatible. Changes are saved automatically.
    </p>
  </CardContent>
</Card>
```
  </action>
  <verify>
1. `npm run lint` passes
2. App starts and Settings page loads
3. Boolean Syntax card appears in Settings
4. Clicking buttons changes the selected option
5. Refresh the page - settings persist
  </verify>
  <done>Boolean syntax configuration exists in Settings with all operators configurable and persisting</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes
2. TypeScript types for matching metadata compile correctly
3. Settings page shows Boolean Syntax Configuration card
4. Boolean syntax changes persist across app restarts
5. transformBooleanSyntax utility correctly transforms strings
</verification>

<success_criteria>
- MatchingMetadata, ExpandedSkill, BooleanStrings, SearchHints types exist
- BooleanSyntaxConfig type exists with all operator options
- DEFAULT_BOOLEAN_SYNTAX constant defined
- transformBooleanSyntax utility works correctly
- Settings page includes Boolean Syntax Configuration card
- Boolean syntax settings persist via settings manager
</success_criteria>

<output>
After completion, create `.planning/phases/04.8-jd-matching-enhancement/04.8-03-SUMMARY.md`
</output>
