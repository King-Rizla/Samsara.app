---
phase: 09-communication-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - src/main/communicationService.ts
  - src/main/index.ts
  - src/main/preload.ts
  - src/main/database.ts
  - src/renderer/components/outreach/OutreachSection.tsx
  - src/renderer/components/outreach/CandidateTimeline.tsx
  - src/renderer/components/outreach/StatusWheel.tsx
  - src/renderer/components/outreach/SendMessageDialog.tsx
  - src/renderer/stores/outreachStore.ts
  - src/renderer/routes/ProjectLayout.tsx
autonomous: true

must_haves:
  truths:
    - "User can send an SMS to a candidate from the Outreach section"
    - "User can send an email to a candidate from the Outreach section"
    - "User sees delivery status update from sent to delivered or failed"
    - "User can view message history in a timeline for each candidate"
    - "User can add a phone or email to the DNC list manually"
    - "System checks DNC before sending and warns user"
  artifacts:
    - path: "src/main/communicationService.ts"
      provides: "SMS and email sending, delivery polling, DNC check"
      exports:
        [
          "sendSMS",
          "sendEmail",
          "pollDeliveryStatus",
          "addToDNC",
          "isOnDNC",
          "removeFromDNC",
        ]
    - path: "src/renderer/components/outreach/OutreachSection.tsx"
      provides: "Outreach wheel section with candidate list and actions"
      min_lines: 150
    - path: "src/renderer/components/outreach/CandidateTimeline.tsx"
      provides: "Timeline view of messages sent to a candidate"
      min_lines: 80
    - path: "src/renderer/stores/outreachStore.ts"
      provides: "Zustand store for outreach state and message history"
      exports: ["useOutreachStore"]
  key_links:
    - from: "src/renderer/components/outreach/SendMessageDialog.tsx"
      to: "window.api.sendSMS"
      via: "IPC invoke"
      pattern: "api\\.sendSMS"
    - from: "src/main/communicationService.ts"
      to: "twilio.messages.create"
      via: "Twilio SDK"
      pattern: "client\\.messages\\.create"
    - from: "src/main/index.ts"
      to: "pollDeliveryStatus"
      via: "setInterval"
      pattern: "setInterval.*pollDeliveryStatus"
---

<objective>
Build SMS and email sending capabilities with delivery status tracking and opt-out compliance.

Purpose: This plan completes the communication infrastructure by enabling actual message sending. Users can manually send messages to candidates and track delivery status, laying the groundwork for automated sequences in Phase 10.

Output: CommunicationService with Twilio SMS and Nodemailer email sending, delivery status polling at 1-minute intervals, DNC registry functions, OutreachSection UI replacing the wheel placeholder, CandidateTimeline for message history, SendMessageDialog for composing messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-communication-infrastructure/09-RESEARCH.md
@.planning/phases/09-communication-infrastructure/09-CONTEXT.md
@.planning/phases/09-communication-infrastructure/09-01-SUMMARY.md
@.planning/phases/09-communication-infrastructure/09-02-SUMMARY.md
@src/main/credentialManager.ts
@src/main/templateEngine.ts
@src/main/database.ts
@src/renderer/types/communication.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create communication service for SMS and email sending</name>
  <files>
    src/main/communicationService.ts
    src/main/database.ts
  </files>
  <action>
Create `src/main/communicationService.ts`:

```typescript
import Twilio from "twilio";
import nodemailer from "nodemailer";
import { getCredential } from "./credentialManager";
import { getDatabase } from "./database";
import * as crypto from "crypto";

// ============================================================================
// SMS Sending (Twilio)
// ============================================================================

interface SendSMSParams {
  projectId: string;
  cvId: string;
  toPhone: string;
  body: string;
  templateId?: string;
}

export async function sendSMS(params: SendSMSParams): Promise<{
  success: boolean;
  messageId?: string;
  dbId?: string;
  error?: string;
}> {
  // Check DNC first
  if (isOnDNC("phone", params.toPhone)) {
    return { success: false, error: "Phone number is on Do Not Contact list" };
  }

  const accountSid = getCredential(params.projectId, "twilio", "account_sid");
  const authToken = getCredential(params.projectId, "twilio", "auth_token");
  const fromNumber = getCredential(params.projectId, "twilio", "phone_number");

  if (!accountSid || !authToken || !fromNumber) {
    return { success: false, error: "Twilio credentials not configured" };
  }

  const client = new Twilio(accountSid, authToken);

  try {
    const message = await client.messages.create({
      body: params.body,
      from: fromNumber,
      to: params.toPhone,
    });

    // Log message to database
    const db = getDatabase();
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    db.prepare(
      `
      INSERT INTO messages
      (id, project_id, cv_id, type, direction, status, from_address, to_address, body, template_id, provider_message_id, sent_at, created_at)
      VALUES (?, ?, ?, 'sms', 'outbound', 'sent', ?, ?, ?, ?, ?, ?, ?)
    `,
    ).run(
      id,
      params.projectId,
      params.cvId,
      fromNumber,
      params.toPhone,
      params.body,
      params.templateId || null,
      message.sid,
      now,
      now,
    );

    return { success: true, messageId: message.sid, dbId: id };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to send SMS",
    };
  }
}

// ============================================================================
// Email Sending (Nodemailer)
// ============================================================================

interface SendEmailParams {
  projectId: string;
  cvId: string;
  toEmail: string;
  subject: string;
  body: string;
  templateId?: string;
}

export async function sendEmail(params: SendEmailParams): Promise<{
  success: boolean;
  messageId?: string;
  dbId?: string;
  error?: string;
}> {
  // Check DNC first
  if (isOnDNC("email", params.toEmail)) {
    return { success: false, error: "Email address is on Do Not Contact list" };
  }

  const smtpHost = getCredential(params.projectId, "smtp", "host");
  const smtpPort = getCredential(params.projectId, "smtp", "port");
  const smtpUser = getCredential(params.projectId, "smtp", "user");
  const smtpPassword = getCredential(params.projectId, "smtp", "password");
  const fromEmail = getCredential(params.projectId, "smtp", "from_email");

  if (!smtpHost || !smtpUser || !smtpPassword) {
    return { success: false, error: "SMTP credentials not configured" };
  }

  const transporter = nodemailer.createTransport({
    host: smtpHost,
    port: parseInt(smtpPort || "587", 10),
    secure: smtpPort === "465",
    auth: { user: smtpUser, pass: smtpPassword },
  });

  try {
    const result = await transporter.sendMail({
      from: fromEmail || smtpUser,
      to: params.toEmail,
      subject: params.subject,
      html: params.body,
      text: params.body.replace(/<[^>]*>/g, ""),
    });

    // Log message to database
    const db = getDatabase();
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    db.prepare(
      `
      INSERT INTO messages
      (id, project_id, cv_id, type, direction, status, from_address, to_address, subject, body, template_id, provider_message_id, sent_at, created_at)
      VALUES (?, ?, ?, 'email', 'outbound', 'sent', ?, ?, ?, ?, ?, ?, ?, ?)
    `,
    ).run(
      id,
      params.projectId,
      params.cvId,
      fromEmail || smtpUser,
      params.toEmail,
      params.subject,
      params.body,
      params.templateId || null,
      result.messageId,
      now,
      now,
    );

    return { success: true, messageId: result.messageId, dbId: id };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to send email",
    };
  }
}

// ============================================================================
// Delivery Status Polling
// ============================================================================

export async function pollDeliveryStatus(projectId: string): Promise<void> {
  const accountSid = getCredential(projectId, "twilio", "account_sid");
  const authToken = getCredential(projectId, "twilio", "auth_token");

  if (!accountSid || !authToken) return;

  const client = new Twilio(accountSid, authToken);
  const db = getDatabase();

  // Get messages with non-terminal status (only SMS - email doesn't have delivery tracking via Twilio)
  const pendingMessages = db
    .prepare(
      `
    SELECT id, provider_message_id FROM messages
    WHERE project_id = ? AND type = 'sms' AND status IN ('sent', 'queued')
  `,
    )
    .all(projectId) as { id: string; provider_message_id: string }[];

  for (const msg of pendingMessages) {
    if (!msg.provider_message_id) continue;

    try {
      const twilioMsg = await client.messages(msg.provider_message_id).fetch();

      let newStatus: string | null = null;
      switch (twilioMsg.status) {
        case "delivered":
          newStatus = "delivered";
          break;
        case "failed":
        case "undelivered":
          newStatus = "failed";
          break;
        // queued, sent, sending - still in progress
        default:
          continue;
      }

      if (newStatus) {
        const now = new Date().toISOString();
        db.prepare(
          `
          UPDATE messages SET status = ?, delivered_at = ?, error_message = ? WHERE id = ?
        `,
        ).run(
          newStatus,
          newStatus === "delivered" ? now : null,
          newStatus === "failed" ? twilioMsg.errorMessage : null,
          msg.id,
        );
      }
    } catch (error) {
      console.error(`Failed to poll status for message ${msg.id}:`, error);
    }
  }
}

// Polling management
let pollingInterval: NodeJS.Timeout | null = null;
let currentPollingProjectId: string | null = null;

export function startDeliveryPolling(projectId: string): void {
  if (pollingInterval) {
    clearInterval(pollingInterval);
  }

  currentPollingProjectId = projectId;
  pollingInterval = setInterval(() => {
    if (currentPollingProjectId) {
      pollDeliveryStatus(currentPollingProjectId);
    }
  }, 60000); // Every 60 seconds per CONTEXT.md

  // Run immediately once
  pollDeliveryStatus(projectId);
}

export function stopDeliveryPolling(): void {
  if (pollingInterval) {
    clearInterval(pollingInterval);
    pollingInterval = null;
    currentPollingProjectId = null;
  }
}

// ============================================================================
// DNC (Do Not Contact) Registry
// ============================================================================

function normalizeContactValue(type: "phone" | "email", value: string): string {
  if (type === "phone") {
    return value.replace(/[^\d+]/g, "");
  }
  return value.toLowerCase().trim();
}

export function addToDNC(
  type: "phone" | "email",
  value: string,
  reason: "opt_out" | "bounce" | "manual",
  sourceMessageId?: string,
): string {
  const db = getDatabase();
  const id = crypto.randomUUID();
  const now = new Date().toISOString();
  const normalized = normalizeContactValue(type, value);

  db.prepare(
    `
    INSERT OR IGNORE INTO dnc_registry (id, type, value, reason, source_message_id, created_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `,
  ).run(id, type, normalized, reason, sourceMessageId || null, now);

  return id;
}

export function isOnDNC(type: "phone" | "email", value: string): boolean {
  const db = getDatabase();
  const normalized = normalizeContactValue(type, value);
  const row = db
    .prepare(
      `
    SELECT id FROM dnc_registry WHERE type = ? AND value = ?
  `,
    )
    .get(type, normalized);
  return !!row;
}

export function removeFromDNC(type: "phone" | "email", value: string): boolean {
  const db = getDatabase();
  const normalized = normalizeContactValue(type, value);
  const result = db
    .prepare(
      `
    DELETE FROM dnc_registry WHERE type = ? AND value = ?
  `,
    )
    .run(type, normalized);
  return result.changes > 0;
}

export function getDNCList(): Array<{
  id: string;
  type: string;
  value: string;
  reason: string;
  createdAt: string;
}> {
  const db = getDatabase();
  return db
    .prepare(
      `
    SELECT id, type, value, reason, created_at as createdAt FROM dnc_registry ORDER BY created_at DESC
  `,
    )
    .all() as Array<{
    id: string;
    type: string;
    value: string;
    reason: string;
    createdAt: string;
  }>;
}
```

Add message query functions to `database.ts`:

```typescript
// ============================================================================
// Message Query Functions (Phase 9)
// ============================================================================

export interface MessageRecord {
  id: string;
  project_id: string;
  cv_id: string | null;
  type: string;
  direction: string;
  status: string;
  from_address: string | null;
  to_address: string;
  subject: string | null;
  body: string;
  template_id: string | null;
  provider_message_id: string | null;
  error_message: string | null;
  sent_at: string | null;
  delivered_at: string | null;
  created_at: string;
}

export function getMessagesByCV(cvId: string): MessageRecord[] {
  const database = getDatabase();
  return database
    .prepare(
      `
    SELECT * FROM messages WHERE cv_id = ? ORDER BY created_at DESC
  `,
    )
    .all(cvId) as MessageRecord[];
}

export function getMessagesByProject(
  projectId: string,
  limit = 50,
): MessageRecord[] {
  const database = getDatabase();
  return database
    .prepare(
      `
    SELECT * FROM messages WHERE project_id = ? ORDER BY created_at DESC LIMIT ?
  `,
    )
    .all(projectId, limit) as MessageRecord[];
}

export function getMessage(id: string): MessageRecord | null {
  const database = getDatabase();
  return (
    (database.prepare("SELECT * FROM messages WHERE id = ?").get(id) as
      | MessageRecord
      | undefined) ?? null
  );
}

export function updateMessageStatus(
  id: string,
  status: string,
  errorMessage?: string,
): boolean {
  const database = getDatabase();
  const now = new Date().toISOString();
  const result = database
    .prepare(
      `
    UPDATE messages SET status = ?, error_message = ?, delivered_at = ? WHERE id = ?
  `,
    )
    .run(status, errorMessage || null, status === "delivered" ? now : null, id);
  return result.changes > 0;
}
```

  </action>
  <verify>
- `npx tsc --noEmit` passes
- communicationService.ts exports sendSMS, sendEmail, pollDeliveryStatus, startDeliveryPolling, stopDeliveryPolling, addToDNC, isOnDNC, removeFromDNC, getDNCList
  </verify>
  <done>
- SMS sending via Twilio implemented with DNC check
- Email sending via Nodemailer implemented with DNC check
- Delivery status polling at 1-minute intervals
- DNC registry functions for opt-out management
- Message logging to database on send
  </done>
</task>

<task type="auto">
  <name>Task 2: Add IPC handlers for messaging and DNC</name>
  <files>
    src/main/index.ts
    src/main/preload.ts
  </files>
  <action>
Add IPC handlers to `index.ts`:

```typescript
import {
  sendSMS,
  sendEmail,
  startDeliveryPolling,
  stopDeliveryPolling,
  addToDNC,
  isOnDNC,
  removeFromDNC,
  getDNCList,
} from "./communicationService";
import {
  getMessagesByCV,
  getMessagesByProject,
  renderTemplate,
} from "./database";
import { renderTemplate as render } from "./templateEngine";

// Messaging IPC handlers
ipcMain.handle(
  "send-sms",
  async (
    _event,
    params: {
      projectId: string;
      cvId: string;
      toPhone: string;
      body: string;
      templateId?: string;
    },
  ) => {
    return sendSMS(params);
  },
);

ipcMain.handle(
  "send-email",
  async (
    _event,
    params: {
      projectId: string;
      cvId: string;
      toEmail: string;
      subject: string;
      body: string;
      templateId?: string;
    },
  ) => {
    return sendEmail(params);
  },
);

ipcMain.handle("get-messages-by-cv", async (_event, cvId: string) => {
  try {
    const messages = getMessagesByCV(cvId);
    return { success: true, data: messages };
  } catch (error) {
    return { success: false, error: String(error) };
  }
});

ipcMain.handle(
  "get-messages-by-project",
  async (_event, projectId: string, limit?: number) => {
    try {
      const messages = getMessagesByProject(projectId, limit);
      return { success: true, data: messages };
    } catch (error) {
      return { success: false, error: String(error) };
    }
  },
);

// DNC IPC handlers
ipcMain.handle(
  "add-to-dnc",
  async (
    _event,
    type: "phone" | "email",
    value: string,
    reason: "opt_out" | "bounce" | "manual",
  ) => {
    try {
      const id = addToDNC(type, value, reason);
      return { success: true, id };
    } catch (error) {
      return { success: false, error: String(error) };
    }
  },
);

ipcMain.handle(
  "check-dnc",
  async (_event, type: "phone" | "email", value: string) => {
    return { onDNC: isOnDNC(type, value) };
  },
);

ipcMain.handle(
  "remove-from-dnc",
  async (_event, type: "phone" | "email", value: string) => {
    try {
      const removed = removeFromDNC(type, value);
      return { success: true, removed };
    } catch (error) {
      return { success: false, error: String(error) };
    }
  },
);

ipcMain.handle("get-dnc-list", async () => {
  try {
    const list = getDNCList();
    return { success: true, data: list };
  } catch (error) {
    return { success: false, error: String(error) };
  }
});

// Polling control IPC handlers
ipcMain.handle("start-delivery-polling", async (_event, projectId: string) => {
  startDeliveryPolling(projectId);
  return { success: true };
});

ipcMain.handle("stop-delivery-polling", async () => {
  stopDeliveryPolling();
  return { success: true };
});

// Render template with real variables (for send preview)
ipcMain.handle(
  "render-template-with-variables",
  async (_event, template: string, variables: Record<string, string>) => {
    try {
      const rendered = render(template, variables);
      return { success: true, data: rendered };
    } catch (error) {
      return { success: false, error: String(error) };
    }
  },
);
```

Add preload API:

```typescript
// Messaging operations (Phase 9)

sendSMS: (params: {
  projectId: string;
  cvId: string;
  toPhone: string;
  body: string;
  templateId?: string;
}): Promise<{ success: boolean; messageId?: string; dbId?: string; error?: string }> =>
  ipcRenderer.invoke('send-sms', params),

sendEmail: (params: {
  projectId: string;
  cvId: string;
  toEmail: string;
  subject: string;
  body: string;
  templateId?: string;
}): Promise<{ success: boolean; messageId?: string; dbId?: string; error?: string }> =>
  ipcRenderer.invoke('send-email', params),

getMessagesByCV: (cvId: string): Promise<{ success: boolean; data?: unknown[]; error?: string }> =>
  ipcRenderer.invoke('get-messages-by-cv', cvId),

getMessagesByProject: (projectId: string, limit?: number): Promise<{ success: boolean; data?: unknown[]; error?: string }> =>
  ipcRenderer.invoke('get-messages-by-project', projectId, limit),

// DNC operations (Phase 9)

addToDNC: (type: 'phone' | 'email', value: string, reason: 'opt_out' | 'bounce' | 'manual'): Promise<{ success: boolean; id?: string; error?: string }> =>
  ipcRenderer.invoke('add-to-dnc', type, value, reason),

checkDNC: (type: 'phone' | 'email', value: string): Promise<{ onDNC: boolean }> =>
  ipcRenderer.invoke('check-dnc', type, value),

removeFromDNC: (type: 'phone' | 'email', value: string): Promise<{ success: boolean; removed?: boolean; error?: string }> =>
  ipcRenderer.invoke('remove-from-dnc', type, value),

getDNCList: (): Promise<{ success: boolean; data?: Array<{ id: string; type: string; value: string; reason: string; createdAt: string }>; error?: string }> =>
  ipcRenderer.invoke('get-dnc-list'),

// Polling control (Phase 9)

startDeliveryPolling: (projectId: string): Promise<{ success: boolean }> =>
  ipcRenderer.invoke('start-delivery-polling', projectId),

stopDeliveryPolling: (): Promise<{ success: boolean }> =>
  ipcRenderer.invoke('stop-delivery-polling'),

// Template rendering with real variables
renderTemplateWithVariables: (template: string, variables: Record<string, string>): Promise<{ success: boolean; data?: string; error?: string }> =>
  ipcRenderer.invoke('render-template-with-variables', template, variables),
```

  </action>
  <verify>
- `npx tsc --noEmit` passes
- IPC handlers registered for all messaging and DNC operations
  </verify>
  <done>
- 12 new IPC handlers for messaging, DNC, and polling
- Preload exposes all messaging APIs
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Outreach UI components and store</name>
  <files>
    src/renderer/stores/outreachStore.ts
    src/renderer/components/outreach/OutreachSection.tsx
    src/renderer/components/outreach/CandidateTimeline.tsx
    src/renderer/components/outreach/StatusWheel.tsx
    src/renderer/components/outreach/SendMessageDialog.tsx
    src/renderer/components/sections/PlaceholderSection.tsx
    src/renderer/types/communication.ts
  </files>
  <action>
Add types to `src/renderer/types/communication.ts`:

```typescript
// Message types
export interface Message {
  id: string;
  projectId: string;
  cvId: string | null;
  type: "sms" | "email";
  direction: "outbound" | "inbound";
  status: "queued" | "sent" | "delivered" | "failed" | "received";
  fromAddress: string | null;
  toAddress: string;
  subject: string | null;
  body: string;
  templateId: string | null;
  providerMessageId: string | null;
  errorMessage: string | null;
  sentAt: string | null;
  deliveredAt: string | null;
  createdAt: string;
}

export interface DNCEntry {
  id: string;
  type: "phone" | "email";
  value: string;
  reason: "opt_out" | "bounce" | "manual";
  createdAt: string;
}

export interface OutreachCandidate {
  cvId: string;
  name: string;
  email?: string;
  phone?: string;
  lastMessageAt?: string;
  messageCount: number;
  status: "pending" | "contacted" | "responded" | "opted_out";
}
```

Create `src/renderer/stores/outreachStore.ts`:

```typescript
import { create } from "zustand";
import type {
  Message,
  DNCEntry,
  OutreachCandidate,
} from "../types/communication";

interface OutreachState {
  candidates: OutreachCandidate[];
  selectedCandidateId: string | null;
  messages: Message[];
  dncList: DNCEntry[];
  isLoading: boolean;
  isSending: boolean;

  // Actions
  setCandidates: (candidates: OutreachCandidate[]) => void;
  selectCandidate: (cvId: string | null) => void;
  setMessages: (messages: Message[]) => void;
  addMessage: (message: Message) => void;
  updateMessageStatus: (
    id: string,
    status: Message["status"],
    errorMessage?: string,
  ) => void;
  setDNCList: (list: DNCEntry[]) => void;

  // Async actions
  loadMessagesForCandidate: (cvId: string) => Promise<void>;
  loadDNCList: () => Promise<void>;
  sendSMS: (params: {
    projectId: string;
    cvId: string;
    toPhone: string;
    body: string;
    templateId?: string;
  }) => Promise<boolean>;
  sendEmail: (params: {
    projectId: string;
    cvId: string;
    toEmail: string;
    subject: string;
    body: string;
    templateId?: string;
  }) => Promise<boolean>;
  addToDNC: (
    type: "phone" | "email",
    value: string,
    reason: "manual",
  ) => Promise<boolean>;
  checkDNC: (type: "phone" | "email", value: string) => Promise<boolean>;
}

export const useOutreachStore = create<OutreachState>((set, get) => ({
  candidates: [],
  selectedCandidateId: null,
  messages: [],
  dncList: [],
  isLoading: false,
  isSending: false,

  setCandidates: (candidates) => set({ candidates }),
  selectCandidate: (cvId) => set({ selectedCandidateId: cvId }),
  setMessages: (messages) => set({ messages }),
  addMessage: (message) =>
    set((state) => ({ messages: [message, ...state.messages] })),
  updateMessageStatus: (id, status, errorMessage) =>
    set((state) => ({
      messages: state.messages.map((m) =>
        m.id === id ? { ...m, status, errorMessage } : m,
      ),
    })),
  setDNCList: (list) => set({ dncList: list }),

  loadMessagesForCandidate: async (cvId) => {
    set({ isLoading: true });
    const result = await window.api.getMessagesByCV(cvId);
    if (result.success && result.data) {
      set({ messages: result.data as Message[], isLoading: false });
    } else {
      set({ isLoading: false });
    }
  },

  loadDNCList: async () => {
    const result = await window.api.getDNCList();
    if (result.success && result.data) {
      set({ dncList: result.data as DNCEntry[] });
    }
  },

  sendSMS: async (params) => {
    set({ isSending: true });
    const result = await window.api.sendSMS(params);
    set({ isSending: false });
    if (result.success && result.dbId) {
      // Reload messages to show the new one
      get().loadMessagesForCandidate(params.cvId);
      return true;
    }
    return false;
  },

  sendEmail: async (params) => {
    set({ isSending: true });
    const result = await window.api.sendEmail(params);
    set({ isSending: false });
    if (result.success && result.dbId) {
      get().loadMessagesForCandidate(params.cvId);
      return true;
    }
    return false;
  },

  addToDNC: async (type, value, reason) => {
    const result = await window.api.addToDNC(type, value, reason);
    if (result.success) {
      get().loadDNCList();
      return true;
    }
    return false;
  },

  checkDNC: async (type, value) => {
    const result = await window.api.checkDNC(type, value);
    return result.onDNC;
  },
}));
```

Create `src/renderer/components/outreach/CandidateTimeline.tsx`:

```typescript
// Timeline showing messages sent to a candidate
// - Each message shows: type icon (SMS/Email), status badge, timestamp, preview
// - Color coding: blue (sent), green (delivered), red (failed)
// - Click to expand and see full message
// - Empty state: "No messages sent to this candidate yet"
```

Create `src/renderer/components/outreach/StatusWheel.tsx`:

```typescript
// Small visual progress indicator per candidate
// - Shows completion through outreach sequence
// - 1/3 filled = SMS sent, 2/3 = email sent, full = call completed
// - Colors: blue for in-progress, green for completed stages
// - Simple SVG arc or progress circle
```

Create `src/renderer/components/outreach/SendMessageDialog.tsx`:

```typescript
// Dialog for composing and sending a message
// - Tabs: SMS / Email
// - Template selector dropdown (loads from templateStore)
// - Recipient display (phone/email from candidate)
// - DNC warning banner if recipient is on DNC list
// - For SMS: character count, segment estimate
// - For Email: subject line input
// - Body textarea with template applied (can edit before send)
// - Preview rendered with candidate data
// - Send button (disabled if DNC or missing credentials)
// - Shows success/error toast after send
```

Create `src/renderer/components/outreach/OutreachSection.tsx`:

```typescript
// Replaces PlaceholderSection for the Outreach wheel wedge
// Layout:
// - Left panel: List of candidates in outreach pipeline
// - Right panel: Selected candidate's timeline + actions
//
// Candidate list:
// - Shows candidates that have been "graduated" to outreach (for now, all CVs with contact info)
// - Each row: name, status badge, StatusWheel, last message time
// - Click to select and view timeline
//
// Selected candidate panel:
// - Header: candidate name, contact info
// - Action buttons: Send SMS, Send Email, Add to DNC
// - CandidateTimeline showing message history
// - DNC badge if candidate is on DNC list
//
// Start delivery polling on mount, stop on unmount
```

Update PlaceholderSection to handle Outreach section differently (or remove the Outreach case since OutreachSection handles it).

Wire up in routing: The Outreach wheel section should navigate to OutreachSection instead of PlaceholderSection.
</action>
<verify>

- `npx tsc --noEmit` passes
- `npx vitest run` passes
- OutreachSection, CandidateTimeline, StatusWheel, SendMessageDialog all export
  </verify>
  <done>
- OutreachSection displays candidates in outreach pipeline
- CandidateTimeline shows message history per candidate
- SendMessageDialog allows composing and sending messages
- DNC warnings display when recipient is on DNC list
- Delivery polling starts when viewing Outreach section
  </done>
  </task>

</tasks>

<verification>
1. Navigate to a project, click Outreach in the Samsara Wheel
2. See list of candidates with contact info
3. Select a candidate, click "Send SMS"
4. Choose a template (or type custom message), see preview
5. Send message (requires valid Twilio credentials)
6. See message appear in timeline with "sent" status
7. Wait 1 minute, see status potentially update to "delivered"
8. Add a phone number to DNC list manually
9. Try to send to that number, see DNC warning
10. `npx tsc --noEmit` passes
11. `npx vitest run` passes
</verification>

<success_criteria>

- User can send SMS and email from the Outreach section
- Messages are logged to database and appear in candidate timeline
- Delivery status updates via polling (for SMS)
- DNC check prevents sending to opted-out contacts
- DNC list can be managed manually
- Outreach section replaces placeholder in Samsara Wheel
  </success_criteria>

<output>
After completion, create `.planning/phases/09-communication-infrastructure/09-03-SUMMARY.md`
</output>
