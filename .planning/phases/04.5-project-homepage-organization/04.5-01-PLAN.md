---
phase: 04.5-project-homepage-organization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/database.ts
autonomous: true

must_haves:
  truths:
    - "Projects table exists with id, name, client_name, description, is_archived, created_at, updated_at"
    - "CVs table has project_id column with foreign key to projects"
    - "Job descriptions table has project_id column with foreign key to projects"
    - "Default Project is created for existing orphaned CVs/JDs"
    - "Schema version tracked via PRAGMA user_version"
  artifacts:
    - path: "src/main/database.ts"
      provides: "Schema migration, project CRUD functions"
      contains: "CREATE TABLE IF NOT EXISTS projects"
  key_links:
    - from: "cvs.project_id"
      to: "projects.id"
      via: "FOREIGN KEY with ON DELETE CASCADE"
    - from: "job_descriptions.project_id"
      to: "projects.id"
      via: "FOREIGN KEY with ON DELETE CASCADE"
---

<objective>
Add projects table and schema migration to SQLite database.

Purpose: Enable data isolation by project - CVs and JDs belong to specific projects. This is the foundational database layer for multi-project workflow.

Output: Database schema with projects table, project_id columns on cvs/job_descriptions, migration logic, and project CRUD functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.5-project-homepage-organization/04.5-RESEARCH.md
@src/main/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add projects table and schema migration</name>
  <files>src/main/database.ts</files>
  <action>
Add schema versioning and migration to `initDatabase()`:

1. After existing table creation, add version check:
```typescript
// Enable foreign keys (must be set per connection)
db.pragma('foreign_keys = ON');

// Schema versioning and migrations
const version = db.pragma('user_version', { simple: true }) as number;

if (version < 1) {
  console.log('Migrating database to version 1 (projects)...');

  // Projects table
  db.exec(`
    CREATE TABLE IF NOT EXISTS projects (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      client_name TEXT,
      description TEXT,
      is_archived INTEGER DEFAULT 0,
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL
    );
  `);

  // Add project_id to cvs (nullable for existing data migration)
  // SQLite doesn't support adding FK constraints via ALTER TABLE, so we add nullable column
  db.exec(`ALTER TABLE cvs ADD COLUMN project_id TEXT`);
  db.exec(`ALTER TABLE job_descriptions ADD COLUMN project_id TEXT`);

  // Create indexes for project filtering
  db.exec(`CREATE INDEX IF NOT EXISTS idx_cvs_project ON cvs(project_id)`);
  db.exec(`CREATE INDEX IF NOT EXISTS idx_jds_project ON job_descriptions(project_id)`);

  // Create Default Project for orphaned data
  const defaultProjectId = 'default-project';
  const now = new Date().toISOString();
  db.prepare(`
    INSERT OR IGNORE INTO projects (id, name, client_name, description, is_archived, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `).run(defaultProjectId, 'Default Project', null, 'Auto-created for existing CVs and JDs', 0, now, now);

  // Migrate existing CVs/JDs to Default Project
  db.exec(`UPDATE cvs SET project_id = 'default-project' WHERE project_id IS NULL`);
  db.exec(`UPDATE job_descriptions SET project_id = 'default-project' WHERE project_id IS NULL`);

  db.pragma('user_version = 1');
  console.log('Database migrated to version 1');
}
```

IMPORTANT: Place this migration AFTER the existing CREATE TABLE statements for cvs and job_descriptions, but BEFORE the app_meta timestamp update.
  </action>
  <verify>
- App launches without database errors
- SQLite has user_version = 1
- Projects table exists with correct schema
- cvs and job_descriptions tables have project_id column
- Default Project exists with id 'default-project'
  </verify>
  <done>Schema migration creates projects table and adds project_id to CVs/JDs with Default Project for orphaned data</done>
</task>

<task type="auto">
  <name>Task 2: Add project CRUD functions</name>
  <files>src/main/database.ts</files>
  <action>
Add TypeScript interfaces and CRUD functions for projects:

1. Add Project interfaces after existing interfaces:
```typescript
// ============================================================================
// Project Types and CRUD
// ============================================================================

export interface ProjectRecord {
  id: string;
  name: string;
  client_name: string | null;
  description: string | null;
  is_archived: number;  // SQLite stores as 0/1
  created_at: string;
  updated_at: string;
}

export interface ProjectSummary {
  id: string;
  name: string;
  client_name: string | null;
  description: string | null;
  is_archived: boolean;
  created_at: string;
  updated_at: string;
  cv_count: number;
  jd_count: number;
}

export interface CreateProjectInput {
  name: string;
  client_name?: string;
  description?: string;
}
```

2. Add CRUD functions:
```typescript
/**
 * Create a new project.
 * Returns the created project record.
 */
export function createProject(input: CreateProjectInput): ProjectRecord {
  const database = getDatabase();
  const id = crypto.randomUUID();
  const now = new Date().toISOString();

  const stmt = database.prepare(`
    INSERT INTO projects (id, name, client_name, description, is_archived, created_at, updated_at)
    VALUES (?, ?, ?, ?, 0, ?, ?)
  `);
  stmt.run(id, input.name, input.client_name || null, input.description || null, now, now);

  console.log(`Created project with ID: ${id}`);
  return {
    id,
    name: input.name,
    client_name: input.client_name || null,
    description: input.description || null,
    is_archived: 0,
    created_at: now,
    updated_at: now,
  };
}

/**
 * Get all projects with CV/JD counts.
 * Excludes archived projects by default.
 */
export function getAllProjects(includeArchived = false): ProjectSummary[] {
  const database = getDatabase();

  const whereClause = includeArchived ? '' : 'WHERE p.is_archived = 0';

  const stmt = database.prepare(`
    SELECT
      p.id, p.name, p.client_name, p.description, p.is_archived, p.created_at, p.updated_at,
      (SELECT COUNT(*) FROM cvs WHERE project_id = p.id) as cv_count,
      (SELECT COUNT(*) FROM job_descriptions WHERE project_id = p.id) as jd_count
    FROM projects p
    ${whereClause}
    ORDER BY p.updated_at DESC
  `);

  const rows = stmt.all() as (ProjectRecord & { cv_count: number; jd_count: number })[];

  return rows.map(row => ({
    ...row,
    is_archived: Boolean(row.is_archived),
  }));
}

/**
 * Get a single project by ID.
 */
export function getProject(id: string): ProjectSummary | null {
  const database = getDatabase();

  const row = database.prepare(`
    SELECT
      p.id, p.name, p.client_name, p.description, p.is_archived, p.created_at, p.updated_at,
      (SELECT COUNT(*) FROM cvs WHERE project_id = p.id) as cv_count,
      (SELECT COUNT(*) FROM job_descriptions WHERE project_id = p.id) as jd_count
    FROM projects p
    WHERE p.id = ?
  `).get(id) as (ProjectRecord & { cv_count: number; jd_count: number }) | undefined;

  if (!row) return null;

  return {
    ...row,
    is_archived: Boolean(row.is_archived),
  };
}

/**
 * Update a project.
 */
export function updateProject(id: string, updates: Partial<CreateProjectInput & { is_archived: boolean }>): boolean {
  const database = getDatabase();
  const now = new Date().toISOString();

  const fields: string[] = ['updated_at = ?'];
  const values: unknown[] = [now];

  if (updates.name !== undefined) {
    fields.push('name = ?');
    values.push(updates.name);
  }
  if (updates.client_name !== undefined) {
    fields.push('client_name = ?');
    values.push(updates.client_name);
  }
  if (updates.description !== undefined) {
    fields.push('description = ?');
    values.push(updates.description);
  }
  if (updates.is_archived !== undefined) {
    fields.push('is_archived = ?');
    values.push(updates.is_archived ? 1 : 0);
  }

  values.push(id);

  const stmt = database.prepare(`UPDATE projects SET ${fields.join(', ')} WHERE id = ?`);
  const result = stmt.run(...values);

  return result.changes > 0;
}

/**
 * Delete a project and all its CVs, JDs, and match results.
 * Returns true if deleted.
 */
export function deleteProject(id: string): boolean {
  const database = getDatabase();

  // First delete all CVs (cascades to cv_jd_matches)
  database.prepare('DELETE FROM cvs WHERE project_id = ?').run(id);

  // Delete all JDs (cascades to cv_jd_matches)
  database.prepare('DELETE FROM job_descriptions WHERE project_id = ?').run(id);

  // Delete the project
  const result = database.prepare('DELETE FROM projects WHERE id = ?').run(id);

  return result.changes > 0;
}

/**
 * Get aggregate stats across all projects.
 */
export function getAggregateStats(): { total_cvs: number; total_jds: number } {
  const database = getDatabase();

  const cvCount = database.prepare('SELECT COUNT(*) as count FROM cvs').get() as { count: number };
  const jdCount = database.prepare('SELECT COUNT(*) as count FROM job_descriptions').get() as { count: number };

  return {
    total_cvs: cvCount.count,
    total_jds: jdCount.count,
  };
}
```

3. Modify getAllCVs and getAllJDs to accept optional projectId filter:
```typescript
export function getAllCVs(projectId?: string): CVSummary[] {
  const database = getDatabase();

  let query = `
    SELECT id, file_name, contact_json, parse_confidence, created_at
    FROM cvs
  `;

  const params: unknown[] = [];
  if (projectId) {
    query += ' WHERE project_id = ?';
    params.push(projectId);
  }

  query += ' ORDER BY created_at DESC';

  const stmt = database.prepare(query);
  return params.length ? stmt.all(...params) as CVSummary[] : stmt.all() as CVSummary[];
}
```

Apply the same pattern to getAllJDs.
  </action>
  <verify>
- TypeScript compiles without errors
- All CRUD functions exist: createProject, getAllProjects, getProject, updateProject, deleteProject, getAggregateStats
- getAllCVs and getAllJDs accept optional projectId parameter
  </verify>
  <done>Project CRUD functions and projectId filtering on getAllCVs/getAllJDs work correctly</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. App launches and database migrates successfully (check console logs)
3. Run `sqlite3 ~/.config/samsara/samsara.db ".schema projects"` to verify table structure
4. Verify default-project exists: `sqlite3 ~/.config/samsara/samsara.db "SELECT * FROM projects"`
</verification>

<success_criteria>
- Database schema version is 1
- Projects table exists with all required columns
- CVs and JDs have project_id column populated with 'default-project' for existing records
- Project CRUD functions work (createProject, getAllProjects, getProject, updateProject, deleteProject)
- getAllCVs and getAllJDs can filter by projectId
</success_criteria>

<output>
After completion, create `.planning/phases/04.5-project-homepage-organization/04.5-01-SUMMARY.md`
</output>
