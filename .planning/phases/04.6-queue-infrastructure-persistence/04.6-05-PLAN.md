---
phase: 04.6-queue-infrastructure-persistence
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - python-src/main.py
  - src/main/pythonManager.ts
  - src/main/queueManager.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Timeout starts when Python begins processing, not when request is submitted"
    - "Python sends ACK immediately when it starts processing a CV"
    - "QueueManager only starts timeout after receiving processing-started ACK"
    - "No redundant timeouts - single timeout in QueueManager, none in sendToPython for extractCV"
  artifacts:
    - path: "python-src/main.py"
      provides: "Processing started ACK message before LLM extraction"
      contains: "processing_started"
    - path: "src/main/pythonManager.ts"
      provides: "ACK callback mechanism, no internal timeout for extractCV"
      exports: ["extractCV"]
    - path: "src/main/queueManager.ts"
      provides: "Timeout started on ACK, not on processNext()"
      contains: "onProcessingStarted"
  key_links:
    - from: "python-src/main.py"
      to: "pythonManager.ts"
      via: "processing_started JSON message on stdout"
      pattern: "processing_started"
    - from: "pythonManager.ts"
      to: "queueManager.ts"
      via: "onProcessingStarted callback"
      pattern: "onProcessingStarted"
---

<objective>
Fix the timeout bug: timeout should start when Python BEGINS processing, not when the request is submitted to the queue.

Purpose: CVs waiting in the queue should get their full 120 seconds of processing time, not have that time eaten up by queue wait time. Also eliminates redundant double timeout (QueueManager 120s + sendToPython 120s).

Output: Modified Python sidecar and QueueManager that coordinate timeout via processing-started ACK, with single clear timeout boundary.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.6-queue-infrastructure-persistence/04.6-VERIFICATION.md

# Key files to modify
@python-src/main.py
@src/main/pythonManager.ts
@src/main/queueManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Python ACK message on processing start</name>
  <files>python-src/main.py</files>
  <action>
Modify the `extract_cv` action handler to send an immediate ACK message BEFORE starting the actual extraction work.

In the `extract_cv` handler (around line 159), right after validating file_path exists and BEFORE calling parse_document():

```python
if action == 'extract_cv':
    file_path = request.get('file_path')
    if not file_path:
        return {
            'id': request_id,
            'success': False,
            'error': 'Missing required parameter: file_path'
        }

    # NEW: Send ACK immediately - tells caller we are NOW starting processing
    # This allows QueueManager to start timeout from this moment, not submission time
    print(json.dumps({
        "type": "ack",
        "event": "processing_started",
        "id": request_id
    }), flush=True)

    try:
        start_time = time.perf_counter()

        # First parse the document (existing code continues)
        parse_result = parse_document(file_path)
        # ... rest unchanged
```

Key points:
- Message format: `{"type": "ack", "event": "processing_started", "id": "req-N-timestamp"}`
- Send BEFORE parse_document() is called (line 172)
- flush=True ensures immediate delivery (no buffering)
- Do NOT modify the final response - only add this ACK before processing starts
  </action>
  <verify>
Test Python directly:
```bash
cd python-src && echo '{"action":"extract_cv","file_path":"nonexistent.pdf","id":"test-1"}' | python main.py 2>/dev/null | head -1
```
First line of output should be the ACK: `{"type": "ack", "event": "processing_started", "id": "test-1"}`
  </verify>
  <done>
Python sends `{"type": "ack", "event": "processing_started", "id": "..."}` immediately when extract_cv begins, before any file parsing or LLM calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: pythonManager ACK callback with no internal timeout for extractCV</name>
  <files>src/main/pythonManager.ts</files>
  <action>
Modify pythonManager to handle ACK callbacks and eliminate redundant timeout for extractCV:

1. **Update pendingRequests Map type** (around line 19):
```typescript
const pendingRequests = new Map<string, {
  resolve: (value: unknown) => void;
  reject: (reason: Error) => void;
  timeout: NodeJS.Timeout | null;  // Changed: can be null
  onAck?: (event: string) => void;  // NEW: optional ACK callback
}>();
```

2. **Handle ACK messages in readline 'line' handler** (around line 95):
```typescript
readlineInterface.on('line', (line: string) => {
  try {
    const response = JSON.parse(line);

    // Handle status messages (no request id)
    if (response.status) {
      console.log('Python status:', response.status);
      return;
    }

    // NEW: Handle ACK messages - type: 'ack' with event
    if (response.type === 'ack' && response.id) {
      const pending = pendingRequests.get(response.id);
      if (pending && pending.onAck) {
        pending.onAck(response.event);
      }
      return;  // ACK is not the final response - keep waiting
    }

    // Handle request responses (existing code)
    const pending = pendingRequests.get(response.id);
    if (pending) {
      if (pending.timeout) clearTimeout(pending.timeout);  // Updated null check
      pendingRequests.delete(response.id);
      if (response.success) {
        pending.resolve(response.data);
      } else {
        pending.reject(new Error(response.error || 'Unknown error'));
      }
    }
  } catch (e) {
    console.error('Invalid JSON from Python:', line);
  }
});
```

3. **Update sendToPython signature** (around line 141):
```typescript
export function sendToPython(
  request: object,
  timeoutMs = 30000,
  onAck?: (event: string) => void  // NEW parameter
): Promise<unknown> {
  return new Promise((resolve, reject) => {
    if (!pythonProcess || !pythonProcess.stdin) {
      reject(new Error('Python process not running'));
      return;
    }

    const id = generateRequestId();
    const requestWithId = { ...request, id };

    // Only set timeout if timeoutMs > 0
    const timeout = timeoutMs > 0 ? setTimeout(() => {
      pendingRequests.delete(id);
      reject(new Error(`Request ${id} timed out after ${timeoutMs}ms`));
    }, timeoutMs) : null;

    pendingRequests.set(id, { resolve, reject, timeout, onAck });

    pythonProcess.stdin.write(JSON.stringify(requestWithId) + '\n');
  });
}
```

4. **Update pythonProcess exit handler** to handle null timeouts (around line 82):
```typescript
// Reject all pending requests
for (const [id, pending] of pendingRequests) {
  if (pending.timeout) clearTimeout(pending.timeout);  // Updated null check
  pending.reject(new Error('Python process exited'));
}
```

5. **Update extractCV to use callback with NO internal timeout** (around line 219):
```typescript
export async function extractCV(
  filePath: string,
  onProcessingStarted?: () => void  // NEW optional callback
): Promise<unknown> {
  if (!pythonReady) {
    throw new Error('Python sidecar is not ready');
  }

  // Pass 0 for timeout - QueueManager handles timeout after ACK
  // Pass callback that fires when Python sends processing_started ACK
  const result = await sendToPython({
    action: 'extract_cv',
    file_path: filePath
  }, 0, onProcessingStarted ? (event) => {  // 0 = no internal timeout
    if (event === 'processing_started') {
      onProcessingStarted();
    }
  } : undefined);

  return result;
}
```

This eliminates the redundant 120s timeout in sendToPython - QueueManager is now the ONLY place that manages timeout for CV extraction.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit
```
Confirm extractCV now has optional onProcessingStarted parameter and passes 0 for timeout.
  </verify>
  <done>
extractCV accepts onProcessingStarted callback, passes 0 timeout to sendToPython (no internal timeout), pythonManager handles ACK messages and invokes callback without resolving promise.
  </done>
</task>

<task type="auto">
  <name>Task 3: QueueManager starts timeout ONLY on ACK</name>
  <files>src/main/queueManager.ts</files>
  <action>
Refactor processNext() to start timeout ONLY after receiving the processing_started ACK from Python:

1. **Import extractCV correctly** - the import at line 15 should already work, but ensure it's importing the updated function.

2. **Refactor processNext() method** (around line 85):
```typescript
private async processNext(): Promise<void> {
  // Only one at a time
  if (this.processing) {
    return;
  }

  // Get next pending CV
  const next = getNextQueuedCV();
  if (!next) {
    return;
  }

  this.processing = true;
  const { id, file_path } = next;

  console.log(`QueueManager: Processing CV ${id} (${file_path})`);

  // Mark as processing in DB and notify UI
  const startedAt = new Date().toISOString();
  updateCVStatus(id, 'processing', { startedAt });
  this.notifyStatus({ id, status: 'processing' });

  // Timeout will start when Python confirms processing has begun
  let timeoutId: NodeJS.Timeout | null = null;

  try {
    // Pass callback to extractCV - timeout starts when Python ACKs
    const result = await extractCV(file_path, () => {
      // Python has confirmed processing started - NOW start timeout
      console.log(`QueueManager: Python ACK received for CV ${id}, starting ${this.timeoutMs}ms timeout`);
      timeoutId = setTimeout(() => {
        this.handleTimeout(id);
      }, this.timeoutMs);
    }) as ParsedCV;

    // Clear timeout - processing succeeded
    if (timeoutId) clearTimeout(timeoutId);

    // Save extracted data and mark completed
    completeCVProcessing(id, result);

    console.log(`QueueManager: Completed CV ${id}`);

    // Notify UI with result
    this.notifyStatus({
      id,
      status: 'completed',
      data: result,
      parseConfidence: result.parse_confidence,
    });
  } catch (error) {
    // Clear timeout if set
    if (timeoutId) clearTimeout(timeoutId);

    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`QueueManager: Failed CV ${id}:`, errorMessage);

    // Mark as failed in DB
    updateCVStatus(id, 'failed', { error: errorMessage });

    // Notify UI
    this.notifyStatus({
      id,
      status: 'failed',
      error: errorMessage,
    });
  }

  this.processing = false;

  // Process next in queue
  this.processNext();
}
```

Key changes:
- REMOVED the setTimeout before extractCV (was at line 109)
- ADDED callback to extractCV that starts timeout when Python ACKs
- Changed timeoutId to be nullable, check before clearing
- Added console.log when ACK received for debugging

The flow is now:
1. processNext() starts, marks CV as 'processing'
2. extractCV() called with callback
3. Request sent to Python
4. Python sends ACK immediately when it starts processing
5. pythonManager receives ACK, calls the callback
6. QueueManager callback fires, starts 120s timeout NOW
7. Python finishes, sends final response
8. Timeout cleared on success/error

This ensures timeout measures ONLY actual Python processing time, not queue wait time.
  </action>
  <verify>
1. TypeScript compiles:
```bash
npx tsc --noEmit && npm run lint
```

2. Run the app and process CVs:
- Console should show: "QueueManager: Processing CV X"
- Then shortly after: "QueueManager: Python ACK received for CV X, starting 120000ms timeout"
- The ACK log should appear BEFORE the extraction completes
  </verify>
  <done>
QueueManager timeout starts only after receiving processing_started callback from Python, not on submission. Single timeout boundary - no redundant timeouts.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile and lint check:**
```bash
npx tsc --noEmit && npm run lint
```

2. **Queue timing verification:**
Drop 3-5 CVs simultaneously and watch console logs:
- "Processing CV X" appears for CV 1 immediately
- "Python ACK received for CV X" appears when Python confirms
- CV 2's "Python ACK received" should NOT appear until CV 1 finishes
- Each CV gets full 120s from its ACK, not from submission

3. **Timeout behavior verification:**
- If Python takes >120s AFTER sending ACK, timeout fires
- If CV waits 90s in queue + 30s processing, NO timeout (processing is only 30s)

4. **No double timeout:**
- Only one timeout exists (QueueManager's)
- sendToPython for extractCV has 0 timeout
</verification>

<success_criteria>
- Python sends `{"type": "ack", "event": "processing_started", "id": "..."}` immediately when extract_cv begins
- pythonManager passes callback through and has NO internal timeout for extractCV
- QueueManager logs "Python ACK received" before starting timeout
- 5 queued CVs: CV #5 gets full 120s processing time even after waiting 120s+ in queue
- Single timeout boundary - no redundant timeouts causing confusion
</success_criteria>

<output>
After completion, create `.planning/phases/04.6-queue-infrastructure-persistence/04.6-05-SUMMARY.md`
</output>
